<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="1. TCP的基本认识                           1.1 头部格式         源端口号&#x2F;目标端口号：分别表示发送方和接收方  序列号：用来保证传输的可靠性，原数据是随机生成的随机数，之后服务端和客户端每交互一次就叠加一次。用来解决网络收发包的乱序问题。  确认应答号：下一次收到数据期望的序列号，可以认为此前的序列号都">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP">
<meta property="og:url" content="https://www.arong.icu/post/56432/index.html">
<meta property="og:site_name" content="阿荣的个人博客">
<meta property="og:description" content="1. TCP的基本认识                           1.1 头部格式         源端口号&#x2F;目标端口号：分别表示发送方和接收方  序列号：用来保证传输的可靠性，原数据是随机生成的随机数，之后服务端和客户端每交互一次就叠加一次。用来解决网络收发包的乱序问题。  确认应答号：下一次收到数据期望的序列号，可以认为此前的序列号都">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1681538502204-6f61e70a-3a10-427e-8f2f-45b7d3612fca.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1681540761397-b5876402-e4f2-48d1-9544-454d31f61eab.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1681572757056-f103cb9c-7088-416a-9d9e-b141b084b6c2.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1681634375484-9d1277eb-3ab7-48fe-aa30-9ae16305b331.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1681637532127-2e7b6ac6-f1c3-408d-804b-f4f93b4b1be3.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1683213868660-eb84aef1-f40d-40cb-abff-9c9a4c341f01.png">
<meta property="og:image" content="https://www.arong.icu/TCP.assets/1683213899231-4a98a853-41fe-47ef-9010-09c2de5e47a4.png">
<meta property="article:published_time" content="2023-03-15T09:52:42.000Z">
<meta property="article:modified_time" content="2023-09-07T04:16:46.988Z">
<meta property="article:author" content="Arong">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.arong.icu/TCP.assets/1681538502204-6f61e70a-3a10-427e-8f2f-45b7d3612fca.png"><title>TCP | 阿荣的个人博客</title><link ref="canonical" href="https://www.arong.icu/post/56432/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"恭喜您，复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner header-inner--height header-inner--bgcolor"><nav class="header-nav header-nav--sticky"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fa fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fa fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fa fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fa fa-user"></i></span><span class="header-nav-menu-item__text">博主</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/read/"><span class="header-nav-menu-item__icon"><i class="fa fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">TCP</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">49分</span></span></div></header><div class="post-body">
        <h1 id="1-TCP的基本认识"   >
          <a href="#1-TCP的基本认识" class="heading-link"><i class="fas fa-link"></i></a>1. TCP的基本认识</h1>
      
        <h2 id="1-1-头部格式"   >
          <a href="#1-1-头部格式" class="heading-link"><i class="fas fa-link"></i></a>1.1 头部格式</h2>
      <p><img src="/TCP.assets/1681538502204-6f61e70a-3a10-427e-8f2f-45b7d3612fca.png" alt="img"></p>
<ul>
<li><p>源端口号&#x2F;目标端口号：分别表示发送方和接收方</p>
</li>
<li><p>序列号：用来保证<strong>传输的可靠性</strong>，原数据是随机生成的随机数，之后服务端和客户端每交互一次就叠加一次。用来<strong>解决网络收发包的乱序问题</strong>。</p>
</li>
<li><p>确认应答号：下一次收到数据期望的序列号，可以认为此前的序列号都传输成功，用来<strong>解决网络丢包问题</strong>。</p>
</li>
<li><p>首部：表示TCP报文头部长度，按比例缩小进行存储。</p>
</li>
<li><p>控制位：</p>
</li>
<li><ul>
<li>URG(Urgent，紧急标志)：表示包中有需要紧急处理的数据，优先处理。</li>
<li>ACK(Acknowledgment，确认标志)：表示确认数据包已经收到。</li>
<li>PSH(Push，推送标志)：PSH为1，立即发送数据。PSH为0，先进行缓存。</li>
<li>RST(Reset，重置标志)：RST标志用于中止连接，用于解决网络连接问题。</li>
<li>SYN(Synchronization，同步标志)：这个位标志用于发起一个连接，建立连接并设置初始序列号。</li>
<li>FIN(Finish，完成标志)：表示终止TCP连接，用于数据传输完毕，此段连接不会再有数据往来。</li>
</ul>
</li>
<li><p>窗口大小：用于<strong>流量控制</strong>，分别表表明自己能够接受的流量大小。</p>
</li>
<li><p>校验和：确保数据传输没有被篡改，重新通过某种算法计算后得到的数。</p>
</li>
<li><p>紧急指针：当URG标志位为1的时候才存在该字段，表示该部分数据为紧急数据。</p>
</li>
<li><p>选项：用于优化TCP传输性能，对TCP功能做出解释，也是TCP总长度可变的原因。</p>
</li>
</ul>
<p>有的文章保留字段为4比特，标志位为8比特，有的文章保留字段为6比特，标志位为6比特。</p>

        <h2 id="1-2-TCP的意义和作用"   >
          <a href="#1-2-TCP的意义和作用" class="heading-link"><i class="fas fa-link"></i></a>1.2 TCP的意义和作用</h2>
      <p>TCP的<strong>面向连接</strong>的，<strong>可靠</strong>的，<strong>基于字节流</strong>的传输。</p>
<p>ip层是不可靠的，其只负责将数据传输到对应的主机，保证数据在网络传输之间不丢失，但是能够<strong>按序到达</strong>，<strong>数据内容的完整</strong>无法保证。所以tcp层的出现正是为了保证数据的安全性。</p>
<ol>
<li>面向连接：只有建立起来连接，才能进行数据的传输。即只有一对一的连接。保证了数据之间传输的<strong>安全</strong>。</li>
<li>可靠性：更加偏向于一个目的的描述，保证数据包发送之后能<strong>可靠的</strong>到达目的地。</li>
<li>基于字节流：应用程序对数据的发送和接收是<strong>没有边界限制</strong>的，为了保证其<strong>有序性</strong>，同时也可以针对其特性建立<strong>缓存区</strong>，将传输的若干数量包拼装完成后再接收。</li>
</ol>
<p>RFC 793定义的连接：</p>
<p><em>Connections: The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including</em> <em>sockets</em><em>,</em> <em>sequence numbers</em><em>, and</em> <em>window sizes</em><em>, is called a connection.</em></p>
<p>从中我们可以看出一个TCP连接中主要包含着三个关键信息：</p>
<ul>
<li>sockets：由ip地址和端口号组成，用于确认地址信息</li>
<li>sequence numbers：随机序列号，用来确保传输的有序和安全</li>
<li>window sizes：窗口大小，用来进行流量控制</li>
</ul>

        <h2 id="1-3-如何确定一个TCP连接"   >
          <a href="#1-3-如何确定一个TCP连接" class="heading-link"><i class="fas fa-link"></i></a>1.3 如何确定一个TCP连接</h2>
      <p><strong>TCP四元组</strong>可以确定一个唯一的TCP连接：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p>求一个端口能够监听的最大TCP连接数</p>
<p>最大TCP连接数 &#x3D; 客户端IP地址数量 * 客户端端口数量</p>

        <h2 id="1-4-TCP和UDP的区别"   >
          <a href="#1-4-TCP和UDP的区别" class="heading-link"><i class="fas fa-link"></i></a>1.4 TCP和UDP的区别</h2>
      <p><img src="/TCP.assets/1681540761397-b5876402-e4f2-48d1-9544-454d31f61eab.png" alt="img"></p>
<p>这里要注意包长度指的是整个UDP的长度，包含数据。校验和为了防止收到损坏的数据包。</p>
<ol>
<li><strong>连接</strong></li>
</ol>
<ul>
<li>TCP是面向连接的协议，他需要经过确定连接之后才可以进行数据的传输。</li>
<li>UDP是无连接协议，数据即刻传输</li>
</ul>
<ol>
<li><strong>服务对象</strong></li>
</ol>
<ul>
<li>TCP只支持一对一的服务，这是他面向连接的特点决定的</li>
<li>UDP支持一对一，一对多，多对多的数据传输</li>
</ul>
<ol>
<li><strong>可靠性</strong></li>
</ol>
<ul>
<li>TCP的可靠性较高，数据丢包和被篡改的风险较低下</li>
<li>UDP的可靠性较低，但其也有其改进版本增强其可靠性，如QUIC协议。</li>
</ul>
<ol>
<li><strong>拥塞控制</strong></li>
</ol>
<ul>
<li>TCP通过头部的窗口大小字段告诉传输方自己最大承受数据的能力，是有限制的。</li>
<li>UDP则因为其无连接特性，数据包可以在网络连接中停留拥塞，故可无后顾之忧的发送</li>
</ul>
<ol>
<li><strong>头部开销</strong></li>
</ol>
<ul>
<li>TCP的头部长度为20个字节加上选项</li>
<li>UDP的头部长度为8个字节，且固定</li>
</ul>
<ol>
<li><strong>传输方式</strong></li>
</ol>
<ul>
<li>TCP采用流式传输方式，保证有序及可靠</li>
<li>UDP采用数据包传输方式，是有边界的，可能会导致传输的乱序问题。</li>
</ul>
<ol>
<li><strong>分片方式</strong></li>
</ol>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<ol>
<li><strong>应用场景</strong></li>
</ol>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li>FTP 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、SNMP 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>

        <h2 id="1-5-TCP和UDP可共用一个端口号吗"   >
          <a href="#1-5-TCP和UDP可共用一个端口号吗" class="heading-link"><i class="fas fa-link"></i></a>1.5 TCP和UDP可共用一个端口号吗</h2>
      <p><strong>可以的。</strong></p>
<p>传输层端口号的作用是：用于区分同一台主机上不同应用程序的数据包</p>
<p>UDP和TCP是传输层的两个完全不一样的传输协议。</p>
<p>主机接收到数据包之后，首先会根据头部的格式判断出到底是UDP协议还是TCP协议，再交由相应的软件板块进行传输。</p>

        <h1 id="2-TCP的连接确立"   >
          <a href="#2-TCP的连接确立" class="heading-link"><i class="fas fa-link"></i></a>2. TCP的连接确立</h1>
      <p>三次握手是TCP连接最最最重要，也是最最最基础的点。但是也要记住，这个过程是数据传输的<strong>准备</strong>工作，其目的只是为客户端和服务端<strong>建立起连接</strong>，确保其能无误收发数据。</p>

        <h2 id="2-1-三次握手总流程图"   >
          <a href="#2-1-三次握手总流程图" class="heading-link"><i class="fas fa-link"></i></a>2.1 三次握手总流程图</h2>
      <p><img src="/TCP.assets/1681572757056-f103cb9c-7088-416a-9d9e-b141b084b6c2.png" alt="img"></p>
<ul>
<li><strong>第一次握手：</strong></li>
</ul>
<p>服务端没有收到请求的时候，处于<code>listen</code>状态，同时的，<strong>客户端发起请求</strong>，发送标志位为1的<code>syn</code>和<code>client_isn</code>，表示请求连接，客户端自身进入<code>syn_send</code>状态。</p>
<ul>
<li><strong>第二次握手：</strong></li>
</ul>
<p>本次由<strong>服务端首先发起请求</strong>，其发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。至此，<strong>服务端告诉客户端自己能够收到他的信息</strong>。之后，发送标志位为1的<code>syn</code>和<code>service_isn</code>，<strong>用于确认客户端能否收到自己的信息</strong>，同时自身进入<code>syn_revd</code>状态。</p>
<ul>
<li><strong>第三次握手：</strong></li>
</ul>
<p>本次握手由客户端发送，表示自己收到了服务端的请求并告知，发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。其后，进入<code>Established</code>状态，表示准备就绪，可以进行数据传输，服务端收到客户端发送的Ack，也同时进入<code>Established</code>状态，至此，三次握手完成。</p>

        <h2 id="2-2-握手的数量为3的原因"   >
          <a href="#2-2-握手的数量为3的原因" class="heading-link"><i class="fas fa-link"></i></a>2.2 握手的数量为3的原因</h2>
      <p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>可以看到，三次握手的主要原因是为了<strong>防止旧的连接重复初始化导致连接混乱。</strong></p>
<p>通过头部中的序列号和确认应答号可以校验连接双方是否昔日故人，如果是再进行数据传输。少掉任意一次连接，都会造成客户端或者服务端无法对对方身份的确认。这三次连接实质上是不可或缺的<strong>两问两答</strong>。</p>
<p>而连接混乱造成的后果则是<strong>资源的浪费</strong>。用旧的无意义的连接传输资源，最后得到的也是无法使用的资源。</p>

        <h2 id="2-3-初始序列号ISN意义及如何生成"   >
          <a href="#2-3-初始序列号ISN意义及如何生成" class="heading-link"><i class="fas fa-link"></i></a>2.3 初始序列号ISN意义及如何生成</h2>
      <p>起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：<code>ISN = M + F(localhost, localport, remotehost, remoteport)</code>。</p>
<ul>
<li>M 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li>F 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口</strong>生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<ul>
<li>意义：防止旧的报文被新的连接接收</li>
</ul>

        <h2 id="2-4-握手报文丢失，双方怎么办"   >
          <a href="#2-4-握手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>2.4 握手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h2 id="2-5-SYN攻击是什么，如何防范"   >
          <a href="#2-5-SYN攻击是什么，如何防范" class="heading-link"><i class="fas fa-link"></i></a>2.5 SYN攻击是什么，如何防范</h2>
      <p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列，对应着三次握手中的<code>syn_revd</code>状态；</li>
<li>全连接队列，也称 accept 队列，对应着三次握手中的<code>Established</code>状态；</li>
</ul>
<p>SYN攻击指的是对于服务器的SYN队列进行<code>ddos</code>攻击，<strong>发送大量的请求</strong>，这时候服务端会产生大量的<code>ACK+SYN</code>加以应答，但是因为客户端是不存在的，所以服务器始终等不到客户端发送过来的<code>ACK</code>，<strong>该批请求也就无法由SYN队列进入到accept队列</strong>，随着SYN队列被占满，服务器再也无法接受请求。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>

        <h1 id="3-TCP断开连接"   >
          <a href="#3-TCP断开连接" class="heading-link"><i class="fas fa-link"></i></a>3. TCP断开连接</h1>
      
        <h2 id="3-1-四次挥手总流程图"   >
          <a href="#3-1-四次挥手总流程图" class="heading-link"><i class="fas fa-link"></i></a>3.1 四次挥手总流程图</h2>
      <p><img src="/TCP.assets/1681634375484-9d1277eb-3ab7-48fe-aa30-9ae16305b331.png" alt="img"></p>
<ul>
<li>首先，客户端服务端双方起始都是可以传输数据的<code>Established</code>状态，正式进入四次挥手断开连接</li>
<li><em><strong>第一次挥手：</strong></em>客户端发送带有<code>FIN</code>标志位的报文，<strong>表示想终止这次连接</strong>，之后进入<code>FIN_WAIT1</code>阶段。</li>
<li>*<strong>第二次挥手：*<strong>服务端收到客户端发送的<code>FIN</code>报文，发送带有<code>ACK</code>头部的确认报文给客户端，表示自己已经收到。随后进入<code>Closed_Wait</code>阶段，</strong>表示等待连接的关闭</strong>，客户端接收到<code>ACK</code>确认报文后进入<code>FIN_WAIT2</code>阶段</li>
<li><em><strong>第三次挥手：</strong></em>服务端将自己想要发送给客户端的信息处理完之后发送<code>FIN</code>报文，表示<strong>服务端已没有信息需要发送给客户端</strong>。随后进入<code>Last_Ack</code>阶段，表示等待客户端的最后一次回应。</li>
<li>*<strong>第四次挥手：*<strong>客户端接受到服务端的<code>FIN</code>报文后，发送<code>ACK</code>确认报文给服务端。之后</strong>进入为期</strong><code>**2MSL**</code><strong>的</strong><code>**TIME_WAIT**</code><strong>阶段</strong>，之后断开连接。服务端收到应答之后断开连接。</li>
</ul>
<p>只有在主动发起断开连接的一方才会有<code>time_wait</code>阶段</p>

        <h2 id="3-2-服务端的SYN和ACK可否合并"   >
          <a href="#3-2-服务端的SYN和ACK可否合并" class="heading-link"><i class="fas fa-link"></i></a>3.2 服务端的SYN和ACK可否合并</h2>
      <p>在四次挥手的过程中，服务端在两个报文中间有一段<code>closed_wait</code>的阶段，那么该阶段可否跳过省略呢</p>

        <h3 id="为什么会有closed-wait的阶段"   >
          <a href="#为什么会有closed-wait的阶段" class="heading-link"><i class="fas fa-link"></i></a>为什么会有closed_wait的阶段</h3>
      <p>首先我们要知道服务端在<code>closed_wait</code>这段时间内做了什么，他主要的作用就是来处理数据，检查是否还有没发送给客户端的数据，如果有，就发送给客户端。<code>FIN</code>标志位的意思是所有数据发送完毕，想要断开请求，所以必须检查数据是否完毕。</p>
<p>他主要实现的原理是在收到客户端发送的<code>FIN</code>报文之后，将一个结束标识符<code>EOF</code>放在待处理数据的末尾，由于TCP的流传输特性，所以之后当服务端将所有数据处理完，才会读取到<code>EOF</code>，读取到<code>EOF</code>之后，才会向服务端发送<code>FIN</code>报文。</p>

        <h3 id="三次连接是否可以实现？"   >
          <a href="#三次连接是否可以实现？" class="heading-link"><i class="fas fa-link"></i></a>三次连接是否可以实现？</h3>
      <p>可以实现，条件是需要<strong>开启TCP延时确认机制</strong>并且服务端<strong>没有数据要发送</strong>。</p>

        <h3 id="TCP延时确认机制"   >
          <a href="#TCP延时确认机制" class="heading-link"><i class="fas fa-link"></i></a>TCP延时确认机制</h3>
      <p>服务端当收到客户端发送过来的<code>FIN</code>信息之后，需要回复<code>ACK</code>报文，如果只单单传输一个20字节的报文头部不携带任何报文信息，而后续需要发送的报文又独立发送，就会造成网络资源的浪费（因为内容和头部是始终需要携带的）。那么为了<strong>提高网络资源的利用效率</strong>，TCP延时确认机制产生，它主要做了下面三件事：</p>
<ul>
<li>当有响应数据需要发送时，数据会随着<code>ACK</code>头部一起发送。</li>
<li>当没有响应数据需要发送时候，服务端会等待一段时间，已确定有没有数据需要发送进而一起发送。</li>
<li>当在等待响应数据时，若又有一个请求发送过来，那么<code>ACK</code>头就会立刻发送。</li>
</ul>
<p>延迟等待时间由<code>TCP_DELACK_MIN</code>和<code>TCP_DELACK_MAX</code>决定。linux内核中默认为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP_DELACK_MIN = HZ/5</span><br><span class="line">TCP_DELACK_MIN = HZ/25</span><br></pre></td></tr></table></div></figure>

<p>HZ与系统的时钟周期频率相关。</p>
<p><img src="/TCP.assets/1681637532127-2e7b6ac6-f1c3-408d-804b-f4f93b4b1be3.png" alt="img"></p>
<p>TCP延时确认机制是默认开启的</p>

        <h3 id="三次连接实现原理"   >
          <a href="#三次连接实现原理" class="heading-link"><i class="fas fa-link"></i></a>三次连接实现原理</h3>
      <p>当没有数据要发送的时候，那么服务端可以直接读取到<code>EOF</code>，准备发送带有<code>FIN</code>的报文，但是因为延时确认机制，原先的<code>ACK</code>报文还没有发送，那么就将<code>FIN</code>一起写到<code>ACK</code>中，之后，<strong>等待一段时间或者知道客户端再次发送请求</strong>（分别对应了其2，3情况），那么这个没有数据但是含有<code>ACK</code>和<code>FIN</code>头部信息的报文就直接发送了。</p>

        <h2 id="3-3-挥手报文丢失，双方怎么办"   >
          <a href="#3-3-挥手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>3.3 挥手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h3 id="close和shutdown方法的比较"   >
          <a href="#close和shutdown方法的比较" class="heading-link"><i class="fas fa-link"></i></a>close和shutdown方法的比较</h3>
      <p>两者都是用于对进程的关闭，但是shutdown关闭的是该进程的发送信息功能，而接受信息功能仍然存在，close则是两个功能都将其关闭。</p>

        <h3 id="在第二次挥手中，客户端shutdown了"   >
          <a href="#在第二次挥手中，客户端shutdown了" class="heading-link"><i class="fas fa-link"></i></a>在第二次挥手中，客户端shutdown了</h3>
      <p>这是一个十分有趣的情况，第二次挥手是由服务端对于客户端的<code>FIN</code>标志的回应，发送了<code>ACK</code>确认标志，如果服务端始终不发送过来第三次挥手，正常情况下客户端是需要重发<code>FIN</code>请求的，但是因为此时客户端的<code>shutdown</code>，使得其无法发送，那么最后造就的结果便是客户端一直在<code>FIN_WAIT2</code>这个阶段卡住，无法关闭。服务端重发请求到达上限时间次数便会自己断开连接。</p>

        <h2 id="3-4-TIME-WAIT状态"   >
          <a href="#3-4-TIME-WAIT状态" class="heading-link"><i class="fas fa-link"></i></a>3.4 TIME_WAIT状态</h2>
      
        <h3 id="TIME-WAIT状态的时间是多少"   >
          <a href="#TIME-WAIT状态的时间是多少" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态的时间是多少</h3>
      <p>2MSL（Maximum Segment Lifetime，报文最大生存时间）。非常巧合的是，我们发现，这个时间便是一次<strong>客户端和服务端之间交互一来一回</strong>的时间。</p>

        <h3 id="TIME-WAIT状态存在的原因"   >
          <a href="#TIME-WAIT状态存在的原因" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态存在的原因</h3>
      <ul>
<li><em>确保新的相同的四元组TCP连接不要接收到旧的报文信息。</em></li>
</ul>
<p>主要是<strong>为了避免第四次挥手的丢失，</strong>客户端发送完成第四次挥手<code>ACK</code>之后就断开连接，那么万一服务端没有收到<code>ACK</code>确认，又重发了一次<code>FIN</code>，此时客户端无法收到他的请求。此时恰好又有一个相同的四元组TCP连接建立了起来，这时候旧的<code>FIN</code>或者数据就会发送到新的连接。会客户端收到错误的信息或者造成新的连接无法将其信息发送完整就断开连接。</p>
<ul>
<li><em>保证被动关闭的一方能够</em>***正常关闭***<em>。</em></li>
</ul>
<p>还是基于第四次挥手的丢失，服务端重新发送<code>FIN</code>报文之后，因为客户端已经关闭，所以无法收到他的<code>ACK</code>报文，那么最后关闭只能是因为超时被动断开连接了。这样既浪费了服务器资源，又对于服务器是有危害的。</p>

        <h3 id="TIME-WAIT状态过多的危害"   >
          <a href="#TIME-WAIT状态过多的危害" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态过多的危害</h3>
      <p>TIME_WAIT状态其实是一种阻塞的表现，等待至少2MSL的时间，而这个时间对<strong>端口号</strong>来说是占用的。如果网络不通畅，那么端口号资源就被占用的极多，就会无法对于服务端建立连接了。会占用<strong>系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>

        <h3 id="如何优化-TIME-WAIT？"   >
          <a href="#如何优化-TIME-WAIT？" class="heading-link"><i class="fas fa-link"></i></a>如何优化 TIME_WAIT？</h3>
      <ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p>第一二种方法主要是通过控制<code>TIME_WAIT</code>的时间加以控制，第三种方法则是直接跨过了<code>TIME_WAIT</code>。都存在着一定上诉提到的风险。</p>

        <h3 id="long-alive-长连接状态"   >
          <a href="#long-alive-长连接状态" class="heading-link"><i class="fas fa-link"></i></a>long-alive 长连接状态</h3>
      <p>这个状态我们可以在请求报文的头部信息中看到，开启状态表示一次请求交互完成之后<strong>不立刻断开，也就表示着后面还有请求需要进行处理</strong>。那么如果每次请求都进行握手挥手网络资源消耗量极大，于是用长连接状态表示不立刻断开。如果交互确实进行完成，那么<strong>只要有一方</strong>发送断开连接请求，那么就会来到四次挥手的状态。</p>
<p><em>什么场景下服务端会主动断开连接呢？</em></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>

        <h2 id="3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"   >
          <a href="#3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="heading-link"><i class="fas fa-link"></i></a>3.5 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h2>
      <p>说明没有发出<code>FIN</code>报文，无法到达下一步<code>LAST_ACK</code>。那么也就是说无法调用<code>closed</code>方法。</p>
<p>通常是代码的问题，主要排查方向是为何服务端调用不到<code>closed</code>方法。</p>

        <h2 id="3-6-建立连接后一方发生故障会怎么样？"   >
          <a href="#3-6-建立连接后一方发生故障会怎么样？" class="heading-link"><i class="fas fa-link"></i></a>3.6 建立连接后一方发生故障会怎么样？</h2>
      
        <h3 id="保活机制"   >
          <a href="#保活机制" class="heading-link"><i class="fas fa-link"></i></a>保活机制</h3>
      <p>通过开启<code>SO_KEEPALIVE</code> 选项生效。</p>
<p>在一个时间段内，如果<strong>任何连接相关的传输的活动</strong>都没有产生，那么每隔一个时间段就发送一次探测报文，如果均没有得到回应，就断定该TCP连接已经死亡。</p>
<p>linux中默认参数如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">7200</span> <span class="comment">//没有活动的时间长度</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl=<span class="number">75</span>  <span class="comment">//发送探测报文的相隔时间段</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">9</span>	 <span class="comment">// 发送探测报文的次数</span></span><br></pre></td></tr></table></div></figure>

<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>

        <h3 id="进程突然被closed"   >
          <a href="#进程突然被closed" class="heading-link"><i class="fas fa-link"></i></a>进程突然被closed</h3>
      <p>如前文所讲，挥手报文丢失的情况。</p>

        <h3 id="主机突然发生宕机"   >
          <a href="#主机突然发生宕机" class="heading-link"><i class="fas fa-link"></i></a>主机突然发生宕机</h3>
      <p>客户端主机崩溃了，服务端是<strong>无法感知到</strong>的，在保活机制时间激活之前，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，在双方不传输数据的情况下，<strong>一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</strong></p>

        <h3 id="客户端的网络连接突然断开"   >
          <a href="#客户端的网络连接突然断开" class="heading-link"><i class="fas fa-link"></i></a>客户端的网络连接突然断开</h3>
      <p>TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p>换而言之，TCP连接一旦建立，就生成了两个独立的结构存储在<strong>本地</strong>，和传输层的连接关系已然不大。</p>
<p>之后，发送就如同进程被closed的状态，直至重新连上网络，方可恢复正常。</p>

        <h1 id="4-TCP的四个机制"   >
          <a href="#4-TCP的四个机制" class="heading-link"><i class="fas fa-link"></i></a>4. TCP的四个机制</h1>
      
        <h2 id="4-1-重传机制"   >
          <a href="#4-1-重传机制" class="heading-link"><i class="fas fa-link"></i></a>4.1 重传机制</h2>
      
        <h3 id="超时重传"   >
          <a href="#超时重传" class="heading-link"><i class="fas fa-link"></i></a>超时重传</h3>
      <p>顾名思义，<strong>超时重传指的是当发送方超过一定时间没有收到回复的时候，重新发送数据报文。</strong></p>
<ul>
<li><strong>RTT（Routing-trip time）</strong>往返时延，指的是一个数据包从发送到接受到回应所需要经过的时间长度</li>
<li>**RTO (**<strong>Retransmission Timeout</strong> <strong>)</strong> 超时发送时间，指的是超时重传的时间。</li>
</ul>
<p>一般在超时重传机制中，RTO会略大于RTT。</p>
<p>RTO太大或者太小的坏处：</p>
<ul>
<li><strong>太大</strong>：<strong>浪费网络资源，网络收发包效率低下，影响用户体验。</strong>首先发送等待请求的时候，发送方就无法给其他主机发送信息，RTO过长会导致发送方资源的浪费。而且响应的时间变慢，网络传输效率低下，影响了用户的体验。</li>
<li><strong>太小</strong>：<strong>浪费了传输的资源，增加网络阻塞。</strong>也许是回应包还没有发送到，就重新发送，这样会导致发送了两个相同的数据包，对传输资源是一种浪费。</li>
</ul>
<p><strong>超时重传的弊端</strong>：时间过久，影响用户体验。</p>

        <h3 id="快速重传"   >
          <a href="#快速重传" class="heading-link"><i class="fas fa-link"></i></a>快速重传</h3>
      <p>快速重传的工作原理是<strong>收到三个相同的ACK报文时，再发送一次ACK报文下一个的请求报文。</strong></p>
<p>因为TCP连接中基于字节流的特性，报文的传输是有序的，因此响应的ACK所发送过来的序列号就表示该序列号之前的所有报文都已经接收完成。但是后面的响应生死未卜。所以快速重传机制会认为对方没有接收到后续的请求报文，所以重新发送一遍。</p>
<p>但是这种做法存在着问题，你<strong>后面的数据包有多少是没有收到的</strong>，发送方要重新发送多少数据包，这些是快速重传无法得知的，所以我们有了<code>SACK</code>重传机制。</p>

        <h3 id="SACK-amp-amp-D-SACK"   >
          <a href="#SACK-amp-amp-D-SACK" class="heading-link"><i class="fas fa-link"></i></a>SACK &amp;&amp; D-SACK</h3>
      <p>SACK(select-acknowledge) 选择性确认，接收方发送ACK响应的时候，会告诉发送方自己接受到了哪些数据。这能够解决快速重传机制存在的问题。D-SACK（Duplicate SACK），D-SACK告诉发送方那些数据是重复发送的。</p>

        <h2 id="4-2-滑动窗口"   >
          <a href="#4-2-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4.2 滑动窗口</h2>
      <p>TCP头部信息中的窗口大小（16位）指的就是这个窗口的大小。指的是接受数据的能力。<strong>在未接受到接受方的应答（数据还没有被处理）的时候，发送方能发送的数据总容量大小。</strong>通常该属性由接收方的窗口大小决定。</p>

        <h3 id="发送方的窗口大小参数"   >
          <a href="#发送方的窗口大小参数" class="heading-link"><i class="fas fa-link"></i></a>发送方的窗口大小参数</h3>
      <ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA（Send Unacknoleged）</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。<strong>可用窗口大小 &#x3D;</strong> <code>**SND.WND -(SND.NXT - SND.UNA)**</code></li>
</ul>

        <h2 id="4-3-流量控制"   >
          <a href="#4-3-流量控制" class="heading-link"><i class="fas fa-link"></i></a>4.3 流量控制</h2>
      <p>TCP一般会使用<strong>滑动窗口机制</strong>来进行流量控制，简单来讲，就是接收方通过发送窗口的大小来告诉发送方，我还有多少地方可以承受你发的数据，如果太多的话，会造成丢包的情况。</p>

        <h3 id="丢包情况"   >
          <a href="#丢包情况" class="heading-link"><i class="fas fa-link"></i></a>丢包情况</h3>
      <p>但是在业务繁忙的时候，丢包情况也会发生。很简单的一个例子，当接收方窗口大小发生改变的时候，他会立刻发送报文告知发送方，但是发送方在接收到接收方发送的报文之前，就已经将一条数据容量超过窗口大小的数据发送给接收方，那么这时候就会产生丢包的现象。</p>

        <h3 id="死锁情况"   >
          <a href="#死锁情况" class="heading-link"><i class="fas fa-link"></i></a>死锁情况</h3>
      <p>这里指的是双方都无从得知对方的状态，从而进入了相对隔离的，无法更新对方信息的状态。那么造成这种结果的原因是：<strong>接收方更新窗口大小为非0的报文丢失在了网络中</strong>，这种情况下，发送方不知道对方已经处理完成信息了，会一直等待，而接收方也在一直等待发送方发送过来的信息。</p>
<ul>
<li>解决方法：</li>
</ul>
<p><strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>这个计时器会在没有收到窗口信息传递报文的一定时间内，发送窗口探测报文，而接收方一旦收到这个报文，就会将自己目前的窗口大小发送。通过外界的力量打破了两者之间相互隔离的状态。</p>

        <h3 id="糊涂窗口综合症"   >
          <a href="#糊涂窗口综合症" class="heading-link"><i class="fas fa-link"></i></a>糊涂窗口综合症</h3>
      <p>这里指的是发送方太过于急于求成，可以算是一种贪心算法。只要接收方告诉发送方自己目前有多少个字节的窗口，那么发送方就会毫不犹豫的发送这么多字节的包过去。</p>
<p>但是这样有一个缺点，万一接收方剩余的窗口很小，而TCP的头部是需要占掉很大一部分的，所以说有时候是一笔得不偿失的交易。</p>
<p>那么为了避免这种情况，发送方针对发送数据的大小做出了规定：</p>
<p>接收方采用的策略如下：</p>
<p>不发送小窗口给发送方</p>
<p>发送方通常的策略如下:</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; MSS 并且 数据大小 &gt;&#x3D; MSS；</li>
<li>条件二：收到之前发送数据的 ack 回包；</li>
</ul>

        <h2 id="4-4-拥塞控制"   >
          <a href="#4-4-拥塞控制" class="heading-link"><i class="fas fa-link"></i></a>4.4 拥塞控制</h2>
      <p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少；</li>
</ul>
<p>拥塞控制主要有如下四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>

        <h3 id="慢启动"   >
          <a href="#慢启动" class="heading-link"><i class="fas fa-link"></i></a>慢启动</h3>
      <p>慢启动的意思就是一点一点的提高发送数据包的数量，<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong>慢启动的增长为指数型增长。</p>
<p>有一个叫慢启动门限 <code>ssthresh （slow start threshold）</code>状态变量。</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p>一般来说 ssthresh 的大小是 65535 字节。</p>

        <h3 id="拥塞避免"   >
          <a href="#拥塞避免" class="heading-link"><i class="fas fa-link"></i></a>拥塞避免</h3>
      <p><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong>它属于线性增长，增长较慢。</p>

        <h3 id="拥塞发生"   >
          <a href="#拥塞发生" class="heading-link"><i class="fas fa-link"></i></a>拥塞发生</h3>
      <p>就是在拥塞时，将窗口大小紧急下降。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li>
<li>ssthresh &#x3D; cwnd;</li>
<li>进入快速恢复算法</li>
</ul>

        <h3 id="快速恢复"   >
          <a href="#快速恢复" class="heading-link"><i class="fas fa-link"></i></a>快速恢复</h3>
      <p>进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>

        <h1 id="5-TCP优化的连接"   >
          <a href="#5-TCP优化的连接" class="heading-link"><i class="fas fa-link"></i></a>5. TCP优化的连接</h1>
      
        <h2 id="5-1-从三次握手的角度进行优化"   >
          <a href="#5-1-从三次握手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.1 从三次握手的角度进行优化</h2>
      <p>因为<strong>三次握手是服务端和客户端之间建立联系的前提条件</strong>，不涉及到任何具体传输数据的传输，而只是进行了<strong>一些状态和校验的传输</strong>。因为正常情况下的用时基本可以忽略不记。所以我们可以将优化点放在具体传输的<strong>异常状态</strong>中，去通过调节参数来对三次握手进行加速。</p>

        <h3 id="5-1-1-超时重传的参数调节-client"   >
          <a href="#5-1-1-超时重传的参数调节-client" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 超时重传的参数调节(client)</h3>
      <p>在网络状态堵塞的情况下，超时重传是不可避免的。但是超时了时候重传几次，采取什么策略。就会对于网络连接的效率起到一定的影响作用。</p>
<ul>
<li><strong>超时重传的次数过少：</strong>可能会引发重复传输，影响网络的资源利用率。只是因为网络拥堵，数据包没有丢失只是到达的时间较慢。而在发送一次请求只会对于本就拥塞的网络进行加塞。</li>
<li><strong>超时重传的次数过多：</strong>可能没办法及时发现问题，让一个达不到目的地，没有接收到的连接一直占用着网络资源。导致网络资源利用率的下降。</li>
</ul>
<p><strong>如何调节超时重传次数：</strong>通过控制<code>tcp_syn_retries</code>参数来控制重传次数。在linx内核中默认值为<code>5</code>，每次超时重传的时间为上一次的两倍。初始值为<code>1</code></p>

        <h3 id="5-1-2-半连接队列的参数调节-service"   >
          <a href="#5-1-2-半连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 半连接队列的参数调节(service)</h3>
      <p>半连接队列指的是服务端接受到客户端的第一次握手请求发送的时候，会将这个连接的中间态放到半连接队列中，<strong>主要用来存储准备启用但尚未启用的连接</strong>。那么对于三次握手的<code>SYN攻击</code>指的是通过不断发送只发送第一次请求的连接，将半连接队列占满，使得后面与服务端请求的连接无法获得通讯。那么怎么去尽量避免这种情况呢，有如下两种做法：</p>
<ul>
<li>调节syn队列的大小：通过调节<code>somaxconn</code>, <code>backlog</code>, <code>tcp_max_syn_conn</code>三个参数来共同调节syn队列的大小，其中，前两个参数是调整<code>accept</code>队列的大小，但是也能够同时调整到半连接队列的大小。</li>
<li>通过设置<code>synCookie</code>参数来进行调节： 这个cookie的主要作用是存储半连接队列中连接的信息。将这个信息连同第二次握手一起发送，这样就可以替代半连接队列的作用了。但是也不能一直开启，一直开启就表示忽略半连接队列，将之前的信息全部再做一次传输，那么服务器的压力就会增大。</li>
</ul>
<p>syn_cookie有三个值：0表示不开启，1表示当半连接队列满时开启，2表示一直开启。默认为1</p>

        <h3 id="5-1-3-全连接队列的参数调节-service"   >
          <a href="#5-1-3-全连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 全连接队列的参数调节(service)</h3>
      <p><code>tcp_abort_on_overflow</code> 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；</li>
<li>1 ：如果 accept 队列满了，server 发送一个 RST 包给 client，表示废掉这个握手过程和这个连接；</li>
</ul>
<p><code>accept</code>队列的长度取决于 <code>somaxconn</code> 和 <code>backlog</code> 之间的最小值，也就是 <code>min(somaxconn, backlog)</code>，</p>

        <h3 id="5-1-4-如何绕过三次握手"   >
          <a href="#5-1-4-如何绕过三次握手" class="heading-link"><i class="fas fa-link"></i></a>5.1.4 如何绕过三次握手</h3>
      <p>linux3.7 版本后，提供了<code>tcp fast open</code>的方式：</p>
<p>在客户端首次建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</p>
<p>节约了一个TTL的时间。</p>

        <h2 id="5-2-从四次挥手的角度进行优化"   >
          <a href="#5-2-从四次挥手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.2 从四次挥手的角度进行优化</h2>
      <p><img src="/TCP.assets/1683213868660-eb84aef1-f40d-40cb-abff-9c9a4c341f01.png" alt="img"></p>
<p><strong>主动方的优化</strong></p>
<p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</p>
<p>当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：</p>
<ul>
<li>如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 <code>tcp_fin_timeout</code> 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，<code>tcp_max_orphans</code> 定义了最大孤儿连接的数量，超过时连接就会直接释放。</li>
<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li>
</ul>
<p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，<code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p>
<p><strong>被动方的优化</strong></p>
<p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p>
<p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文。</p>

        <h2 id="5-3-传输过程中进行优化"   >
          <a href="#5-3-传输过程中进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.3 传输过程中进行优化</h2>
      <p><img src="/TCP.assets/1683213899231-4a98a853-41fe-47ef-9010-09c2de5e47a4.png" alt="img"></p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://www.arong.icu">Arong</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://www.arong.icu/post/56432/">https://www.arong.icu/post/56432/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="https://www.arong.icu/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/post/11079/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">2.LinkList</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/post/35944/"><span class="paginator-prev__text">HTTP</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-TCP%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">
          1. TCP的基本认识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">
          1.1 头部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-TCP%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">
          1.2 TCP的意义和作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.</span> <span class="toc-text">
          1.3 如何确定一个TCP连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.</span> <span class="toc-text">
          1.4 TCP和UDP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-TCP%E5%92%8CUDP%E5%8F%AF%E5%85%B1%E7%94%A8%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%B7%E5%90%97"><span class="toc-number">1.5.</span> <span class="toc-text">
          1.5 TCP和UDP可共用一个端口号吗</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E7%A1%AE%E7%AB%8B"><span class="toc-number">2.</span> <span class="toc-text">
          2. TCP的连接确立</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%80%BB%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">
          2.1 三次握手总流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%8F%A1%E6%89%8B%E7%9A%84%E6%95%B0%E9%87%8F%E4%B8%BA3%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.2.</span> <span class="toc-text">
          2.2 握手的数量为3的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7ISN%E6%84%8F%E4%B9%89%E5%8F%8A%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90"><span class="toc-number">2.3.</span> <span class="toc-text">
          2.3 初始序列号ISN意义及如何生成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%8F%A1%E6%89%8B%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%8F%8C%E6%96%B9%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">2.4.</span> <span class="toc-text">
          2.4 握手报文丢失，双方怎么办</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-SYN%E6%94%BB%E5%87%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83"><span class="toc-number">2.5.</span> <span class="toc-text">
          2.5 SYN攻击是什么，如何防范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.</span> <span class="toc-text">
          3. TCP断开连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%80%BB%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">
          3.1 四次挥手总流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84SYN%E5%92%8CACK%E5%8F%AF%E5%90%A6%E5%90%88%E5%B9%B6"><span class="toc-number">3.2.</span> <span class="toc-text">
          3.2 服务端的SYN和ACK可否合并</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89closed-wait%E7%9A%84%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">
          为什么会有closed_wait的阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.2.2.</span> <span class="toc-text">
          三次连接是否可以实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%BB%B6%E6%97%B6%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.3.</span> <span class="toc-text">
          TCP延时确认机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E8%BF%9E%E6%8E%A5%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.4.</span> <span class="toc-text">
          三次连接实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%8C%A5%E6%89%8B%E6%8A%A5%E6%96%87%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%8F%8C%E6%96%B9%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">3.3.</span> <span class="toc-text">
          3.3 挥手报文丢失，双方怎么办</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#close%E5%92%8Cshutdown%E6%96%B9%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">
          close和shutdown方法的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AFshutdown%E4%BA%86"><span class="toc-number">3.3.2.</span> <span class="toc-text">
          在第二次挥手中，客户端shutdown了</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-TIME-WAIT%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.</span> <span class="toc-text">
          3.4 TIME_WAIT状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="toc-number">3.4.1.</span> <span class="toc-text">
          TIME_WAIT状态的时间是多少</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E5%AD%98%E5%9C%A8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.4.2.</span> <span class="toc-text">
          TIME_WAIT状态存在的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIME-WAIT%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">3.4.3.</span> <span class="toc-text">
          TIME_WAIT状态过多的危害</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-TIME-WAIT%EF%BC%9F"><span class="toc-number">3.4.4.</span> <span class="toc-text">
          如何优化 TIME_WAIT？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#long-alive-%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.5.</span> <span class="toc-text">
          long-alive 长连接状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%87%BA%E7%8E%B0%E5%A4%A7%E9%87%8F-CLOSE-WAIT-%E7%8A%B6%E6%80%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">
          3.5 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E5%90%8E%E4%B8%80%E6%96%B9%E5%8F%91%E7%94%9F%E6%95%85%E9%9A%9C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">
          3.6 建立连接后一方发生故障会怎么样？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%B4%BB%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.1.</span> <span class="toc-text">
          保活机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AA%81%E7%84%B6%E8%A2%ABclosed"><span class="toc-number">3.6.2.</span> <span class="toc-text">
          进程突然被closed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E7%AA%81%E7%84%B6%E5%8F%91%E7%94%9F%E5%AE%95%E6%9C%BA"><span class="toc-number">3.6.3.</span> <span class="toc-text">
          主机突然发生宕机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E7%AA%81%E7%84%B6%E6%96%AD%E5%BC%80"><span class="toc-number">3.6.4.</span> <span class="toc-text">
          客户端的网络连接突然断开</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-TCP%E7%9A%84%E5%9B%9B%E4%B8%AA%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">
          4. TCP的四个机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">
          4.1 重传机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">4.1.1.</span> <span class="toc-text">
          超时重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0"><span class="toc-number">4.1.2.</span> <span class="toc-text">
          快速重传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SACK-amp-amp-D-SACK"><span class="toc-number">4.1.3.</span> <span class="toc-text">
          SACK &amp;&amp; D-SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">4.2.</span> <span class="toc-text">
          4.2 滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E7%AA%97%E5%8F%A3%E5%A4%A7%E5%B0%8F%E5%8F%82%E6%95%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">
          发送方的窗口大小参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">
          4.3 流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85%E6%83%85%E5%86%B5"><span class="toc-number">4.3.1.</span> <span class="toc-text">
          丢包情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%83%85%E5%86%B5"><span class="toc-number">4.3.2.</span> <span class="toc-text">
          死锁情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87"><span class="toc-number">4.3.3.</span> <span class="toc-text">
          糊涂窗口综合症</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">
          4.4 拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8"><span class="toc-number">4.4.1.</span> <span class="toc-text">
          慢启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D"><span class="toc-number">4.4.2.</span> <span class="toc-text">
          拥塞避免</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F"><span class="toc-number">4.4.3.</span> <span class="toc-text">
          拥塞发生</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">4.4.4.</span> <span class="toc-text">
          快速恢复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-TCP%E4%BC%98%E5%8C%96%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.</span> <span class="toc-text">
          5. TCP优化的连接</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BB%8E%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.1.</span> <span class="toc-text">
          5.1 从三次握手的角度进行优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82-client"><span class="toc-number">5.1.1.</span> <span class="toc-text">
          5.1.1 超时重传的参数调节(client)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82-service"><span class="toc-number">5.1.2.</span> <span class="toc-text">
          5.1.2 半连接队列的参数调节(service)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%82%E6%95%B0%E8%B0%83%E8%8A%82-service"><span class="toc-number">5.1.3.</span> <span class="toc-text">
          5.1.3 全连接队列的参数调节(service)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E5%A6%82%E4%BD%95%E7%BB%95%E8%BF%87%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">5.1.4.</span> <span class="toc-text">
          5.1.4 如何绕过三次握手</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BB%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E8%A7%92%E5%BA%A6%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">
          5.2 从四次挥手的角度进行优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.3.</span> <span class="toc-text">
          5.3 传输过程中进行优化</span></a></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/myphoto.png" alt="avatar"></div><p class="sidebar-ov-author__text">道阻且长,行则将至</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fa fa-heart"></i></span><span>Arong</span></div><div>加油！一起学习一起成长</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>