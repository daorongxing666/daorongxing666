<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="这是我的个人博客，记录计算机学习之路！">
<meta property="og:type" content="website">
<meta property="og:title" content="阿荣的个人博客">
<meta property="og:url" content="https://www.arong.icu/index.html">
<meta property="og:site_name" content="阿荣的个人博客">
<meta property="og:description" content="这是我的个人博客，记录计算机学习之路！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Arong">
<meta name="twitter:card" content="summary"><title>阿荣的个人博客</title><link ref="canonical" href="https://www.arong.icu/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"恭喜您，复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fa fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fa fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fa fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fa fa-user"></i></span><span class="header-nav-menu-item__text">博主</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/read/"><span class="header-nav-menu-item__icon"><i class="fa fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">阿荣的个人博客</div><div class="header-banner-info__subtitle">一起学习学不完的计算机吧</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fa fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/10764/">二叉树</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-树"   >
          <a href="#1-树" class="heading-link"><i class="fas fa-link"></i></a>1. 树</h1>
      
        <h2 id="1-1-树的基本概念"   >
          <a href="#1-1-树的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.1 树的基本概念</h2>
      <p>定义：除了根节点，每个节点有且仅有一个前驱<br>基本术语：</p>
<ul>
<li>节点：树上的一个个元素，包含数据元素和指向子树的指针</li>
<li>节点的度： 节点的子树个数</li>
<li>树的度： 树中各节点的度的最大值</li>
<li>叶子节点： 又称<strong>终端节点</strong>，指度为0的节点</li>
<li>分支节点： 又称<strong>非终端节点</strong>，指度不为0的节点</li>
<li>孩子： 节点的子树的根</li>
<li>双亲： 孩子的上一个节点</li>
<li>兄弟： 同一个双亲的孩子之间互为兄弟</li>
<li>祖先： 根到某节点路径上的所有节点，都是这个节点的祖先</li>
<li>层次：根为第一层，往下为第二层</li>
<li>高度：树中节点的最大层次</li>
</ul>

        <h2 id="1-2-树的存储结构"   >
          <a href="#1-2-树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>1.2 树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>浪费空间，一般不使用</li>
<li>链式存储结构</li>
</ol>
<ul>
<li>孩子存储结构</li>
<li>双亲存储结构</li>
<li>孩子兄弟存储结构</li>
</ul>

        <h1 id="2-二叉树"   >
          <a href="#2-二叉树" class="heading-link"><i class="fas fa-link"></i></a>2. 二叉树</h1>
      <p>定义：<br>每个节点最多只能有两个子树，即每个子树的度为0，1，2<br>且有左右之分，不能颠倒</p>

        <h2 id="2-1-二叉树的主要性质"   >
          <a href="#2-1-二叉树的主要性质" class="heading-link"><i class="fas fa-link"></i></a>2.1 二叉树的主要性质</h2>
      <ol>
<li>非空二叉树上叶子节点数等于双分支节点数加1<br>即：<code>n0 = n2 + 1</code><br>证明：设二叉树上叶子节点数为n0，单分支节点数为n1，双分支节点数为n2；<br>则总结点数为<code>n0+n1+n2</code><br>总分支数为<code>n1+2n2</code><br>根据总分支数&#x3D;总节点数-1，有<code>n0+n1+n2-1 = n1+2n2</code><br>化简后得到：<code>n0 = n2 + 1</code></li>
<li>二叉树上的第i层最多有<code>2^(i-1)</code>个节点</li>
<li>高度为h的二叉树最多有<code>2^h - 1</code>个节点</li>
<li>在有n个节点的完全二叉树下，如果i为某节点的编号，那么有</li>
</ol>
<ul>
<li>i&#x2F;2（向下取整）为其双亲的节点编号</li>
<li>2i为其左孩子编号，2i+1为其右孩子编号(若&gt;n,那么无左右孩子)</li>
</ul>
<ol start="5">
<li>具有n个节点的完全二叉树的高度为log2 n + 1(向下取整)</li>
</ol>

        <h2 id="2-2-二叉树的存储结构"   >
          <a href="#2-2-二叉树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.2 二叉树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>最适用于完全二叉树，适用于普通二叉树易导致浪费存储空间</li>
<li>链式存储结构<br>用一个节点和两个树之间的关系表示二叉树的链式存储结构<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    Elemtype data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchlid;  <span class="comment">//左指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchlid;  <span class="comment">//右指针域</span></span><br><span class="line">&#125;BTNode；</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h2 id="2-3-二叉树的遍历算法"   >
          <a href="#2-3-二叉树的遍历算法" class="heading-link"><i class="fas fa-link"></i></a>2.3 二叉树的遍历算法</h2>
      <ul>
<li>先序遍历(根 -&gt; 左 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>中序遍历(左 -&gt; 根 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>后序遍历(左 -&gt; 右 -&gt; 根)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>层序遍历<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    BTNode *queue[maxSize];</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">        queue[rear] = p;</span><br><span class="line">        <span class="keyword">while</span>(front != rear) &#123;</span><br><span class="line">            front = (front + <span class="number">1</span>)% maxSize;</span><br><span class="line">            q = queue[front];</span><br><span class="line">            <span class="built_in">visit</span>(q);</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="2-4-线索二叉树"   >
          <a href="#2-4-线索二叉树" class="heading-link"><i class="fas fa-link"></i></a>2.4 线索二叉树</h2>
      <p>节点定义：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;  <span class="comment">//线索标记，判断是子树还是线索</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *rchild;</span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></div></figure>

<p>中序遍历线索二叉树算法：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != null) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p -&gt; lchild, pre); <span class="comment">// 递归，左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p -&gt; lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立当前节点的前驱线索</span></span><br><span class="line">            p -&gt; lchild = pre;</span><br><span class="line">            p -&gt; ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre -&gt; rchlid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立前驱节点的后继线索</span></span><br><span class="line">            p -&gt; rchild = p;</span><br><span class="line">            p -&gt; rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;rchlid;</span><br><span class="line">        <span class="built_in">InThread</span>(p,pre); <span class="comment">// 递归，右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInThread</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">    TBTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(root, pre);</span><br><span class="line">        pre -&gt; rchild = null;  <span class="comment">//非空二叉树线索化</span></span><br><span class="line">        pre -&gt; rtag = <span class="number">1</span>;   <span class="comment">// 处理中序最后一个节点 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-5-树和二叉树的应用"   >
          <a href="#2-5-树和二叉树的应用" class="heading-link"><i class="fas fa-link"></i></a>2.5 树和二叉树的应用</h2>
      
        <h3 id="2-5-1-二叉排序树-BTS"   >
          <a href="#2-5-1-二叉排序树-BTS" class="heading-link"><i class="fas fa-link"></i></a>2.5.1 二叉排序树(BTS)</h3>
      
        <h4 id="2-5-1-1-定义"   >
          <a href="#2-5-1-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.1 定义</h4>
      <ol>
<li>若其左子树不为空，则左子树上所有关键字的值均不大于根关键字的值；</li>
<li>若其右子树不为空，则右子树上所有关键字的值均不小于根关键字的值；</li>
<li>每个根节点下的子树都满足此规则</li>
</ol>

        <h4 id="2-5-1-2-存储结构"   >
          <a href="#2-5-1-2-存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.2 存储结构</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-查找"   >
          <a href="#2-5-1-3-查找" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 查找</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BSTSearch</span><span class="params">(BTNode* bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> bt;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-插入"   >
          <a href="#2-5-1-3-插入" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 插入</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSTInsert</span><span class="params">(BTNode* &amp;bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到插入位置，创建新节点并插入</span></span><br><span class="line">    <span class="keyword">if</span>(bt == null) &#123;</span><br><span class="line">        bt = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode)); <span class="comment">//创建新节点</span></span><br><span class="line">        bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt-&gt;key = key;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//节点不为空，查找插入位置，和查找算法类似</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 已经存在值，不用插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-4-构造"   >
          <a href="#2-5-1-4-构造" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.4 构造</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBTS</span><span class="params">(BTNode *&amp;bt, <span class="type">int</span> key[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一棵空树</span></span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 逐个插入节点</span></span><br><span class="line">        <span class="built_in">BSTInsert</span>(bt, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-5-删除"   >
          <a href="#2-5-1-5-删除" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.5 删除</h4>
      <ol>
<li>p节点为叶子节点，直接删除</li>
<li>p节点只有左子树或者右子树，直接删除，将子树与原来双亲节点连接即可</li>
<li>p节点既有左子树又有右子树，将其直接前驱(或后继)作为双亲节点的连接点</li>
</ol>

        <h3 id="2-5-2-平衡二叉树-AVL树"   >
          <a href="#2-5-2-平衡二叉树-AVL树" class="heading-link"><i class="fas fa-link"></i></a>2.5.2 平衡二叉树(AVL树)</h3>
      
        <h4 id="2-5-2-1-定义"   >
          <a href="#2-5-2-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.1 定义</h4>
      <p>是一种特殊的二叉排序树，其左右子树高度的差的绝对值不超过1；其考点主要为平衡调整，共有LL, RR, LR, RL四种类型</p>

        <h4 id="2-5-2-2-LL"   >
          <a href="#2-5-2-2-LL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.2 LL</h4>
      <ol>
<li>当前操作节点是A （A这个节点是最小失衡树的根节点)</li>
<li>断开该节点的根节点的左孩子连接线 (此时变成了两棵树，设以A为根节点的树为原根树，以B为根节点的树为新根树)</li>
<li>判断新根树的根节点的右子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的右子树。</li>
<li>若不空:<br>– 将新根树的根节点的右子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的左子树。<br>– 把原根树作为新根树的右子树。</li>
</ul>

        <h4 id="2-5-2-3-RR"   >
          <a href="#2-5-2-3-RR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.3 RR</h4>
      <ol>
<li>当前操作节点是66 （66这个节点是最小失衡树的根节点)</li>
<li>断开该节点的右孩子连接线 (此时变成了两棵树，设以66为根节点的树为原根树，以77为根节点的树为新根树)</li>
<li>判断新根树的根节点的左子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的左子树。</li>
<li>若不空:<br>– 将新根树的根节点的左子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的右子树。<br>– 把原根树作为新根树的左子树。</li>
</ul>

        <h4 id="2-5-2-4-LR"   >
          <a href="#2-5-2-4-LR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.4 LR</h4>
      <p>先左旋，再右旋</p>

        <h4 id="2-5-2-5-RL"   >
          <a href="#2-5-2-5-RL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.5 RL</h4>
      <p>先右旋，再左旋</p>

        <h3 id="2-5-3-哈夫曼树与哈夫曼编码"   >
          <a href="#2-5-3-哈夫曼树与哈夫曼编码" class="heading-link"><i class="fas fa-link"></i></a>2.5.3 哈夫曼树与哈夫曼编码</h3>
      
        <h3 id="2-5-4-并查集"   >
          <a href="#2-5-4-并查集" class="heading-link"><i class="fas fa-link"></i></a>2.5.4 并查集</h3>
      
        <h3 id="2-5-5-红黑树"   >
          <a href="#2-5-5-红黑树" class="heading-link"><i class="fas fa-link"></i></a>2.5.5 红黑树</h3>
      
        <h4 id="2-5-5-1-性质"   >
          <a href="#2-5-5-1-性质" class="heading-link"><i class="fas fa-link"></i></a>2.5.5.1 性质</h4>
      <ol>
<li>节点包含红黑信息，根节点是黑色</li>
<li>所有叶子节点都是黑色，标记为NIL节点</li>
<li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/34330/">String</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-05</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-06</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-字符串基础知识"   >
          <a href="#1-字符串基础知识" class="heading-link"><i class="fas fa-link"></i></a>1. 字符串基础知识</h1>
      
        <h2 id="1-1-字符串对象的创建"   >
          <a href="#1-1-字符串对象的创建" class="heading-link"><i class="fas fa-link"></i></a>1.1 字符串对象的创建</h2>
      <p><code>new String()</code> 方法会在堆中创建一个对象，之后会在方法区中的字符串常量池中判断，如果没有值相等的字符串，那么创建一个常量； 如果有，那么直接调用。</p>

        <h2 id="1-2-方法"   >
          <a href="#1-2-方法" class="heading-link"><i class="fas fa-link"></i></a>1.2 方法</h2>
      <div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>char <font color="red">charAt</font>(int index)</td><td>返回指定位置的字符</td></tr><tr><td>int <font color="red">compareTo</font>(String anotherString)</td><td>比较两个字符串。相等返回0&#xff1b;前大后小返回1&#xff1b;前小后大返回-1</td></tr><tr><td>boolean <font color="red">contains</font>(CharSequence s)</td><td>判断字符串是否包含s</td></tr><tr><td>boolean <font color="red">endsWith</font>(String suffix)</td><td>判断字符串是否以suffix结尾</td></tr><tr><td>boolean <font color="red">equals</font>(Object anObject)</td><td>判断两个串是否相等</td></tr><tr><td>boolean <font color="red">equalsIgnoreCase</font>(String anotherString)</td><td>忽略大小写判断两个串是否相等</td></tr><tr><td>byte[] <font color="red">getBytes</font>()</td><td>将字符串串变成字节数组返回</td></tr><tr><td>int <font color="red">indexOf</font>(String str)</td><td>返回str在字符串第一次出现的位置</td></tr><tr><td>boolean <font color="red">isEmpty</font>()</td><td>字符串是否为空</td></tr><tr><td>int <font color="red">length</font>()</td><td>字符串长度</td></tr><tr><td>int <font color="red">lastIndexOf</font>(String str)</td><td>返回str最后一次出现的位置</td></tr><tr><td>String <font color="red">replace</font>(CharSequence target, CharSequence replacement)</td><td>用replacement替换字符串target的字符</td></tr><tr><td>String[] <font color="red">split</font>(String regex)</td><td>将字符串以regex分割</td></tr><tr><td>boolean <font color="red">startsWith</font>(String prefix)</td><td>判断字符串是否以prefix开始</td></tr><tr><td>String <font color="red">substring</font>(int beginIndex)</td><td>从beginIndex开始截取字串</td></tr><tr><td>String <font color="red">substring</font>(int beginIndex, int endIndex)</td><td>截取beginIndex到endIndex - 1的字符串</td></tr><tr><td>char[] <font color="red">toCharArray</font>()</td><td>将字符串转换乘char数组</td></tr><tr><td>String <font color="red">toLowerCase</font>()</td><td>字符串转小写</td></tr><tr><td>String <font color="red">toUpperCase</font>()</td><td>字符串转大写</td></tr><tr><td>String <font color="red">trim</font>()</td><td>去除字符串两边空格</td></tr><tr><td>静态方法</td><td></td></tr><tr><td>static String <font color="red">valueOf</font>(int i)</td><td>将 i 转换成字符串</td></tr></tbody></table></div>





<p>class Solution {<br>    public int numDifferentIntegers(String word) {<br>        Set<String> set &#x3D; new HashSet<String>();<br>        int p1 &#x3D; 0;<br>        int n &#x3D; word.length();<br>        int p2;<br>        while (true) {<br>        while (p1 &lt; n &amp;&amp; !Character.isDigit(word.charAt(p1))) {<br>            p1++;<br>        }<br>                    if (p1 &#x3D;&#x3D; n) {<br>                break;<br>            }<br>        p2 &#x3D; p1;<br>        while(p2 &lt; n &amp;&amp; Character.isDigit(word.charAt(p1))) {<br>            p2++;<br>        }<br>        while(p2-p1 &gt; 1 &amp;&amp; word.charAt(p1) &#x3D;&#x3D; ‘0’) {<br>            p1++;<br>        }<br>        res.add(word.substring(p1,p2));<br>        p1 &#x3D; p2;<br>        }</p>
<pre><code>    return res.size();
&#125;
</code></pre>
<p>}</p>
<p>Class Solution {<br>    public int numDifferentIntegers(String word) {<br>        Set<String> set &#x3D; new HashSet<String>();<br>        int n &#x3D; word.length(), p1 &#x3D; 0, p2;<br>        while (true) {<br>            while (p1 &lt; n &amp;&amp; !Character.isDigit(word.charAt(p1))) {<br>                p1++;<br>            }<br>            if (p1 &#x3D;&#x3D; n) {<br>                break;<br>            }<br>            p2 &#x3D; p1;<br>            while (p2 &lt; n &amp;&amp; Character.isDigit(word.charAt(p2))) {<br>                p2++;<br>            }<br>            while (p2 - p1 &gt; 1 &amp;&amp; word.charAt(p1) &#x3D;&#x3D; ‘0’) { &#x2F;&#x2F; 去除前导 0<br>                p1++;<br>            }<br>            set.add(word.substring(p1, p2));<br>            p1 &#x3D; p2;<br>        }<br>        return set.size();<br>    }</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/57281/">3-hashtable</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-04</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-哈希表基本概念的入门"   >
          <a href="#1-哈希表基本概念的入门" class="heading-link"><i class="fas fa-link"></i></a>1. 哈希表基本概念的入门</h1>
      <p>哈希表也叫散列表，是通过<code>key &amp; value</code>来进行定位的数据结构，他把关键码值映射到表中一个位置来进行定位，这个映射函数叫做哈希函数；<br>元素在数组位置position可以表示为<code>hash(key)</code>， 表面上只存放key，找到key就可以找到value。<br>主要思想是空间换时间，可以节约遍历的时间成本，但是代价是需要建立字典库存储映射结果。</p>
<ul>
<li>数组+链表结构<br>数组查询方便，可以通过下标直接获得所对应的值，但是插入删除不方便，需要整体移动元素还需要扩容；<br>链表查询不方便，没有下标只能通过遍历的方式进行查询，增加插入方便，只需要找到需要插入的节点之后进行插入删除即可；<br>哈希表是两者的结合，获得了两者的优点。<br>哈希碰撞指经过哈希函数两个key都映射到了同一个数组位置上，那么这时候有两种解决方法。</li>
<li>拉链法：在同一个位置进行链表结构的扩充；</li>
<li>线性探索法： 往数组的下一个位置进行扩充；<br>需要考虑到的是<strong>查询效率</strong>，当链表长度过长，那么使用线性探索法；当链表长度足够，使用拉链法。<br>哈希攻击指的是黑客运用一些会转换为相同存储位置的数据注入，最后使得<strong>哈希表退化成一个单链表</strong>，降低了查询效率，DOS(Denial of Service, 拒绝服务供给)攻击.</li>
</ul>

        <h2 id="1-1-hashMap"   >
          <a href="#1-1-hashMap" class="heading-link"><i class="fas fa-link"></i></a>1.1 hashMap</h2>
      
        <h3 id="1-1-1-map基本操作"   >
          <a href="#1-1-1-map基本操作" class="heading-link"><i class="fas fa-link"></i></a>1.1.1 map基本操作</h3>
      <ul>
<li>hashMap的主要Api：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">map.clear();</span><br><span class="line">map.size();</span><br><span class="line">map.isEmpty</span><br><span class="line">map.containsKey(); <span class="comment">//判断</span></span><br><span class="line">map.containsValue();</span><br><span class="line">map.get(key);</span><br><span class="line">map.put(key,value);</span><br><span class="line">map.putAll(otherMap);</span><br><span class="line">map.remove(key);</span><br><span class="line">map.getOrDefault(key,defaultValue);查找key的值,不存在则返回默认值。</span><br><span class="line">map.entrySet();用来遍历每一对KV</span><br><span class="line"><span class="title function_">for</span><span class="params">(Map.Entry&lt;Integer，Integer&gt; etntey : map.entrySet()</span>)</span><br></pre></td></tr></table></div></figure></li>
<li>map遍历三种方式<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式： keySet 取出map中所有键，封装为map集合</span></span><br><span class="line">		Set&lt;String&gt; s1=buy.keySet();</span><br><span class="line">		<span class="comment">//开始根据键找值</span></span><br><span class="line">		<span class="keyword">for</span> (String key : s1) &#123;</span><br><span class="line">			Integer value=buy.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;-&gt;&gt;&gt;&gt;&quot;</span>+value);	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式： 将所有键值对取出封装为entrySet集合</span></span><br><span class="line">		Set&lt;Map.Entry&lt;String,Integer&gt;&gt; en=buy.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : en) &#123;</span><br><span class="line">			String key=entry.getKey();</span><br><span class="line">			Integer value=entry.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot;-&gt;&gt;&gt;&quot;</span>+value);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式： Lambda表达式遍历</span></span><br><span class="line">		buy.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String t, Integer u)</span> &#123;</span><br><span class="line">				System.out.println(t+<span class="string">&quot;-&gt;&gt;&gt;&quot;</span>+u);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="1-1-2-HashMap两个重要参数"   >
          <a href="#1-1-2-HashMap两个重要参数" class="heading-link"><i class="fas fa-link"></i></a>1.1.2 HashMap两个重要参数</h3>
      <ul>
<li>初始容量大小：确定了哈希表底层数组的长度，必须是2的幂，默认初始值为16；</li>
<li>加载因子： 决定什么时候进行扩容，默认为0.75f，当数组存储元素个数超过<code>初始容量大小*加载因子</code>，数组就会用<code>refresh()</code>方法进行扩容，将数组扩大到原来的两倍。<br>扩容十分耗费性能，因为会生成一个新的数组，而且原来元素都要重新计算hashcode存入新的数组。</li>
</ul>

        <h3 id="1-1-3-put方法原理"   >
          <a href="#1-1-3-put方法原理" class="heading-link"><i class="fas fa-link"></i></a>1.1.3 put方法原理</h3>
      <p>将key通过本地方法<code>public native int hashcode()</code>， 获取对应key的哈希码， 这个哈希码和key的存储位置有关，一般计算规则是取模存入，假如数组的长度是16个字节，key的hashcode是3214968，那么<code>3214968 mod 16 = 8</code>, 那么key就会被存储在数组的第8个位置，如果该位置为空则直接存入，如果该位置有值，就将插入的key与已经存在的key逐一进行equals判断，如果true就替换values，否则就以链表或红黑树(当链表长度大于8时)形式接入。此时<code>(key, value)</code>被封装为Node节点一同进行put操作</p>
<blockquote>
<p>红黑树是平衡二叉树，在查找的效率方面比链表高。</p>
</blockquote>
<ul>
<li>equals()和hashcode()关系<br>equals()方法对于基本数据类型，比较两个数的内容是否相等，而对于引用数据类型，则比较两个数的存储位置是否相等。<br>两个对象equals()了，那么他们的hashcode()一定相等；两个对象不equals()，他们的hashcode不一定不相等(经过算法可能计算出来相同的值，哈希碰撞的原理)<br>equals()重写了，hashcode()就一定要重写，否则可能两个对象equals，他们的hashcode仍然不相等，可能为后世使用埋下隐患;</li>
</ul>

        <h3 id="1-1-4-get-key-方法原理"   >
          <a href="#1-1-4-get-key-方法原理" class="heading-link"><i class="fas fa-link"></i></a>1.1.4 get(key)方法原理</h3>
      <p>首先调用hashcode()方法获取key的hashcode；<br>之后取模定位到数组的索引位置，如果位置为空，返回null；<br>如果有值，逐一遍历将key进行equal判断，成功则放回对应Node中的values；匹配不到返回null。</p>

        <h3 id="1-1-5-hashMap-在Java1-7和1-8中的区别"   >
          <a href="#1-1-5-hashMap-在Java1-7和1-8中的区别" class="heading-link"><i class="fas fa-link"></i></a>1.1.5 hashMap 在Java1.7和1.8中的区别</h3>
      
        <h4 id="1-结构不同"   >
          <a href="#1-结构不同" class="heading-link"><i class="fas fa-link"></i></a>1. 结构不同</h4>
      <p>1.7采用的是数组+链表的数据结构<br>1.8采用的是数组+链表+红黑树的数据结构(当链表长度大于8时，扩展为红黑树)</p>

        <h4 id="2-节点不同"   >
          <a href="#2-节点不同" class="heading-link"><i class="fas fa-link"></i></a>2. 节点不同</h4>
      <p>区别：<br>1.8中的hash作为一个常量，可以减少扩容时候再次计算哈希值造成的性能消耗。<br>1.8多了红黑树的节点。</p>

        <h4 id="3-hash函数区别"   >
          <a href="#3-hash函数区别" class="heading-link"><i class="fas fa-link"></i></a>3. hash函数区别</h4>
      <p>1.8相较于1.7只采用了一次位运算和一次与运算，而这次的目的是为了能够减少哈希碰撞，将高位和地位融合在一起，因为发现进行取模操作的时候对高位的影响是相对较小的。因为计算公式为<code>(n-1) &amp; hash</code>，对高位基本上是没有什么影响的。</p>
<blockquote>
<p>取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，<code>hash % length == hash &amp; (length - 1)</code>的前提是length是2的n次方, 位运算特征，length是2的n次方，那么他减去1之后就是n个1，异或运算同0异1，这时候就能准确得出他在长度内的值是多少了。 </p>
</blockquote>

        <h4 id="4-初始化方式"   >
          <a href="#4-初始化方式" class="heading-link"><i class="fas fa-link"></i></a>4. 初始化方式</h4>
      <p>1.7：</p>
<ul>
<li>table是直接赋值给了一个空数组，在第一次put元素时初始化和计算容量。</li>
<li>table是单独定义的inflateTable（）初始化方法创建的。<br>1.8：</li>
<li>table没有赋值，属于懒加载，构造方式时已经计算好了新的容量位置（大于等于给定容量的最小2的次幂）。</li>
<li>table是resize（）方法创建的。</li>
</ul>

        <h4 id="5-扩容方式"   >
          <a href="#5-扩容方式" class="heading-link"><i class="fas fa-link"></i></a>5. 扩容方式</h4>
      <p>1.7： 运用异或对哈希值进行重新计算，运用resize()方法负责扩容，inflateTable()负责创建表；<br>1.8： 运用原来的哈希值加上扩容数组长度得到新的数组索引位置，节约了性能利用；表为空时候resize()创建表，表中有数值resize()扩容</p>

        <h4 id="6-数据插入方式"   >
          <a href="#6-数据插入方式" class="heading-link"><i class="fas fa-link"></i></a>6. 数据插入方式</h4>
      <p>1.7： 头插法<br>1.8： 尾插法，避免了在并发时出现逆序和循环链表的情况</p>

        <h3 id="1-1-6-线程问题"   >
          <a href="#1-1-6-线程问题" class="heading-link"><i class="fas fa-link"></i></a>1.1.6 线程问题</h3>
      <p>1.7 死循环，数据丢失，并发执行扩容阶段<br>1.8 解决死循环，数据丢失仍然没有解决，并发put的时候</p>
<p>整体储存流程如下：<br><img src="/images/20190122151905332.png"></p>
<hr>

        <h2 id="1-2-Set"   >
          <a href="#1-2-Set" class="heading-link"><i class="fas fa-link"></i></a>1.2 Set</h2>
      
        <h3 id="1-2-1-Set集合基本操作"   >
          <a href="#1-2-1-Set集合基本操作" class="heading-link"><i class="fas fa-link"></i></a>1.2.1 Set集合基本操作</h3>
      <p>list是有序的，元素可以重复的；set是无序的，不能重复的</p>
<ul>
<li>主要Api：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E object)</span> <span class="comment">//添加一个元素，添加成功返回true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">//从Set集合中移除所有元素，该方法是从Collection集合继承过来的。</span></span><br><span class="line">Object <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object object)</span> <span class="comment">//判断集合内是否包含元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">//判断是否为空集合</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//迭代器，遍历set集合用</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object object)</span> <span class="comment">//移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">//数组长度</span></span><br></pre></td></tr></table></div></figure></li>
<li>遍历方式</li>
</ul>
<ol>
<li>iterator遍历<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();  </span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();  </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();  </span><br><span class="line">  System.out.println(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>增强for遍历<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : set) &#123;  </span><br><span class="line">      System.out.println(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h1 id="2-数组相关题目"   >
          <a href="#2-数组相关题目" class="heading-link"><i class="fas fa-link"></i></a>2. 数组相关题目</h1>
      
        <h2 id="2-1-字母异位词"   >
          <a href="#2-1-字母异位词" class="heading-link"><i class="fas fa-link"></i></a>2.1 字母异位词</h2>
      
        <h3 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/valid-anagram/" >Problem 242 有效的字母异位词</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度"   >
          <a href="#复杂度" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h3 id="主要思想"   >
          <a href="#主要思想" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这道题目要我们比较的是每个字符出现的次数，那么我们就有两个需要比较的量，<mark>一个是出现的字符是否相等，另一个是字符出现的次数是否相等，</mark>那么我们就可以想到，本题中的字符串由26个字母构成，是一个<strong>有限且可以连续的集合</strong>(将字符转换位ASCII码)，所以我们考虑用可存储连续集合的存储工具数组来进行存储，每个索引对应的值就是他出现的次数。那么每在s字符串出现一次，加上1； 每在t字符串出现一次，减去1； 因为异位词要求字母个数都相等，到最后只需要判断<strong>数组内的元素是否均为0</strong>即可。</p>

        <h3 id="注意点"   >
          <a href="#注意点" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>本题可能有的会考虑用Map进行存储，key为字母字符，values为次数；是可以的，但是Map中key的特点是可以连续可以不连续，需要用一个哈希映射来存储相对应Map的值，而且也会新增很多空间，影响性能。而连续的集合用数组可以和Map达到一样的效果，但是空间成本小了。</p>

        <h3 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建26位数组存储26个字母</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 加入记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            temp[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            temp[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配是否还有记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-2-赎金信"   >
          <a href="#2-2-赎金信" class="heading-link"><i class="fas fa-link"></i></a>2.2 赎金信</h2>
      
        <h3 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/ransom-note/" >Problem 383 赎金信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-1"   >
          <a href="#复杂度-1" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h3 id="主要思想-1"   >
          <a href="#主要思想-1" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>和上道题的思路是一样的，找要求的重复字符以及其出现的次数。这个升级版主要体现在他不是完全匹配的了，那我们就要从中想出加上的是哪个，减去的是哪个。那么这里用大的数组加入，小的数组减去，如果都大于0，说明大的完全能包含小的；如果小于0，说明大的里面由小的没有的元素。</p>

        <h3 id="注意点-1"   >
          <a href="#注意点-1" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>学一下字符串的两种遍历方法吧，for增强遍历<code>for(char ch : str.toCharArray)</code>和直接遍历<code>for()... str.charAt(i)</code></p>

        <h3 id="代码实现-1"   >
          <a href="#代码实现-1" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希映射数组</span></span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="3-Set相关题目"   >
          <a href="#3-Set相关题目" class="heading-link"><i class="fas fa-link"></i></a>3. Set相关题目</h1>
      
        <h2 id="3-1-两个数组的交集"   >
          <a href="#3-1-两个数组的交集" class="heading-link"><i class="fas fa-link"></i></a>3.1 两个数组的交集</h2>
      
        <h3 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-arrays/" >Problem 349 两个数组的交集</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-2"   >
          <a href="#复杂度-2" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-2"   >
          <a href="#主要思想-2" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>题目中说到<code>输出结果中的每个元素一定是唯一的</code>，那么就无需去考虑每个元素出现的次数了。所以我们<strong>只需判断的是有没有出现过</strong>即可，那么这种单一元素的判断，而且数组内元素是离散的，用<mark>数组会造成很多空间的浪费</mark>，所以我们想到了<strong>无连续的离散的</strong>集合Set。创建两个集合，其中一个作为比对集，负责比较有没有重复，另一个作为结果集，记录符合条件元素。</p>

        <h3 id="注意点-2"   >
          <a href="#注意点-2" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>集合转数组的写法：<code>resset.stream().mapToInt(x -&gt; x).toArray()</code></p>

        <h3 id="代码实现-2"   >
          <a href="#代码实现-2" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 计算的集合</span></span><br><span class="line">        Set&lt;Integer&gt; tempset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果输出的集合</span></span><br><span class="line">        Set&lt;Integer&gt; resset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            tempset.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tempset.contains(i)) &#123;</span><br><span class="line">                <span class="comment">// 比对成功，加入结果集</span></span><br><span class="line">                resset.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resset.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-2-快乐数"   >
          <a href="#3-2-快乐数" class="heading-link"><i class="fas fa-link"></i></a>3.2 快乐数</h2>
      
        <h3 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/happy-number/" >Problem 202 快乐数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-3"   >
          <a href="#复杂度-3" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-3"   >
          <a href="#主要思想-3" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这道题明确声明了会有无限循环的情况出现，那么这道题得到的就两个结果，一个是我们确定是快乐数的条件：最后结果是1；另一个是无限循环，不是快乐数。所以我们可以直接在循环中设置退出条件一个是为1， 另一个是无限循环。那么要判断是否无限循环就是判断字符是否出现过，重复出现的问题想到哈希表，又因为我们只需要记录内容，次数我们不关心，一个维度我们就用Set就可以了。</p>

        <h3 id="注意点-3"   >
          <a href="#注意点-3" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>获取每位数字的方法：第一步是取10模，得到个位的数字；第二步是除以10，将十位的数字移到下一位个位，然后不断循环，中止的条件是没有可以移动的位了，说明这个数已经被我们操作完了，也就是<code>n &gt; 0</code>。</p>

        <h3 id="代码实现-3"   >
          <a href="#代码实现-3" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; code = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 因为会无限循环，所以到了重复的时候就说明无需再进行下去了</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !code.contains(n))&#123;</span><br><span class="line">            code.add(n);</span><br><span class="line">            n = getNextCount(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每位数字的平方和</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextCount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += temp * temp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="4-Map相关题目"   >
          <a href="#4-Map相关题目" class="heading-link"><i class="fas fa-link"></i></a>4. Map相关题目</h1>
      
        <h2 id="4-1-两数之和"   >
          <a href="#4-1-两数之和" class="heading-link"><i class="fas fa-link"></i></a>4.1 两数之和</h2>
      
        <h3 id="相关题目-4"   >
          <a href="#相关题目-4" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/two-sum/" >Problem 1 两数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-4"   >
          <a href="#复杂度-4" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-4"   >
          <a href="#主要思想-4" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>我们需要通过数组的每个元素值对其进行计算，然后输出的是他的下标，那么这时候我们会发现，其实我们需要操作的是两个值，又需要对元素进行比对匹配，所以选择用Map集合或者数组存储会比较好一些，那我们就看到底是不是连续的。因为最后要输出的是索引，所以我们会选择把索引存在Values中，而元素就只能存在key中了，因为元素的离散的，所以我们只能用Map集合了。</p>

        <h3 id="注意点-4"   >
          <a href="#注意点-4" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>每次一定都要好好想想空值和特殊值有没有办法包含在你的逻辑中，没有的话要提前排除掉。数组的空值具体实现为：<code>nums == null || nums.length == 0</code></p>

        <h3 id="代码实现-4"   >
          <a href="#代码实现-4" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 结果集存储结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 排除空数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// key为数组元素值，values为对应元素索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(temp, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-2-四数之和Ⅱ"   >
          <a href="#4-2-四数之和Ⅱ" class="heading-link"><i class="fas fa-link"></i></a>4.2 四数之和Ⅱ</h2>
      
        <h3 id="相关题目-5"   >
          <a href="#相关题目-5" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum-ii/" >Problem 454 两数相加Ⅱ</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-5"   >
          <a href="#复杂度-5" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-5"   >
          <a href="#主要思想-5" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这里要求我们输出的是元组的个数，也就是我们不需要具体的去确认他的下标，只需要知道有这个东西存在就可以了。所以我们要关心的就是元素的值。那其实我们可以两两拆分，遍历数组集合求出两个数组的和，然后再与另外两个数组匹配，时间复杂度虽然是n^2^，但是相较于暴力算法直接缩短了一半。但是我们发现，可能一个数的和可以由多种表现形式，所以我们还需要关心的一个点就是组成该和的个数。所以其实我们要考虑到的是两个变量，所以我们会使用Map集合，key用来存储两个数组和的值，values用来存储这个和的组成出现的次数。之后在进行配对的时候也要把所有符合的次数加上，也就计数的时候不是+1，而是+values了。</p>

        <h3 id="注意点-5"   >
          <a href="#注意点-5" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>存储更新个数的操作：包含：<code>map.put(sum, map.get(sum) + 1);</code>不包含：<code>map.put(nums1[i] + nums2[j], 1);</code></p>

        <h3 id="代码实现-5"   >
          <a href="#代码实现-5" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="comment">// 计数器记录满足条件元组个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 两两配对生成集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum)) &#123;</span><br><span class="line">                    <span class="comment">// 存储个数更新的操作</span></span><br><span class="line">                    map.put(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(nums1[i] + nums2[j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums3.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums4.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span> - (nums3[i] + nums4[j]);</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                        <span class="comment">// 需要进行所有的配对</span></span><br><span class="line">                        count += map.get(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-3-三数之和"   >
          <a href="#4-3-三数之和" class="heading-link"><i class="fas fa-link"></i></a>4.3 三数之和</h2>
      
        <h3 id="相关题目-6"   >
          <a href="#相关题目-6" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/3sum/" >Problem 15 三数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-6"   >
          <a href="#复杂度-6" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-6"   >
          <a href="#主要思想-6" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>等于一个指定的值，那么就有<code>大于小于等于</code>三种情况，只有三者不断的中立，那么最后才能实现，那么我们就想到了其实可以用<strong>排序对他进行划分</strong>，那么排序就想到了<strong>双指针</strong>，但是这里有三个数怎么办呢，那么我们就固定一个，然后去走另外两个，等于是有两个变量的双指针就是O(a)级别的时间复杂度，有三个变量的双指针就是O(n)的时间复杂度，<mark>有n个变量的双指针就是O(n^n-2)的时间复杂度</mark>。</p>

        <h3 id="注意点-6"   >
          <a href="#注意点-6" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>去重复的动作，因为题目明确告诉我们了一样的不算，那么我们怎么去重复呢，就对于固定指针而言，他前后不能一样，对于移动的双指针模型而言，他们两个不能同时一样即可。因为他们两组指针是相对运动的。 而有个细节的点就是判断固定指针去重的时候如果这么写nums[i] &#x3D;&#x3D; nums[i + 1]，就会引发一个只是重复元素但是被我们排除的情况，因为我们未曾比较过，而后移了，这个本来应该操作的可操作范围就变小了，应该写成和i-1进行比较，这样才能确保所有都是匹配过的，操作范围上一个一样的比你大，那肯定你能匹配到的范围也是他能够匹配到的。<br>去重不能只去除一次，而要去到满足这个条件为止，所以不能用if，而要用while<br>将集合装进集合：<code>list.add(Arrays.asList(nums[index], nums[left], nums[right]));</code></p>

        <h3 id="代码实现-6"   >
          <a href="#代码实现-6" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 对于第一项就大于0的有序数组，那么势必无法加起来等于0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; nums.length; index++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于index的去重</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span> &amp;&amp; nums[index] == nums[index - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[index] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 太大了，应该小一点，那么右边就缩小</span></span><br><span class="line">                right --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 太小了，应该大一点，左边过来点</span></span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 是我们的目标，装进集合里去！</span></span><br><span class="line">            list.add(Arrays.asList(nums[index], nums[left], nums[right]));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 去重left</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去重right</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-4-四数之和"   >
          <a href="#4-4-四数之和" class="heading-link"><i class="fas fa-link"></i></a>4.4 四数之和</h2>
      
        <h3 id="相关题目-7"   >
          <a href="#相关题目-7" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/4sum/" >Problem 18 四数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-7"   >
          <a href="#复杂度-7" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^3)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-7"   >
          <a href="#主要思想-7" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>比三数之和多了一层循环。</p>

        <h3 id="注意点-7"   >
          <a href="#注意点-7" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0 </code>就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，target是-10，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p>

        <h3 id="代码实现-7"   >
          <a href="#代码实现-7" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">fourSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.size(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/24714/">类结构和类加载</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-类文件结构"   >
          <a href="#1-类文件结构" class="heading-link"><i class="fas fa-link"></i></a>1. 类文件结构</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="1-1-魔数-amgic"   >
          <a href="#1-1-魔数-amgic" class="heading-link"><i class="fas fa-link"></i></a>1.1 魔数(amgic)</h2>
      <p>唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。即进行<strong>类型识别</strong>。使用魔数而不使用文件拓展名是为了安全考虑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-2-版本号-minor-version-amp-major-version"   >
          <a href="#1-2-版本号-minor-version-amp-major-version" class="heading-link"><i class="fas fa-link"></i></a>1.2 版本号(minor_version &amp; major_version)</h2>
      <p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-3-常量池"   >
          <a href="#1-3-常量池" class="heading-link"><i class="fas fa-link"></i></a>1.3 常量池</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></div></figure>
<p><code>constant_pool_count</code>表示常量池的容量，索引从1开始，到他的数量-1.第0项常量表示不引用任何常量，默认为空。</p>
<blockquote>
<p>0x0016：表示为十进制是22，表示有21个常量，索引从1-21<br>主要存放两类常量：字面量和符号引用<br>每一项常量都是一个表，表开始是u1类型的标志位。<br><img src="/images/1bcc0033df92b50d7db8ef484f54e88.png"></p>
</blockquote>

        <h2 id="1-4-访问标志"   >
          <a href="#1-4-访问标志" class="heading-link"><i class="fas fa-link"></i></a>1.4 访问标志</h2>
      <p>识别类或接口层次的访问消息。<br><img src="/images/ca3c4e7fd521b481e238d400f9a4757.png"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-5-类索引，父类索引和接口索引集合"   >
          <a href="#1-5-类索引，父类索引和接口索引集合" class="heading-link"><i class="fas fa-link"></i></a>1.5 类索引，父类索引和接口索引集合</h2>
      <p>当前类要设置全限名，所有的都有父类，除了java.lang.Object，接口可以多实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-6-字段表集合"   >
          <a href="#1-6-字段表集合" class="heading-link"><i class="fas fa-link"></i></a>1.6 字段表集合</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br></pre></td></tr></table></div></figure>
<p>字段表格式：</p>
<ul>
<li><code>access_flags</code>: 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><code>name_index</code>: 对常量池的引用，表示的字段的名称；</li>
<li><code>descriptor_index</code>: 对常量池的引用，表示字段和方法的描述符；</li>
<li><code>attributes_count</code>: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><code>attributes[attributes_count]</code>: 存放具体属性具体内容。<br>字段表标志位：<br><img src="/images/ba74348c5a074791abadabda1534dbf3.png"></li>
</ul>

        <h2 id="1-7-方法表集合"   >
          <a href="#1-7-方法表集合" class="heading-link"><i class="fas fa-link"></i></a>1.7 方法表集合</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></div></figure>
<p>方法表结构：<br><img src="/images/4efb6101e08445499f2faf59f34963f4.png"><br>方法表标志位：<br><img src="/images/d8137412775c419b948902e79dee14da.png"></p>

        <h1 id="2-类加载机制"   >
          <a href="#2-类加载机制" class="heading-link"><i class="fas fa-link"></i></a>2. 类加载机制</h1>
      <p>类的生命周期：<br><img src="/images/b724a4d759f8f67fbdac422a0eac658.png"><br>类加载的时机：</p>
<ul>
<li>创建类的实例，也就是<code>new</code>一个对象。</li>
<li>访问类的静态方法或者静态变量（包含静态变量赋值）。</li>
<li>使用<code>Class.forName()</code>反射类。</li>
<li>子类初始化的时候。</li>
<li>JVM启动时标明的启动类。</li>
</ul>

        <h2 id="2-1-加载"   >
          <a href="#2-1-加载" class="heading-link"><i class="fas fa-link"></i></a>2.1 加载</h2>
      <ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个流的静态存储结构转换为方法区运行时数据结构。</li>
<li>生成一个Class对象<br>jvm是<strong>懒加载</strong>，所以只有使用到类时才会加载，例如调用类的main()方法，new对象等等 ，主类在运行过程中如果使用到其它类，会逐步加载这些类。</li>
</ol>

        <h2 id="2-2-验证"   >
          <a href="#2-2-验证" class="heading-link"><i class="fas fa-link"></i></a>2.2 验证</h2>
      <ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>

        <h2 id="2-3-准备"   >
          <a href="#2-3-准备" class="heading-link"><i class="fas fa-link"></i></a>2.3 准备</h2>
      <p>为类中定义的变量(被<code>static</code>修饰过的变量)分配内存并设置类变量初始值。此阶段不包含实例变量的赋值。</p>

        <h2 id="2-4-解析"   >
          <a href="#2-4-解析" class="heading-link"><i class="fas fa-link"></i></a>2.4 解析</h2>
      <p>将符号引用转换为直接引用。</p>
<ul>
<li>符号引用： 描述对象，包括如下三种：<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符</li>
<li>直接引用：<br>变量有一个内存地址来标识，如果我们用一个指针指向这个内存地址，这个指针就是直接引用。<br>等我们需要用到这个变量的时候，就可以直接通过指针指向的地址找到。<br>而我们在加载类的时候，解析代码并指向内存某个地址，然后将符号引用 obj和这个内存地址进行映射的过程，就是解析这个步骤要做的事，也叫做符号引用转换为直接引用。</li>
</ul>

        <h2 id="2-5-初始化"   >
          <a href="#2-5-初始化" class="heading-link"><i class="fas fa-link"></i></a>2.5 初始化</h2>
      <p>（1）对类的静态变量初始化为指定的值<br><code>int initData = 666</code><br>（2）执行静态代码块<br><code>&lt;clinit&gt;()</code></p>

        <h1 id="3-类加载器"   >
          <a href="#3-类加载器" class="heading-link"><i class="fas fa-link"></i></a>3. 类加载器</h1>
      
        <h2 id="3-1-类加载器的种类"   >
          <a href="#3-1-类加载器的种类" class="heading-link"><i class="fas fa-link"></i></a>3.1 类加载器的种类</h2>
      <p><img src="/images/47266cb826c74981b21ded13641ed666.png"></p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：负责加载Java类的核心类(<code>&lt;JAVA_HOME&gt;\lib</code>目录下，能被<code>-Xbootclasspath</code>参数所指定路径存放的)，是用C++代码实现的，无法被java代码直接引用。</li>
<li>扩展类加载器（Extensions ClassLoader）：负责加载JRE的扩展目录lib&#x2F;ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为Null。</li>
<li>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径 classpath 上所有的 jar 包和 .class 文件。</li>
</ul>

        <h2 id="3-2-双亲委派模型"   >
          <a href="#3-2-双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a>3.2 双亲委派模型</h2>
      <p>工作过程：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的夹杂请求最终都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。<br>简而言之：<font color=red>自下而上请求，自上而下加载</font><br>优势：<br>父类加载器成功加载则返回，子类加载器不会再加载，防止了重复加载。<br>防止核心API库被随意篡改。比如有一个要加载java.lang.Integer类的请求，通过双亲委派进制加载传递到启动类加载器，在在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，可以防止核心API被随意篡改。</p>
<p><a href="/images.classAll.png"></a></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/3701/">Spring_1</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-03</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Spring-day01"   >
          <a href="#Spring-day01" class="heading-link"><i class="fas fa-link"></i></a>Spring_day01</h2>
      <p><strong>今日目标</strong></p>
<blockquote>
<ul>
<li>掌握Spring相关概念</li>
<li>完成IOC&#x2F;DI的入门案例编写</li>
<li>掌握IOC的相关配置与使用</li>
<li>掌握DI的相关配置与使用</li>
</ul>
</blockquote>

        <h2 id="1，课程介绍"   >
          <a href="#1，课程介绍" class="heading-link"><i class="fas fa-link"></i></a>1，课程介绍</h2>
      <p>对于一门新技术，我们需要从<code>为什么要学</code>、<code>学什么</code>以及<code>怎么学</code>这三个方向入手来学习。那对于Spring来说:</p>

        <h3 id="1-1-为什么要学"   >
          <a href="#1-1-为什么要学" class="heading-link"><i class="fas fa-link"></i></a>1.1 为什么要学?</h3>
      <ul>
<li><p>从使用和占有率看</p>
<ul>
<li><p>Spring在市场的占有率与使用率高</p>
</li>
<li><p>Spring在企业的技术选型命中率高</p>
</li>
<li><p>所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;&#x3D;&#x3D;90%&#x3D;&#x3D;</p>
<p><img src="/images/image-20210729171139088.png"></p>
<p><strong>说明</strong>:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。</p>
</li>
</ul>
</li>
<li><p>从专业角度看</p>
<ul>
<li>随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决?<ul>
<li>Spring可以&#x3D;&#x3D;简化开发&#x3D;&#x3D;，降低企业级开发的复杂性，使开发变得更简单快捷</li>
</ul>
</li>
<li>随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作?<ul>
<li>Spring可以&#x3D;&#x3D;框架整合&#x3D;&#x3D;，高效整合其他技术，提高企业级应用开发与运行效率</li>
</ul>
</li>
</ul>
<p>综上所述，&#x3D;&#x3D;Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-2-学什么"   >
          <a href="#1-2-学什么" class="heading-link"><i class="fas fa-link"></i></a>1.2 学什么?</h3>
      <p>从上面的介绍中，我们可以看到Spring框架主要的优势是在<code>简化开发</code>和<code>框架整合</code>上，至于如何实现就是咱们要学习Spring框架的主要内容:</p>
<ul>
<li><p>简化开发: Spring框架中提供了两个大的核心技术，分别是:</p>
<ul>
<li>&#x3D;&#x3D;IOC&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP&#x3D;&#x3D;<ul>
<li>&#x3D;&#x3D;事务处理&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p> 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。</p>
<p> 2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。</p>
</li>
<li><p>框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:</p>
<ul>
<li>&#x3D;&#x3D;MyBatis&#x3D;&#x3D;</li>
<li>MyBatis-plus</li>
<li>Struts</li>
<li>Struts2</li>
<li>Hibernate</li>
<li>……</li>
</ul>
<p>这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。</p>
<p>综上所述，对于Spring的学习，主要学习四块内容:</p>
<p>&#x3D;&#x3D;(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-3-怎么学"   >
          <a href="#1-3-怎么学" class="heading-link"><i class="fas fa-link"></i></a>1.3 怎么学?</h3>
      <ul>
<li>学习Spring框架设计思想<ul>
<li>对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的<code>思想</code>上。</li>
</ul>
</li>
<li>学习基础操作，思考操作与思想间的联系<ul>
<li>掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系</li>
</ul>
</li>
<li>学习案例，熟练应用操作的同时，体会思想<ul>
<li>会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。</li>
</ul>
</li>
</ul>
<p>介绍完<code>为什么要学</code>、<code>学什么</code>和<code>怎么学</code>Spring框架后，大家需要重点掌握的是:</p>
<ul>
<li>Spring很优秀，需要认真重点的学习</li>
<li>Spring的学习主线是IOC、AOP、声明式事务和整合MyBais</li>
</ul>
<p>接下来，咱们就开始进入Spring框架的学习。</p>

        <h2 id="2，Spring相关概念"   >
          <a href="#2，Spring相关概念" class="heading-link"><i class="fas fa-link"></i></a>2，Spring相关概念</h2>
      
        <h3 id="2-1-初识Spring"   >
          <a href="#2-1-初识Spring" class="heading-link"><i class="fas fa-link"></i></a>2.1 初识Spring</h3>
      <p>在这一节，主要通过以下两个点来了解下Spring:</p>

        <h4 id="2-1-1-Spring家族"   >
          <a href="#2-1-1-Spring家族" class="heading-link"><i class="fas fa-link"></i></a>2.1.1 Spring家族</h4>
      <ul>
<li><p>官网：<a href="https://spring.io，从官网我们可以大概了解到：">https://spring.io，从官网我们可以大概了解到：</a></p>
<ul>
<li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li>
<li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li>
</ul>
</li>
<li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p>
<ul>
<li><p>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</p>
</li>
<li><p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图所示</p>
<p><img src="/images/image-20210729171850181.png"></p>
<p><strong>说明:</strong></p>
<p>图中的图标都代表什么含义，可以进入<code>https://spring.io/projects</code>网站进行对比查看。</p>
<p>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p>
<p><img src="/images/1629714811435.png"></p>
<ul>
<li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li>
<li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li>
<li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li>
</ul>
<p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="2-1-2-了解Spring发展史"   >
          <a href="#2-1-2-了解Spring发展史" class="heading-link"><i class="fas fa-link"></i></a>2.1.2 了解Spring发展史</h4>
      <p> 接下来我们介绍下Spring Framework这个技术是如何来的呢?</p>
<p><img src="/images/image-20210729171926576.png"></p>
<p>Spring发展史</p>
<ul>
<li>IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。</li>
<li>Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的<code>Expert One-on-One J2EE Design and Development</code>,书中有阐述在开发中使用EJB该如何做。</li>
<li>Rod Johnson在2004年出版的<code>Expert One-on-One J2EE Development without EJB</code>,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。</li>
<li>随着时间推移，版本不断更新维护，目前最新的是Spring5<ul>
<li>Spring1.0是纯配置文件开发</li>
<li>Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式</li>
<li>Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主</li>
<li>Spring4.0根据JDK的版本升级对个别API进行了调整</li>
<li>Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版</li>
</ul>
</li>
</ul>
<p>本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是:</p>
<ul>
<li>今天所学的Spring其实是Spring家族中的Spring Framework</li>
<li>Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础</li>
</ul>

        <h3 id="2-2-Spring系统架构"   >
          <a href="#2-2-Spring系统架构" class="heading-link"><i class="fas fa-link"></i></a>2.2 Spring系统架构</h3>
      <p>前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?</p>
<p>针对这些问题，我们将从<code>系统架构图</code>和<code>课程学习路线</code>来进行说明:</p>

        <h4 id="2-2-1-系统架构图"   >
          <a href="#2-2-1-系统架构图" class="heading-link"><i class="fas fa-link"></i></a>2.2.1 系统架构图</h4>
      <ul>
<li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p>
</li>
<li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p>
<p><img src="/images/image-20210729172153796.png"></p>
</li>
<li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p>
<p><img src="/images/1629720945720.png"></p>
<p>(1)核心层</p>
<ul>
<li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li>
</ul>
<p>(2)AOP层</p>
<ul>
<li>AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D;</li>
<li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li>
</ul>
<p>(3)数据层</p>
<ul>
<li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li>
<li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li>
<li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li>
</ul>
<p>(4)Web层</p>
<ul>
<li>这一层的内容将在SpringMVC框架具体学习</li>
</ul>
<p>(5)Test层</p>
<ul>
<li>Spring主要整合了Junit来完成单元测试和集成测试</li>
</ul>
</li>
</ul>

        <h4 id="2-2-2-课程学习路线"   >
          <a href="#2-2-2-课程学习路线" class="heading-link"><i class="fas fa-link"></i></a>2.2.2 课程学习路线</h4>
      <p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p>
<ul>
<li>&#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;Spring的AOP&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D;</li>
</ul>
<p><img src="/images/1629722300996.png"></p>
<p>对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。</p>

        <h3 id="2-3-Spring核心概念"   >
          <a href="#2-3-Spring核心概念" class="heading-link"><i class="fas fa-link"></i></a>2.3 Spring核心概念</h3>
      <p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p>

        <h4 id="2-3-1-目前项目中的问题"   >
          <a href="#2-3-1-目前项目中的问题" class="heading-link"><i class="fas fa-link"></i></a>2.3.1 目前项目中的问题</h4>
      <p>一个概念的提出，总是因为有对应的问题需要去解决，那么我们就需要先分析下目前咱们代码在编写过程中遇到的问题:</p>
<p><img src="/images/1629723232339.png"></p>
<p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p>
<p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p>
<p>(3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D; <strong>耦合度偏高</strong> &#x3D;&#x3D;</p>
<p>针对这个问题，该如何解决呢?</p>
<p><img src="/images/1629724206002.png"></p>
<p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p>
<p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p>
<p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p>
<p>针对这个问题，Spring就提出了一个解决方案:</p>
<ul>
<li>使用对象时，<mark>在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象</mark></li>
</ul>
<p>这种实现思就是Spring的一个核心概念</p>

        <h4 id="2-3-2-IOC、IOC容器、Bean、DI"   >
          <a href="#2-3-2-IOC、IOC容器、Bean、DI" class="heading-link"><i class="fas fa-link"></i></a>2.3.2 IOC、IOC容器、Bean、DI</h4>
      <ol>
<li>&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;</li>
</ol>
<p>(1)什么是控制反转呢？</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li>
<li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li>
<li>这种思想就是控制反转</li>
<li>别人[外部]指定是什么呢?继续往下学</li>
</ul>
</li>
</ul>
<p>(2)Spring和IOC之间的关系是什么呢?</p>
<ul>
<li>Spring技术对IOC思想进行了<strong>实现</strong></li>
<li>Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部”， IOC容器是IOC思想的具体实现</li>
<li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li>
</ul>
<p>(3)IOC容器的作用以及内部存放的是什么?</p>
<ul>
<li>IOC容器<strong>负责对象的创建</strong>、初始化等一系列工作，其中包含了数据层和业务层的类对象</li>
<li>被创建或被管理的<strong>对象</strong>在IOC容器中统称为**&#x3D;&#x3D;Bean&#x3D;&#x3D;**</li>
<li>IOC容器中放的就是一个个的Bean对象</li>
</ul>
<p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p>
<ul>
<li>不行，因为service运行需要依赖dao对象</li>
<li>IOC容器中虽然有service和dao对象</li>
<li>但是service对象和dao对象没有任何关系</li>
<li>需要把dao对象交给service,也就是说要<strong>绑定service和dao对象之间的关系</strong></li>
</ul>
<p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p>
<ol start="2">
<li>&#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D;</li>
</ol>
<p><img src="/images/1629735078619.png"></p>
<p>(1)什么是依赖注入呢?</p>
<ul>
<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li>
<li>这种思想就是依赖注入</li>
</ul>
</li>
</ul>
<p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p>
<ul>
<li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li>
</ul>
<p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠:</p>
<ul>
<li>使用IOC容器管理bean（IOC)</li>
<li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li>
<li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li>
</ul>

        <h4 id="2-3-3-核心概念小结"   >
          <a href="#2-3-3-核心概念小结" class="heading-link"><i class="fas fa-link"></i></a>2.3.3 核心概念小结</h4>
      <p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p>
<p>(1)什么IOC&#x2F;DI思想?</p>
<ul>
<li>IOC:控制反转，控制反转的是对象的创建权</li>
<li>DI:依赖注入，绑定对象与对象之间的依赖关系</li>
</ul>
<p>(2)什么是IOC容器?</p>
<p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p>
<p>(3)什么是Bean?</p>
<p>容器中所存放的一个个对象就叫Bean或Bean对象</p>

        <h2 id="3，入门案例"   >
          <a href="#3，入门案例" class="heading-link"><i class="fas fa-link"></i></a>3，入门案例</h2>
      <p>介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p>

        <h3 id="3-1-IOC入门案例"   >
          <a href="#3-1-IOC入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.1 IOC入门案例</h3>
      <p>对于入门案例，我们得先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-1-1-入门案例思路分析"   >
          <a href="#3-1-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.1.1 入门案例思路分析</h4>
      <p>(1)Spring是使用容器来管理bean对象的，那么管什么? </p>
<ul>
<li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li>
</ul>
<p>(2)如何将被管理的对象告知IOC容器?</p>
<ul>
<li>使用配置文件</li>
</ul>
<p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p>
<ul>
<li>Spring框架提供相应的接口</li>
</ul>
<p>(4)IOC容器得到后，如何从容器中获取bean?</p>
<ul>
<li>调用Spring框架提供对应接口中的方法</li>
</ul>
<p>(5)使用Spring导入哪些坐标?</p>
<ul>
<li>用别人的东西，就需要在pom.xml添加对应的依赖</li>
</ul>

        <h4 id="3-1-2-入门案例代码实现"   >
          <a href="#3-1-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.1.2 入门案例代码实现</h4>
      <blockquote>
<p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p>
<p>1.创建Maven的java项目</p>
<p>2.pom.xml添加Spring的依赖jar包</p>
<p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<p>4.resources下添加spring配置文件，并完成bean的配置</p>
<p>5.使用Spring提供的接口完成IOC容器的创建</p>
<p>6.从容器中获取对象进行方法调用</p>
</blockquote>

        <h5 id="步骤1-创建Maven项目"   >
          <a href="#步骤1-创建Maven项目" class="heading-link"><i class="fas fa-link"></i></a>步骤1:创建Maven项目</h5>
      <p><img src="/images/1629734010072.png"></p>

        <h5 id="步骤2-添加Spring的依赖jar包"   >
          <a href="#步骤2-添加Spring的依赖jar包" class="heading-link"><i class="fas fa-link"></i></a>步骤2:添加Spring的依赖jar包</h5>
      <p>pom.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-添加案例中需要的类"   >
          <a href="#步骤3-添加案例中需要的类" class="heading-link"><i class="fas fa-link"></i></a>步骤3:添加案例中需要的类</h5>
      <p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-添加spring配置文件"   >
          <a href="#步骤4-添加spring配置文件" class="heading-link"><i class="fas fa-link"></i></a>步骤4:添加spring配置文件</h5>
      <p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p>
<p><img src="/images/1629734336440.png"></p>

        <h5 id="步骤5-在配置文件中完成bean的配置"   >
          <a href="#步骤5-在配置文件中完成bean的配置" class="heading-link"><i class="fas fa-link"></i></a>步骤5:在配置文件中完成bean的配置</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>&#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D;</strong></p>

        <h5 id="步骤6-获取IOC容器"   >
          <a href="#步骤6-获取IOC容器" class="heading-link"><i class="fas fa-link"></i></a>步骤6:获取IOC容器</h5>
      <p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤7-从容器中获取对象进行方法调用"   >
          <a href="#步骤7-从容器中获取对象进行方法调用" class="heading-link"><i class="fas fa-link"></i></a>步骤7:从容器中获取对象进行方法调用</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤8-运行程序"   >
          <a href="#步骤8-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤8:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p>

        <h3 id="3-2-DI入门案例"   >
          <a href="#3-2-DI入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.2 DI入门案例</h3>
      <p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-2-1-入门案例思路分析"   >
          <a href="#3-2-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.2.1 入门案例思路分析</h4>
      <p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p>
<ul>
<li>DI的入门案例要依赖于前面IOC的入门案例</li>
</ul>
<p>(2)Service中使用new形式创建的Dao对象是否保留?</p>
<ul>
<li>需要删除掉，最终要使用IOC容器中的bean对象</li>
</ul>
<p>(3)Service中需要的Dao对象如何进入到Service中?</p>
<ul>
<li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li>
</ul>
<p>(4)Service与Dao间的关系如何描述?</p>
<ul>
<li>使用配置文件</li>
</ul>

        <h4 id="3-2-2-入门案例代码实现"   >
          <a href="#3-2-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.2.2 入门案例代码实现</h4>
      <blockquote>
<p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p>
<p>1.删除业务层中使用new的方式创建的dao对象</p>
<p>2.在业务层提供BookDao的setter方法</p>
<p>3.在配置文件中添加依赖注入的配置</p>
<p>4.运行程序调用方法</p>
</blockquote>

        <h5 id="步骤1-去除代码中的new"   >
          <a href="#步骤1-去除代码中的new" class="heading-link"><i class="fas fa-link"></i></a>步骤1: 去除代码中的new</h5>
      <p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-为属性提供setter方法"   >
          <a href="#步骤2-为属性提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤2:为属性提供setter方法</h5>
      <p>在BookServiceImpl类中,为BookDao提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-修改配置完成注入"   >
          <a href="#步骤3-修改配置完成注入" class="heading-link"><i class="fas fa-link"></i></a>步骤3:修改配置完成注入</h5>
      <p>在配置文件中添加依赖注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        		name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        		ref属性表示参照哪一个bean</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D;</p>
<ul>
<li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li>
<li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li>
<li>综上所述，对应关系如下:</li>
</ul>
<p><img src="/images/1629736314989.png"></p>

        <h5 id="步骤4-运行程序"   >
          <a href="#步骤4-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤4:运行程序</h5>
      <p>运行，测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>

        <h2 id="4，IOC相关内容"   >
          <a href="#4，IOC相关内容" class="heading-link"><i class="fas fa-link"></i></a>4，IOC相关内容</h2>
      <p>通过前面两个案例，我们已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p>

        <h3 id="4-1-bean基础配置"   >
          <a href="#4-1-bean基础配置" class="heading-link"><i class="fas fa-link"></i></a>4.1 bean基础配置</h3>
      <p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容：</p>

        <h4 id="4-1-1-bean基础配置-id与class"   >
          <a href="#4-1-1-bean基础配置-id与class" class="heading-link"><i class="fas fa-link"></i></a>4.1.1 bean基础配置(id与class)</h4>
      <p>对于bean的基础配置，在前面的案例中已经使用过:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p>
<p><img src="/images/image-20210729183500978.png"></p>
<p>这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。</p>
<p><strong>思考：</strong></p>
<ul>
<li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li>
</ul>
<p>答案肯定是不行，因为接口是没办法创建对象的。</p>
<ul>
<li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li>
</ul>
<p>在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案:</p>
<ul>
<li><p>使用前面IOC和DI的案例</p>
</li>
<li><p>重新搭建一个新的案例环境,目的是方便大家查阅代码</p>
<ul>
<li><p>搭建的内容和前面的案例是一样的，内容如下：</p>
<p><img src="/images/1629769227068.png"></p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-1-2-bean的name属性"   >
          <a href="#4-1-2-bean的name属性" class="heading-link"><i class="fas fa-link"></i></a>4.1.2 bean的name属性</h4>
      <p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p>
<p>首先来看下别名的配置说明:</p>
<p><img src="/images/image-20210729183558051.png"></p>

        <h5 id="步骤1：配置别名"   >
          <a href="#步骤1：配置别名" class="heading-link"><i class="fas fa-link"></i></a>步骤1：配置别名</h5>
      <p>打开spring的配置文件applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p>

        <h5 id="步骤2-根据名称容器中获取bean对象"   >
          <a href="#步骤2-根据名称容器中获取bean对象" class="heading-link"><i class="fas fa-link"></i></a>步骤2:根据名称容器中获取bean对象</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序"   >
          <a href="#步骤3-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p>
<p><img src="/images/1629771744003.png"></p>
</li>
<li><p>如果不存在,则会报错，如下:</p>
<p><img src="/images/1629771880920.png"></p>
<p>这个错误大家需要特别关注下:</p>
<p><img src="/images/1629771972886.png"></p>
<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p>
</li>
</ul>

        <h4 id="4-1-3-bean作用范围scope配置"   >
          <a href="#4-1-3-bean作用范围scope配置" class="heading-link"><i class="fas fa-link"></i></a>4.1.3 bean作用范围scope配置</h4>
      <p>关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。</p>
<p>看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?</p>
<p>我们先来看下<code>bean作用范围的配置属性</code>:</p>
<p><img src="/images/image-20210729183628138.png"></p>

        <h5 id="4-1-3-1-验证IOC容器中对象是否为单例"   >
          <a href="#4-1-3-1-验证IOC容器中对象是否为单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.1 验证IOC容器中对象是否为单例</h5>
      
        <h6 id="验证思路"   >
          <a href="#验证思路" class="heading-link"><i class="fas fa-link"></i></a>验证思路</h6>
      <p>​	同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p>

        <h6 id="具体实现"   >
          <a href="#具体实现" class="heading-link"><i class="fas fa-link"></i></a>具体实现</h6>
      <ul>
<li><p>创建一个AppForScope的类，在其main方法中来验证</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>打印，观察控制台的打印结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>结论:默认情况下，Spring创建的bean对象都是单例的</p>
</li>
</ul>
<p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p>

        <h5 id="4-1-3-2-配置bean为非单例"   >
          <a href="#4-1-3-2-配置bean为非单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.2 配置bean为非单例</h5>
      <p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p>
<ul>
<li><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>将scope设置为<code>singleton</code></p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>将scope设置为<code>prototype</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772928714.png"></p>
</li>
<li><p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p>
<ul>
<li><code>singleton</code>默认为单例</li>
<li><code>prototype</code>为非单例</li>
</ul>
</li>
</ul>

        <h5 id="4-1-3-3-scope使用后续思考"   >
          <a href="#4-1-3-3-scope使用后续思考" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.3 scope使用后续思考</h5>
      <p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p>
<ul>
<li><p>为什么bean默认为单例?</p>
<ul>
<li>bean为单例的意思是在Spring的IOC容器中<strong>只会有该类的一个对象</strong></li>
<li>bean对象只有一个就<strong>避免了对象的频繁创建与销毁</strong>，达到了bean对象的<strong>复用，性能高</strong></li>
</ul>
</li>
<li><p>bean在容器中是单例的，会不会产生<strong>线程安全</strong>问题?</p>
<ul>
<li><p>如果对象是<mark>有状态</mark>对象，即该对象有成员变量可以用来存储数据的，</p>
<p>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</p>
</li>
<li><p>如果对象是<mark>无状态</mark>对象，即该对象没有成员变量没有进行数据存储的，</p>
<p>因方法中的<strong>局部变量在方法调用完成后会被销毁</strong>，所以不会存在线程安全问题。</p>
</li>
</ul>
</li>
<li><p>哪些bean对象适合交给容器进行管理?</p>
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
</li>
<li><p>哪些bean对象不适合交给容器进行管理?</p>
<ul>
<li>封装<strong>实例</strong>的域对象，因为会引发线程安全问题，所以不适合。</li>
</ul>
</li>
</ul>

        <h4 id="4-14-bean基础配置小结"   >
          <a href="#4-14-bean基础配置小结" class="heading-link"><i class="fas fa-link"></i></a>4.14 bean基础配置小结</h4>
      <p>关于bean的基础配置中，需要大家掌握以下属性:</p>
<p><img src="/images/1631529887695.png"></p>

        <h3 id="4-2-bean实例化"   >
          <a href="#4-2-bean实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2 bean实例化</h3>
      <p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p>
<p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p>
<ul>
<li>bean是如何创建的</li>
<li>实例化bean的三种方式，<code>构造方法(重点)</code>,<code>静态工厂</code>，<code>实例工厂()</code>，<code>FactoryBean()(重点)</code></li>
</ul>
<p>在讲解这三种创建方式之前，我们需要先确认一件事:</p>
<p>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</p>
<p>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</p>

        <h4 id="4-2-1-环境准备"   >
          <a href="#4-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.1 环境准备</h4>
      <p>为了方便大家阅读代码，重新准备个开发环境，</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629775585694.png"></p>

        <h4 id="4-2-2-构造方法实例化"   >
          <a href="#4-2-2-构造方法实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.2 构造方法实例化</h4>
      <p>在上述的环境下，我们来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p>

        <h5 id="步骤1-准备需要被创建的类"   >
          <a href="#步骤1-准备需要被创建的类" class="heading-link"><i class="fas fa-link"></i></a>步骤1:准备需要被创建的类</h5>
      <p>准备一个BookDao和BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-将类配置到Spring容器"   >
          <a href="#步骤2-将类配置到Spring容器" class="heading-link"><i class="fas fa-link"></i></a>步骤2:将类配置到Spring容器</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-编写运行程序"   >
          <a href="#步骤3-编写运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:编写运行程序</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-类中提供构造函数测试"   >
          <a href="#步骤4-类中提供构造函数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤4:类中提供构造函数测试</h5>
      <p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤5-将构造函数改成private测试"   >
          <a href="#步骤5-将构造函数改成private测试" class="heading-link"><i class="fas fa-link"></i></a>步骤5:将构造函数改成private测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,因为无论私有公有都能够被访问，所以我们可以说，<strong>Spring底层用的是反射</strong></p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤6-构造函数中添加一个参数测试"   >
          <a href="#步骤6-构造函数中添加一个参数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤6:构造函数中添加一个参数测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，</p>
<p>程序会报错，说明Spring底层使用的是<strong>类的无参构造方法</strong>。</p>
<p>（原因：有参构造器通常意味着类要进行实例化，而实例化的类在IOC的单例模式下很容易造成线程安全问题，所以IOC拒绝访问有参构造器生成的对象）</p>
<p><img src="/images/1629776331499.png"></p>
<p><mark>底层是运用反射获取类的无参构造器来构造类的单例对象。</mark></p>

        <h4 id="4-2-3-分析Spring的错误信息-简单看看就好了"   >
          <a href="#4-2-3-分析Spring的错误信息-简单看看就好了" class="heading-link"><i class="fas fa-link"></i></a>4.2.3 分析Spring的错误信息(简单看看就好了)</h4>
      <p>接下来，我们主要研究下Spring的报错信息来学一学如阅读。</p>
<ul>
<li><p>错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面</p>
<blockquote>
<p>Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>Caused by 翻译为<code>引起</code>，即出现错误的原因</li>
<li>java.lang.NoSuchMethodException:抛出的异常为<code>没有这样的方法异常</code></li>
<li>com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>():哪个类的哪个方法没有被找到导致的异常，<code>&lt;init&gt;</code>()指定是类的构造方法，即该类的无参构造方法</li>
</ul>
</li>
</ul>
<p>如果最后一行错误获取不到错误信息，接下来查看第二层:</p>
<blockquote>
<p> Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>nested:嵌套的意思，后面的异常内容和最底层的异常是一致的<ul>
<li>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; <ul>
<li>Caused by: <code>引发</code></li>
<li>BeanInstantiationException:翻译为<code>bean实例化异常</code></li>
<li>No default constructor found:没有一个默认的构造函数被发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看到这其实错误已经比较明显，给大家个练习，把倒数第三层的错误分析下吧:</p>
<blockquote>
<p> Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bookDao’ defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()。</p>
</blockquote>
<p>至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做。这也是我们以后比较常用的一种方式。</p>

        <h4 id="4-2-4-静态工厂实例化"   >
          <a href="#4-2-4-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4 静态工厂实例化</h4>
      <p>接下来研究Spring中的第二种bean的创建方式<code>静态工厂实例化</code>:</p>

        <h5 id="4-2-4-1-工厂方式创建bean"   >
          <a href="#4-2-4-1-工厂方式创建bean" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.1 工厂方式创建bean</h5>
      <p>在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式:</p>
<p>(1)准备一个OrderDao和OrderDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> OrderDaoFactory.getOrderDao();</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?</p>

        <h5 id="4-2-4-2-静态工厂实例化"   >
          <a href="#4-2-4-2-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.2 静态工厂实例化</h5>
      <p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</p>
<p>(1)在spring的配置文件application.properties中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>class:工厂类的类全名</p>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>对应关系如下图:</p>
<p><img src="/images/image-20210729195248948.png"></p>
<p>(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> (OrderDao) ctx.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        orderDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么?</p>
<p>主要的原因是:</p>
<ul>
<li>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如:</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory setup....&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果:</p>
<p><img src="/images/1629788036885.png"></p>
<p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。</p>

        <h4 id="4-2-5-实例工厂与FactoryBean"   >
          <a href="#4-2-5-实例工厂与FactoryBean" class="heading-link"><i class="fas fa-link"></i></a>4.2.5 实例工厂与FactoryBean</h4>
      <p>接下来继续来研究Spring的第三种bean的创建方式<code>实例工厂实例化</code>:</p>

        <h5 id="4-2-3-1-环境准备"   >
          <a href="#4-2-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.1 环境准备</h5>
      <p>(1)准备一个UserDao和UserDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceUser运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">UserDaoFactory</span> <span class="variable">userDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> userDaoFactory.getUserDao();</span><br><span class="line">        userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>对于上面这种实例工厂的方式如何交给Spring管理呢?</p>

        <h5 id="4-2-3-2-实例工厂实例化"   >
          <a href="#4-2-3-2-实例工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.2 实例工厂实例化</h5>
      <p>具体实现步骤为:</p>
<p>(1)在spring的配置文件中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>实例化工厂运行的顺序是:</p>
<ul>
<li><p>创建实例化工厂对象,对应的是第一行配置</p>
</li>
<li><p>调用对象中的方法来创建bean，对应的是第二行配置</p>
<ul>
<li><p>factory-bean:工厂的实例对象</p>
</li>
<li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p>
<p><img src="/images/image-20210729200203249.png"></p>
</li>
</ul>
</li>
</ul>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p>

        <h5 id="4-2-3-3-FactoryBean的使用"   >
          <a href="#4-2-3-3-FactoryBean的使用" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.3 FactoryBean的使用</h5>
      <p>具体的使用步骤为:</p>
<p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)在Spring的配置文件中进行配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p>
<p><img src="/images/1629788769436.png"></p>
<p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。</p>
<p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p>
<p>方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象</p>
<p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?</p>
<p>思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>打印结果，如下:</p>
<p><img src="/images/1629790070607.png"></p>
<p>通过验证，会发现默认是单例，那如果想改成单例具体如何实现?</p>
<p>只需要将isSingleton()方法进行重写，修改返回为false，即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FactoryBean创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForInstanceUser，查看结果</p>
<p><img src="/images/1629790197860.png"></p>
<p>从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。</p>

        <h4 id="4-2-6-bean实例化小结"   >
          <a href="#4-2-6-bean实例化小结" class="heading-link"><i class="fas fa-link"></i></a>4.2.6 bean实例化小结</h4>
      <p>通过这一节的学习，需要掌握:</p>
<p>(1)bean是如何创建的呢?</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></div></figure>

<p>(2)Spring的IOC实例化对象的三种方式分别是:</p>
<ul>
<li>构造方法(常用)</li>
<li>静态工厂(了解)</li>
<li>实例工厂(了解)<ul>
<li>FactoryBean(实用)</li>
</ul>
</li>
</ul>
<p>这些方式中，重点掌握<code>构造方法</code>和<code>FactoryBean</code>即可。</p>
<p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p>

        <h3 id="4-3-bean的生命周期"   >
          <a href="#4-3-bean的生命周期" class="heading-link"><i class="fas fa-link"></i></a>4.3 bean的生命周期</h3>
      <p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解:</p>
<ul>
<li>首先理解下什么是生命周期?<ul>
<li>从创建到消亡的完整过程,例如人<strong>从出生到死亡</strong>的整个过程就是一个生命周期。</li>
</ul>
</li>
<li>bean生命周期是什么?<ul>
<li>bean对象从创建到销毁的整体过程。</li>
</ul>
</li>
<li>bean生命周期控制是什么?<ul>
<li>在bean创建后到销毁前做一些事情。</li>
</ul>
</li>
</ul>
<p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p>

        <h4 id="4-3-1-环境准备"   >
          <a href="#4-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.3.1 环境准备</h4>
      <p>还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629791473409.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        	<span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-3-2-生命周期设置"   >
          <a href="#4-3-2-生命周期设置" class="heading-link"><i class="fas fa-link"></i></a>4.3.2 生命周期设置</h4>
      <p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p>
<ul>
<li>bean<strong>创建之后</strong>，想要添加内容，比如用<strong>来初始化需要用到资源</strong></li>
<li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li>
</ul>

        <h5 id="步骤1-添加初始化和销毁方法"   >
          <a href="#步骤1-添加初始化和销毁方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加初始化和销毁方法</h5>
      <p>针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置生命周期"   >
          <a href="#步骤2-配置生命周期" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置生命周期</h5>
      <p>在配置文件添加配置，如下:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-1"   >
          <a href="#步骤3-运行程序-1" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForLifeCycle打印结果为:</p>
<p><img src="/images/1629792339889.png"></p>
<p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p>
<ul>
<li>Spring的IOC容器是运行在JVM中</li>
<li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li>
<li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li>
<li>所以没有调用对应的destroy方法</li>
</ul>
<p>知道了出现问题的原因，具体该如何解决呢?</p>

        <h4 id="4-3-3-close关闭容器"   >
          <a href="#4-3-3-close关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.3 close关闭容器</h4>
      <ul>
<li><p>ApplicationContext中没有close方法</p>
</li>
<li><p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>调用ctx的close()方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>运行程序，就能执行destroy方法的内容</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>

        <h4 id="4-3-4-注册钩子关闭容器"   >
          <a href="#4-3-4-注册钩子关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.4 注册钩子关闭容器</h4>
      <ul>
<li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p>
</li>
<li><p>调用ctx的<code>registerShutdownHook()</code>方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></div></figure>

<p>**注意:**registerShutdownHook在ApplicationContext中也没有</p>
</li>
<li><p>运行后，查询打印结果</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>
<p>两种方式介绍完后，close和registerShutdownHook选哪个?</p>
<p>相同点:这两种都能用来关闭容器</p>
<p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p>
<p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p>
<p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p>
<p>接下来在BookServiceImpl完成这两个接口的使用:</p>
<p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForLifeCycle类，</p>
<p><img src="/images/1629794527419.png"></p>
<p>那第二种方式的实现，我们也介绍完了。</p>
<p><strong>小细节</strong></p>
<ul>
<li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p>
</li>
<li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p>
</li>
<li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p>
</li>
<li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p>
<ul>
<li><p>从方法名分析，猜想应该是setBookDao方法先执行</p>
</li>
<li><p>验证思路，在setBookDao方法中添加一句话</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>重新运行AppForLifeCycle，打印结果如下:</p>
<p><img src="/images/1629794928636.png"></p>
<p>验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-3-5-bean生命周期小结"   >
          <a href="#4-3-5-bean生命周期小结" class="heading-link"><i class="fas fa-link"></i></a>4.3.5 bean生命周期小结</h4>
      <p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p>
<ul>
<li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li>
<li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li>
</ul>
<p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p>
<ul>
<li>初始化容器<ul>
<li>1.创建对象(内存分配)</li>
<li>2.执行构造方法</li>
<li>3.执行属性注入(set操作)</li>
<li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li>
</ul>
</li>
<li>使用bean<ul>
<li>1.执行业务操作</li>
</ul>
</li>
<li>关闭&#x2F;销毁容器<ul>
<li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p>(3)关闭容器的两种方式:</p>
<ul>
<li>ConfigurableApplicationContext是ApplicationContext的子类<ul>
<li>close()方法</li>
<li>registerShutdownHook()方法</li>
</ul>
</li>
</ul>

        <h2 id="5，DI相关内容"   >
          <a href="#5，DI相关内容" class="heading-link"><i class="fas fa-link"></i></a>5，DI相关内容</h2>
      <p>前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p>
<p>我们先来思考</p>
<ul>
<li>向一个类中传递数据的方式有几种?<ul>
<li>普通方法(set方法)</li>
<li>构造方法</li>
</ul>
</li>
<li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?<ul>
<li>引用类型</li>
<li>简单类型(基本数据类型与String)</li>
</ul>
</li>
</ul>
<p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p>
<ul>
<li>setter注入<ul>
<li>简单类型</li>
<li>&#x3D;&#x3D;引用类型&#x3D;&#x3D;</li>
</ul>
</li>
<li>构造器注入<ul>
<li>简单类型</li>
<li>引用类型</li>
</ul>
</li>
</ul>
<p>依赖注入的方式已经介绍完，接下来挨个学习下:</p>

        <h3 id="5-1-setter注入"   >
          <a href="#5-1-setter注入" class="heading-link"><i class="fas fa-link"></i></a>5.1 setter注入</h3>
      <ol>
<li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li>
</ol>
<ul>
<li>在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-1-1-环境准备"   >
          <a href="#5-1-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 环境准备</h4>
      <p>为了更好的学习下面内容，我们依旧准备一个新环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629799214191.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDISet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成setter注入的学习:</p>

        <h4 id="5-1-2-注入引用数据类型"   >
          <a href="#5-1-2-注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 注入引用数据类型</h4>
      <blockquote>
<p>需求:在bookServiceImpl对象中注入userDao</p>
<p>1.在BookServiceImpl中声明userDao属性</p>
<p>2.为userDao属性提供setter方法</p>
<p>3.在配置文件中使用property标签注入</p>
</blockquote>

        <h5 id="步骤1-声明属性并提供setter方法"   >
          <a href="#步骤1-声明属性并提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookServiceImpl中声明userDao属性，并提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置"   >
          <a href="#步骤2-配置文件中进行注入配置" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-2"   >
          <a href="#步骤3-运行程序-2" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629799873386.png"></p>

        <h4 id="5-1-3-注入简单数据类型"   >
          <a href="#5-1-3-注入简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 注入简单数据类型</h4>
      <blockquote>
<p>需求：给BookDaoImpl注入一些简单数据类型的数据</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p>
<p>2.为这些属性提供对应的setter方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>
<p><strong>思考:</strong></p>
<p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p>
<p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p>

        <h5 id="步骤1-声明属性并提供setter方法-1"   >
          <a href="#步骤1-声明属性并提供setter方法-1" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置-1"   >
          <a href="#步骤2-配置文件中进行注入配置-1" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p>

        <h5 id="步骤3-运行程序-3"   >
          <a href="#步骤3-运行程序-3" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629800324721.png"></p>
<p>**注意:**两个property注入标签的顺序可以任意。</p>
<p>对于setter注入方式的基本使用就已经介绍完了，</p>
<ul>
<li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li>
<li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>

        <h3 id="5-2-构造器注入"   >
          <a href="#5-2-构造器注入" class="heading-link"><i class="fas fa-link"></i></a>5.2 构造器注入</h3>
      
        <h4 id="5-2-1-环境准备"   >
          <a href="#5-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.2.1 环境准备</h4>
      <p>构造器注入也就是构造方法注入，学习之前，还是先准备下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629800748639.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDIConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-2-2-构造器注入引用数据类型"   >
          <a href="#5-2-2-构造器注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.2 构造器注入引用数据类型</h4>
      <p>接下来，在上面这个环境中来完成构造器注入的学习:</p>
<blockquote>
<p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p>
<p>1.将bookDao的setter方法删除掉</p>
<p>2.添加带有bookDao参数的构造方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>

        <h5 id="步骤1-删除setter方法并提供构造方法"   >
          <a href="#步骤1-删除setter方法并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:删除setter方法并提供构造方法</h5>
      <p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行配置构造方式注入"   >
          <a href="#步骤2-配置文件中进行配置构造方式注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行配置构造方式注入</h5>
      <p>在applicationContext.xml中配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>标签<constructor-arg>中</p>
<ul>
<li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p>
</li>
<li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p>
</li>
</ul>

        <h5 id="步骤3：运行程序"   >
          <a href="#步骤3：运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3：运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p>
<p><img src="/images/1629802656916.png"></p>

        <h4 id="5-2-3-构造器注入多个引用数据类型"   >
          <a href="#5-2-3-构造器注入多个引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.3 构造器注入多个引用数据类型</h4>
      <blockquote>
<p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p>
<p>1.声明userDao属性</p>
<p>2.生成一个带有bookDao和userDao参数的构造函数</p>
<p>3.在applicationContext.xml中配置注入</p>
</blockquote>

        <h5 id="步骤1-提供多个属性的构造函数"   >
          <a href="#步骤1-提供多个属性的构造函数" class="heading-link"><i class="fas fa-link"></i></a>步骤1:提供多个属性的构造函数</h5>
      <p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>步骤2:配置文件中配置多参数注入</p>
<p>在applicationContext.xml中配置注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-4"   >
          <a href="#步骤3-运行程序-4" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629802697318.png"></p>

        <h4 id="5-2-4-构造器注入多个简单数据类型"   >
          <a href="#5-2-4-构造器注入多个简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.4 构造器注入多个简单数据类型</h4>
      <blockquote>
<p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.提供一个包含这两个参数的构造方法</p>
<p>2.在applicationContext.xml中进行注入配置</p>
</blockquote>

        <h5 id="步骤1-添加多个简单属性并提供构造方法"   >
          <a href="#步骤1-添加多个简单属性并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加多个简单属性并提供构造方法</h5>
      <p>修改BookDaoImpl类，添加构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置完成多个属性构造器注入"   >
          <a href="#步骤2-配置完成多个属性构造器注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置完成多个属性构造器注入</h5>
      <p>在applicationContext.xml中进行注入配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-5"   >
          <a href="#步骤3-运行程序-5" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果</p>
<p><img src="/images/1629803111769.png"></p>
<p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p>
<p><img src="/images/1629803529598.png"></p>
<ul>
<li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li>
<li>这两块存在紧耦合，具体该如何解决?</li>
</ul>
<p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p>
<p>方式一:删除name属性，添加type属性，按照类型注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li>
<li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li>
</ul>
<p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决参数类型重复问题</li>
<li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li>
</ul>
<p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p>
<ol>
<li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul>
<li>强制依赖指对象在创建的过程中必须要注入指定的参数</li>
</ul>
</li>
<li>可选依赖使用setter注入进行，灵活性强<ul>
<li>可选依赖指对象在创建过程中注入的参数可有可无</li>
</ul>
</li>
<li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><strong>&#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D;</strong></li>
</ol>
<p>这节中主要讲解的是Spring的依赖注入的实现方式:</p>
<ul>
<li><p>setter注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>构造器注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>依赖注入的方式选择上</p>
<ul>
<li>建议使用setter注入</li>
<li>第三方技术根据情况选择</li>
</ul>
</li>
</ul>

        <h3 id="5-3-自动配置"   >
          <a href="#5-3-自动配置" class="heading-link"><i class="fas fa-link"></i></a>5.3 自动配置</h3>
      <p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。</p>
<p>问:麻烦在哪?</p>
<p>答:配置文件的编写配置上。</p>
<p>问:有更简单方式么?</p>
<p>答:有，自动配置</p>
<p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p>

        <h4 id="5-3-1-什么是依赖自动装配"   >
          <a href="#5-3-1-什么是依赖自动装配" class="heading-link"><i class="fas fa-link"></i></a>5.3.1 什么是依赖自动装配?</h4>
      <ul>
<li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li>
</ul>

        <h4 id="5-3-2-自动装配方式有哪些"   >
          <a href="#5-3-2-自动装配方式有哪些" class="heading-link"><i class="fas fa-link"></i></a>5.3.2 自动装配方式有哪些?</h4>
      <ul>
<li>&#x3D;&#x3D;按类型（常用）&#x3D;&#x3D;</li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>

        <h4 id="5-3-3-准备下案例环境"   >
          <a href="#5-3-3-准备下案例环境" class="heading-link"><i class="fas fa-link"></i></a>5.3.3 准备下案例环境</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629805387647.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-3-4-完成自动装配的配置"   >
          <a href="#5-3-4-完成自动装配的配置" class="heading-link"><i class="fas fa-link"></i></a>5.3.4 完成自动装配的配置</h4>
      <p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p>
<p>自动装配只需要修改applicationContext.xml配置文件即可:</p>
<p>(1)将<code>&lt;property&gt;</code>标签删除</p>
<p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p>
<p>首先来实现按照类型注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li>需要注入属性的类中对应属性的setter方法不能省略</li>
<li>被注入的对象必须要被Spring的IOC容器管理</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li>
</ul>
<p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>按照名称注入中的名称指的是什么?</p>
<p><img src="/images/1629806856156.png"></p>
<ul>
<li>bookDao是private修饰的，外部类无法直接方法</li>
<li>外部类只能通过属性的set方法进行访问</li>
<li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul>
<li>为什么是去掉set首字母小写?</li>
<li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li>
</ul>
</li>
<li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li>
</ul>
</li>
<li><p>如果按照名称去找对应的bean对象，找不到则注入Null</p>
</li>
<li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p>
</li>
</ul>
<p>两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。</p>
<p>最后对于依赖注入，需要注意一些其他的配置特征:</p>
<ol>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>
<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>
</ol>

        <h3 id="5-4-集合注入"   >
          <a href="#5-4-集合注入" class="heading-link"><i class="fas fa-link"></i></a>5.4 集合注入</h3>
      <p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p>
<p>先来回顾下，常见的集合类型有哪些?</p>
<ul>
<li>数组</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>Properties</li>
</ul>
<p>针对不同的集合类型，该如何实现注入呢?</p>

        <h4 id="5-4-1-环境准备"   >
          <a href="#5-4-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.4.1 环境准备</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629807579330.png"></p>
<p>(1)项目中添加添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件，applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDICollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成<code>集合注入</code>的学习:</p>
<p>下面的所以配置方式，都是在bookDao的bean标签中使用<property>进行注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-2-注入数组类型数据"   >
          <a href="#5-4-2-注入数组类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.2 注入数组类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-3-注入List类型数据"   >
          <a href="#5-4-3-注入List类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.3 注入List类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-4-注入Set类型数据"   >
          <a href="#5-4-4-注入Set类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.4 注入Set类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-5-注入Map类型数据"   >
          <a href="#5-4-5-注入Map类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.5 注入Map类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-6-注入Properties类型数据"   >
          <a href="#5-4-6-注入Properties类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.6 注入Properties类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>配置完成后，运行下看结果:</p>
<p><img src="/images/1629808046783.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/370/">GC</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-内存分配与回收原则"   >
          <a href="#1-内存分配与回收原则" class="heading-link"><i class="fas fa-link"></i></a>1. 内存分配与回收原则</h1>
      
        <h2 id="1-1-对象优先在Eden区进行分配"   >
          <a href="#1-1-对象优先在Eden区进行分配" class="heading-link"><i class="fas fa-link"></i></a>1.1 对象优先在Eden区进行分配</h2>
      <p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。若无法存入survivor区，则通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去 </p>
<blockquote>
<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
</blockquote>

        <h2 id="1-2-大对象直接进入老年代"   >
          <a href="#1-2-大对象直接进入老年代" class="heading-link"><i class="fas fa-link"></i></a>1.2 大对象直接进入老年代</h2>
      <p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>

        <h2 id="1-3-长期存活的对象进入老年代"   >
          <a href="#1-3-长期存活的对象进入老年代" class="heading-link"><i class="fas fa-link"></i></a>1.3 长期存活的对象进入老年代</h2>
      <p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。<br>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>

        <h2 id="1-4-GC的分类"   >
          <a href="#1-4-GC的分类" class="heading-link"><i class="fas fa-link"></i></a>1.4 GC的分类</h2>
      <p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li>部分收集 (Partial GC)：<br>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；<br>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；<br>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>
</ul>

        <h1 id="2-如何判断对象可以被回收-死亡对象的判断"   >
          <a href="#2-如何判断对象可以被回收-死亡对象的判断" class="heading-link"><i class="fas fa-link"></i></a>2. 如何判断对象可以被回收(死亡对象的判断)</h1>
      
        <h2 id="2-1-引用计数法"   >
          <a href="#2-1-引用计数法" class="heading-link"><i class="fas fa-link"></i></a>2.1 引用计数法</h2>
      <p>通过调用对象的次数计数，调用了一次+1，调用了两次+2；如果失去引用了，计数器-1；<br>弊端：循环引用可能导致计数次数无法归零，进而导致内存泄漏。</p>

        <h2 id="2-2-可达性分析算法"   >
          <a href="#2-2-可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a>2.2 可达性分析算法</h2>
      <p>先确立一个根对象(<code>GC Root</code>)，看有没有对象和根对象直接或者间接的引用，如果有，那就是不能被垃圾回收的对象。<br>可作为<code>GC Root</code>对象的有：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>

        <h2 id="2-3-四种引用"   >
          <a href="#2-3-四种引用" class="heading-link"><i class="fas fa-link"></i></a>2.3 四种引用</h2>
      
        <h3 id="2-3-1-强引用"   >
          <a href="#2-3-1-强引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.1 强引用</h3>
      <p>沿着根对象能找到的A对象，那么A对象称为被强引用。仅当强引用与A对象断开时，可被回收。</p>

        <h3 id="2-3-2-软引用"   >
          <a href="#2-3-2-软引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.2 软引用</h3>
      <p><code>SoftRenference&lt;byte[]&gt; ref = new SoftRenference&lt;&gt;(new byte[])</code><br><strong>没有被强引用所引用</strong>，垃圾回收发生时都<u>有可能</u>被回收。<br>当发生过一次垃圾回收且内存仍然不够时，会回收<strong>被软引用引用的对象</strong>。<br>软引用一般适用于一些非必要的场景，比如说网页图片，没有必要一直占着内存空间，等到需要的时候再加载就可以了。</p>
<ul>
<li>具体案例如下：<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">soft</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line"></span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<strong>输出结果：</strong><blockquote>
<p>[B@330bedb4<br>1<br>[B@2503dbd3<br>2<br>[B@4b67cf4d<br>3<br>[GC (Allocation Failure) [PSYoungGen: 2162K-&gt;488K(6144K)] 14450K-&gt;13074K(19968K), 0.0019161 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br><mark>内存不足，进行一次垃圾回收。</mark><br>[B@7ea987ac<br>4<br>[GC (Allocation Failure) –[PSYoungGen: 4696K-&gt;4696K(6144K)] 17282K-&gt;17290K(19968K), 0.0006865 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4535K(6144K)] [ParOldGen: 12594K-&gt;12545K(13824K)] 17290K-&gt;17080K(19968K), [Metaspace: 3373K-&gt;3373K(1056768K)], 0.&gt; &gt; 0045075 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]<br>[GC (Allocation Failure) –[PSYoungGen: 4535K-&gt;4535K(6144K)] 17080K-&gt;17096K(19968K), 0.0006433 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>[Full GC (Allocation Failure) [PSYoungGen: 4535K-&gt;0K(6144K)] [ParOldGen: 12561K-&gt;677K(8704K)] 17096K-&gt;677K(14848K), [Metaspace: 3373K-&gt;3373K(1056768K)], 0.&gt; &gt; 0059614 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs]<br><mark>进行一次垃圾回收之后内存仍然不足，触发软引用机制，将软引用创建的对象所垃圾回收释放空间。</mark><br>[B@12a3a380<br>5<br>循环结束：5<br>null<br>null<br>null<br>null<br>[B@12a3a380</p>
</blockquote>
</li>
</ul>

        <h3 id="2-3-3-引用队列"   >
          <a href="#2-3-3-引用队列" class="heading-link"><i class="fas fa-link"></i></a>2.3.3 引用队列</h3>
      <p>软弱引用无引用对象时，自动进入引用队列</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">    Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>( poll != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<blockquote>
<p>[B@4aa8f0b4 (最后结果)</p>
</blockquote>

        <h3 id="2-3-4-弱引用"   >
          <a href="#2-3-4-弱引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.4 弱引用</h3>
      <p>只要当发生了垃圾回收，被<strong>弱引用引用的对象</strong>会被回收。<br>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>类似于软引用。</p>

        <h3 id="2-3-5-虚引用"   >
          <a href="#2-3-5-虚引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.5 虚引用</h3>
      <p>必须配合引用队列来使用。创建时即关联引用队列。缓存时会留下直接内存，当<code>StringBuffer</code>对象被回收时，他的直接内存没有被回收掉，此时虚引用对象进入引用队列，调用线程清理直接内存。<br>虚引用主要用来跟踪对象被垃圾回收的活动。起到触发器的作用，当虚引用的对象意识到自己快要被回收了，会做出一些相应的程序。</p>

        <h3 id="2-3-6-终结器引用"   >
          <a href="#2-3-6-终结器引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.6 终结器引用</h3>
      <p>当<code>finallize()</code>将要被垃圾回收时，将终结器引用放入引用队列，由<code>finallizeHandler</code>去由终结器引用的对象去销毁对象<br>所以说当对象不可达的时候不会被立刻销毁，而要经历两次标记之后才确定要被销毁。<br>缺点：<code>finallizeHandler</code>优先级很低，且销毁流程漫长，需要两次GC才能销毁完成，易造成内存泄漏 。</p>

        <h1 id="3-三种垃圾收集算法"   >
          <a href="#3-三种垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a>3. 三种垃圾收集算法</h1>
      
        <h2 id="3-1-标记——清除算法-Mark-Clear"   >
          <a href="#3-1-标记——清除算法-Mark-Clear" class="heading-link"><i class="fas fa-link"></i></a>3.1 标记——清除算法(Mark-Clear)</h2>
      <ul>
<li>流程：首先标记出需要垃圾回收的对象，标记完成后，统一回收被标记的对象。也可以相反。</li>
<li>缺点：<br><strong>执行效率不稳定</strong>，随着对象增长降低效率不断变化；<br><strong>内存空间碎片化</strong>，需要分配较大内存时无法找到足够连续内存不得不提前进行一次垃圾回收操作。<br><img src="/images/Mark-Sweep.png"></li>
</ul>

        <h2 id="3-2-标记——复制算法-Mark-Copy"   >
          <a href="#3-2-标记——复制算法-Mark-Copy" class="heading-link"><i class="fas fa-link"></i></a>3.2 标记——复制算法(Mark-Copy)</h2>
      <ul>
<li>流程：<strong>半区复制。</strong> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，这一块的内存用完了，就将存活着的对象复制到另一块的上面，然后再把已使用的内存空间一次性清理掉。</li>
<li>优点：解决了碎片空间的问题，只需要移动栈顶指针，按顺序分配即可</li>
<li>缺点：<strong>内存缩小到原来的一半</strong>，造成空间浪费<br><img src="/images/Mark-Copy.png"></li>
</ul>
<p>拓展：APPel式回收<br>把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用一块Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor仍然存活的对象一次性复制到另一块Survivor中，直接清理掉原来的两块对象。<br><img src="/images/Appel.png"></p>
<blockquote>
<p>理论依据：HotSpot默认Eden和Survivor的大小比为8：1，即新生代内存空间占总内存空间的90%，相比于标记复制算法节约了巨大的内存空间，而“朝生夕灭”理论认为，新生代中有98%的对象熬不过第一轮收集，所以内存空间时绰绰有余的。</p>
</blockquote>

        <h2 id="3-3-标记——整理算法-Mark-Compact"   >
          <a href="#3-3-标记——整理算法-Mark-Compact" class="heading-link"><i class="fas fa-link"></i></a>3.3 标记——整理算法(Mark-Compact)</h2>
      <ul>
<li>流程：标记算法和前两者一样，而在回收的时候不同于前者，是先让所有存活的对象往内存空间的一侧进行移动，然后直接清理掉边界之外的内存。</li>
<li>缺点：移动更新对象任务量及其庞大，需要全程暂停用户应用程序才能进行。易形成<code>Stop The World</code>现象。</li>
<li>移动和不移动的利弊比较：<br>是否移动对象都存在弊端，<strong>移动则内存回收</strong>时会更复杂，<strong>不移动则内存分配</strong>时会更复杂；从<strong>垃圾收集的停顿时间</strong>来看，<strong>不移动</strong>对象停顿时间会更短，甚至可以不需要停顿，但是从整个<strong>程序的吞吐量</strong>来看，<strong>移动对象会更划算</strong>；即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要 高得多，这部分的耗时增加，总吞吐量仍然是下降的</li>
</ul>

        <h2 id="4-垃圾分代回收"   >
          <a href="#4-垃圾分代回收" class="heading-link"><i class="fas fa-link"></i></a>4. 垃圾分代回收</h2>
      <p>(面试题)原因：<br>因为将对象分代可以根据各个年代的特点选择合适的垃圾分配机制。<br>比如在新生代，大部分(约98%)的对象都会被回收，那么这时候就可以使用标记——复制算法，只需要复制少量的存活对象，节约内存成本。而在老年代对象存活较多的情况下，也没有足够多的空间为其进行分配担保，所以使用“标记——清除”或者“标记——整理”分类方法。</p>

        <h2 id="4-1-分代垃圾回收机制"   >
          <a href="#4-1-分代垃圾回收机制" class="heading-link"><i class="fas fa-link"></i></a>4.1 分代垃圾回收机制</h2>
      <p><img src="/images/GC.png"></p>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to。</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长。</li>
<li>当新生代内存无法容纳对象大小，直接晋升为老年代</li>
<li>线程中出现OOM异常时，他占据的内存资源会全部释放掉，不会影响其他线程的运行</li>
</ul>

        <h2 id="4-2-VM相关参数"   >
          <a href="#4-2-VM相关参数" class="heading-link"><i class="fas fa-link"></i></a>4.2 VM相关参数</h2>
      <p><img src="/images/VMparams.png"></p>

        <h1 id="5-垃圾回收器"   >
          <a href="#5-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a>5. 垃圾回收器</h1>
      <blockquote>
<p>serial: 串行    单线程,一个方法执行完下个方法才能够执行<br>parallel : 并行   多线程,可以同时执行垃圾回收, 但其他无法方法运行 STW 相当于所有线程都归垃圾回收所有<br>concurrent : 并发   多线程,其他方法和垃圾回收可以同时执行,但是只能逐个进行垃圾回收,相当于平等的线程分配给每一个方法</p>
</blockquote>

        <h2 id="5-1-串行垃圾回收器-Serial-x2F-Serial-Old"   >
          <a href="#5-1-串行垃圾回收器-Serial-x2F-Serial-Old" class="heading-link"><i class="fas fa-link"></i></a>5.1 串行垃圾回收器(Serial&#x2F; Serial Old)</h2>
      <p>单线程。适用于堆内存较少的情况，适合个人电脑<br><code>-XX:+UseSerialGC = Serial + SerialOld</code><br><img src="/images/serial.png"><br>新生代用“标记——复制”算法，老年代用“标记——整理”算法</p>

        <h2 id="5-2-吞吐量优先-Parallel-x2F-Parallel-Old"   >
          <a href="#5-2-吞吐量优先-Parallel-x2F-Parallel-Old" class="heading-link"><i class="fas fa-link"></i></a>5.2 吞吐量优先(Parallel&#x2F; Parallel Old)</h2>
      <p>多线程，堆内存较大，多核CPU<br>单位时间内,完成STW次数越少(STW的时间占总用户时间)<br>关注吞吐量<br><code>XX:+UseparalellGC</code><br><code>-XX:ParallelGCThreads:n</code> :允许同时允许的线程数量<br><code>-XX:+UseAdaptSizePolicy</code> :自适应调整新生代的大小<br><code>-XX:GCTimeRadio:radio</code> : 最多允许<strong>垃圾回收时间占总线程时间</strong>的<mark>1&#x2F;(1+radio)</mark>,希望堆大，关注的是吞吐量<br><code>-XX:MaxGCPauseMillis=is</code> : default是200ms,表示<strong>最长垃圾回收时间</strong>,希望堆小,与上一个冲突，关注的是响应时间</p>

        <h2 id="5-2-响应时间优先-CMS-Concurrent-Marking-Sweep"   >
          <a href="#5-2-响应时间优先-CMS-Concurrent-Marking-Sweep" class="heading-link"><i class="fas fa-link"></i></a>5.2 响应时间优先(CMS Concurrent Marking Sweep)</h2>
      <p>多线程，堆内存较大，多核CPU<br>注重STW时间的长度(单独只考虑STW的时间)</p>
<ul>
<li>初始标记: 需要STW，但仅标记与GC Root关联的对象,速度快</li>
<li>并发标记: 从GC Root直接关联对象开始遍历整个对象图, 耗时长,但并发运行</li>
<li>重新标记: 需要STW, 修正因并发导致的对象标记变动</li>
<li>并发清除: 清理标记对象<br><strong><font color=red>只有在初始标记和重新标记时候才会STW</font></strong><br>三个缺点:</li>
<li>对CPU占用低,只占用了一部分进行GC, 但拖慢了用户进行的CPU量, 对吞吐量有影响.</li>
<li>并发过程中产生的浮动垃圾难以处理</li>
<li>使用“标记——清除”算法大量空间碎片的产生<br><code>-XX:+UseConcMarkSweepGC</code><br><code>-XX:ConcGCThreads=thread</code>:运用于垃圾回收的线程,一般是总线程数的1&#x2F;4<br><code>-XX:CMSInitiatingOccupancyFraction : percent</code> :触发垃圾回收阈值<br>剩下内存空间留给其他进行的进程以及浮动垃圾; 阈值过高可能导致并发失败<br><img src="/images/CMS.png"></li>
</ul>

        <h1 id="6-G1"   >
          <a href="#6-G1" class="heading-link"><i class="fas fa-link"></i></a>6. G1</h1>
      <blockquote>
<p>难点，一款很多知识点的垃圾回收器，牵涉到很多新概念</p>
</blockquote>

        <h2 id="6-1-基础概念的了解"   >
          <a href="#6-1-基础概念的了解" class="heading-link"><i class="fas fa-link"></i></a>6.1 基础概念的了解</h2>
      
        <h3 id="6-1-1-写屏障"   >
          <a href="#6-1-1-写屏障" class="heading-link"><i class="fas fa-link"></i></a>6.1.1 写屏障</h3>
      <p>可以看成是虚拟机层面对”引用类型字段赋值”这个动作的AOP切面, 在引用对象赋值的时候会形成一个环形,供程序执行额外的操作,而我们解决这种想要在编译场景中赋值的操作,就可以使用写屏障这种在机械码方面操作的手段,简单的来说,写屏障就是负责对在编译阶段中产生改变内容的处理的.</p>

        <h3 id="6-1-2-记忆集和卡表"   >
          <a href="#6-1-2-记忆集和卡表" class="heading-link"><i class="fas fa-link"></i></a>6.1.2 记忆集和卡表</h3>
      <p>这两者的出现是为了解决对象跨代引用所带来的问题的.跨代引用会导致老年代向新生代的引用难以通过只扫描新生代的对象去识别, 而如果要进行对老年代和新生代进行同时扫描的话, 那么STW的时间会变长, 性能较差.而记忆集是一种抽象的数据结构, 主要是用于记录非搜集区域指向搜集区域的指针集合的抽象数据结构.其在G1垃圾处理器中被安排在新生代中.而卡表是记忆集的一种具体实现.卡表主要运用在老年代, 当有一个老年代对象引用了新生代的时候, 卡表就会在对应的数组元素值标记为1, 表示这个元素为脏.之后通过写屏障在引用对象的行为发生时进行标记, 之后在新生代垃圾回收扫描时,这个对象就会被视为活对象了.</p>

        <h2 id="6-2-三色标记算法"   >
          <a href="#6-2-三色标记算法" class="heading-link"><i class="fas fa-link"></i></a>6.2 三色标记算法</h2>
      
        <h3 id="6-2-1-基本概念"   >
          <a href="#6-2-1-基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.2.1 基本概念</h3>
      <p>这是垃圾回收在新生代回收时根据GC Root的遍历所进行标记的一种算法.具体实现为将对象标为黑灰白三种对象, 其划分标准如下: </p>
<ul>
<li>黑: 已经被垃圾回收器访问过, 其所有引用已经全部被扫描过了, 保证其是安全存活的, 且不会再进行扫描;</li>
<li>灰: 被垃圾回收器访问过, 但是他身上的至少一个引用还没有被垃圾回收器访问, 是扫描引用他的灰色对象之后形成的;</li>
<li>白: 没有被垃圾回收器访问过, 开始的时候所有对象都是白色的, 当垃圾回收扫描完成时, 还是白色的对象说明对象是不可达的.<br>扫描完成的标志: 没有灰色对象的存在</li>
</ul>

        <h3 id="6-2-2-遍历过程"   >
          <a href="#6-2-2-遍历过程" class="heading-link"><i class="fas fa-link"></i></a>6.2.2 遍历过程</h3>
      <p>1.初始时，全部对象都是白色的<br>2.GC Roots直接引用的对象变成灰色<br>3.从灰色集合中获取元素：<br>    3.1 将本对象直接引用的对象标记为灰色<br>    3.2 将本对象标记为黑色<br>4.重复步骤3，直到灰色的对象集合变为空<br>5.结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</p>

        <h3 id="6-2-3-存在问题"   >
          <a href="#6-2-3-存在问题" class="heading-link"><i class="fas fa-link"></i></a>6.2.3 存在问题</h3>
      <p>标记算法存在的问题都是基于并发执行下产生的, 因为用户线程在进行的时候, 对象的调用总是会进行, 而同时进行对对象的操作有可能导致引用的错误.</p>
<ol>
<li>漏删<br>把原本死亡的对象标记为存活, 会发生的情况为因为A到B的引用,B被标灰了,但之后引用就断开了, 此时B没有对象引用他, 但是他的标记是灰色, 不会被回收, 这种我们把它叫做浮动垃圾. 这种解决方案十分简单, 下次扫描的时候, 因为没有对象引用他, 他就会自动被删除的.</li>
<li>多删<br>原本是黑色的对象被标记为白色.具体造成原因为如下两点:</li>
</ol>
<ul>
<li>插入了一条或者多条黑色对象对白色对象的引用</li>
<li>删除了所有灰色对象对白色对象的直接或者间接引用<br>这种问题很大, 因为本来程序运行所需要的一个对象被销毁了, 会导致程序的异常, 那么垃圾回收器给出了我们两种如下解决方案.</li>
</ul>

        <h3 id="6-2-4-解决方案"   >
          <a href="#6-2-4-解决方案" class="heading-link"><i class="fas fa-link"></i></a>6.2.4 解决方案</h3>
      <ul>
<li>增量更新(Increment update)<br>破坏的是第一个条件, 他会将这个新插入的引用记录下来, 扫描结束之后会以黑色对象为根重新进行扫描,可以理解为这个技术可以使得产生的新引用的黑色节点变灰.其主要实现为写屏障; 主要用于CMS中</li>
<li>原始快照(SnapShot At The Beginning)<br>破坏的主要是第二个条件, 他会在断开连接时将断开连接前的一瞬间记录下来, 再将他放到一个独立的内存区域中, 扫描结束后, 重新以灰色节点为根重新进行扫描.</li>
</ul>

        <h2 id="6-3-G1垃圾回收器的垃圾处理流程"   >
          <a href="#6-3-G1垃圾回收器的垃圾处理流程" class="heading-link"><i class="fas fa-link"></i></a>6.3 G1垃圾回收器的垃圾处理流程</h2>
      
        <h3 id="6-3-1-以rigion为分区的回收范围改变"   >
          <a href="#6-3-1-以rigion为分区的回收范围改变" class="heading-link"><i class="fas fa-link"></i></a>6.3.1 以rigion为分区的回收范围改变</h3>
      <p>首先我们需要知道，G1相较于CMS包括之前的垃圾回收器做出了一个巨大的改变，就是垃圾回收区域的划分，以前分代收集理论是垃圾回收器的主流理论，而G1将其做了一个更新包装，其面向堆内任何部分来组成回收集(Cset)，每一个回收集被叫做region区域，每一个区域中也可扮演为Eden，Survivor空间，每次回收的最小单元是一个region，而对于不同的region区域采取不同的策略，对于垃圾回收产生了更为优秀的结果。G1收集器会自动的去评估每个region区域的回收价值大小，根据<code>-XX:MaxGCPauseMillis</code>参数来确定回收策略，我们叫这种模式为<code>Mixed GC</code>。相比于之前，有两个优点，一个是变得更加灵活了，有回收策略了；另一个是不再需要连续了，内存空间的分配也会更加合理。<br>那么在我们了解了这种化整为零的内存空间分配策略后，我们需要知道整个G1回收器的垃圾回收流程：<br><img src="/images/G1.png"></p>

        <h3 id="6-3-2-Young-GC"   >
          <a href="#6-3-2-Young-GC" class="heading-link"><i class="fas fa-link"></i></a>6.3.2 Young GC</h3>
      <p>程序在运行的时候，随着对象不断创建，许多内存进行Eden区，当Eden区被占满时，会自动触发一次<code>Young GC</code>，此时会引起STW，此时G1涉及的对象只有Eden区和Survivor区,回收的内存进入<code>Cset</code>中进行回收;运用了复制算法,将存活单位复制到新的survivor区域.</p>
<ul>
<li>扫描根和rset, 此时会有一个小的短暂的STW;</li>
<li>运用写屏障更新rset,此时所有跨代引用对象不会被视为垃圾;</li>
<li>复制算法,实现Eden区和Survivor区的存活对象到新的Survivor区的转移</li>
<li>处理软弱虚引用.</li>
</ul>

        <h3 id="6-3-3-Young-GC-Concurrent-Marking"   >
          <a href="#6-3-3-Young-GC-Concurrent-Marking" class="heading-link"><i class="fas fa-link"></i></a>6.3.3 Young GC + Concurrent Marking</h3>
      <ul>
<li>首先进行一次young GC, 同时进行一次进行一次初始标记, 标记GC Root对象, 此时会发生STW;</li>
<li>并发标记, 沿着GC Root遍历对象, 同时将所有跨代引用的标记变脏,此时属于并发标记, 不会STW; 同时也会进行SATB, 对漏标的对象进行了处理;</li>
<li>再次标记, 处理原来SATB的对象; </li>
<li>独占清理, 对每一块内存区域进行排序, 为下阶段Mixed GC做准备;</li>
<li>清理本阶段内存.</li>
</ul>

        <h3 id="6-3-4-Mixed-GC"   >
          <a href="#6-3-4-Mixed-GC" class="heading-link"><i class="fas fa-link"></i></a>6.3.4 Mixed GC</h3>
      <p>此时会根据<code>-XX:MaxGCPauseMillis</code>实现清理策略, 在这个阶段会做三件事:</p>
<ul>
<li>新生代的垃圾回收: Eden区存活对象到survivor区; Survivor区存活对象到新的survivor区; </li>
<li>晋升: Survivor区达到晋升阈值的对象晋升到老年代</li>
<li>老年代的垃圾回收: 结合<code>-XX:MaxGCPauseMillis</code>和上一阶段的排序, 将部分老年代进行回收;<br>这个阶段也说明了Garbage First这个垃圾回收器名字的由来, 就是会在这个环节优先回收占用内存较多的区域.<blockquote>
<p><code>-XX:MaxGCPauseMillis</code>: 最大暂停时间过短, 回收速度小于产生速度, 触发单线程的Full GC; 正常情况, 回收速度大于产生速度, Concurrent mark;<br><code>-XX：G1MixedGCLiveThresholdPercent</code>: 回收阈值,默认为65%; 达到之后才会触发回收, 过小意味着存活对象多,复制时间浪费多, STW时间长．</p>
</blockquote>
</li>
</ul>

        <h2 id="6-4-新增功能"   >
          <a href="#6-4-新增功能" class="heading-link"><i class="fas fa-link"></i></a>6.4 新增功能</h2>
      
        <h3 id="6-4-1-字符串去重"   >
          <a href="#6-4-1-字符串去重" class="heading-link"><i class="fas fa-link"></i></a>6.4.1 字符串去重</h3>
      <ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加<br><code>-XX:+UseStringDeduplication</code><br>将所有新分配的字符串放入一个队列; 当新生代回收时，G1并发检查是否有字符串重复; 如果它们值一样，让它们引用同一个 char[]<blockquote>
<p>注意: 与 String.intern() 不一样; String.intern() 关注的是字符串对象; 而字符串去重关注的是 char[]; 在 JVM 内部，使用了不同的字符串表</p>
</blockquote>
</li>
</ul>

        <h3 id="6-4-2-类卸载"   >
          <a href="#6-4-2-类卸载" class="heading-link"><i class="fas fa-link"></i></a>6.4.2 类卸载</h3>
      <p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类<br>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p>

        <h3 id="6-4-3-巨型对象管理"   >
          <a href="#6-4-3-巨型对象管理" class="heading-link"><i class="fas fa-link"></i></a>6.4.3 巨型对象管理</h3>
      <p>一个对象大于 region 的一半时，称之为巨型对象<br>G1 不会对巨型对象进行拷贝<br>回收时被优先考虑<br>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</p>

        <h1 id="7-ZGC收集器"   >
          <a href="#7-ZGC收集器" class="heading-link"><i class="fas fa-link"></i></a>7. ZGC收集器</h1>
      <p>是一款低延迟垃圾收集器, 希望在对吞吐量影响不大的前提下, 把垃圾收集的停顿时间缩短在10ms以内。<br>其内存布局也是和G1一样划分为若干Region区，但其具有动态的容量大小和动态创建和销毁的特征，可以分为如下三种容量：</p>
<ul>
<li>大： 不固定可以动态变换，但是一定为2MB的整数倍，不会被重分配。</li>
<li>中： 容量固定为32MB， 用来存储256KB ~ 4MB的对象</li>
<li>小： 容量固定为2MB， 用来存储0 ~ 256KB的对象</li>
</ul>

        <h2 id="7-1-ZGC的垃圾收集流程"   >
          <a href="#7-1-ZGC的垃圾收集流程" class="heading-link"><i class="fas fa-link"></i></a>7.1 ZGC的垃圾收集流程</h2>
      
        <h3 id="7-1-1-并发标记-Concurrent-Marking"   >
          <a href="#7-1-1-并发标记-Concurrent-Marking" class="heading-link"><i class="fas fa-link"></i></a>7.1.1 并发标记(Concurrent Marking)</h3>
      <p>只会在开始标记GC Root的时候有小小的停顿，剩下的标记活动都是并发运行的。和G1需要STW进行三色算法不同，ZGC的标记位置是在指针上的，所以可以省略去遍历对象图的流程</p>

        <h3 id="7-1-2-并发预备重分配-Concurrent-Perpare-for-Relocation"   >
          <a href="#7-1-2-并发预备重分配-Concurrent-Perpare-for-Relocation" class="heading-link"><i class="fas fa-link"></i></a>7.1.2 并发预备重分配(Concurrent Perpare for Relocation)</h3>
      <p>通过并发标记得出的结论查询到底有哪些垃圾是需要回收的，然后将需要回收的Region区组成重分配集(Relocation Set)。因为ZGC不区分新生代老年代的特点，所以该阶段的扫描是针对全堆的，但同时相较于G1也省去了记忆集的维护成本。</p>
<blockquote>
<p>ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，而不是说回收的行为针对这个集合里面的region进行。</p>
</blockquote>

        <h3 id="7-1-3-并发重分配-Concurrent-Relocation"   >
          <a href="#7-1-3-并发重分配-Concurrent-Relocation" class="heading-link"><i class="fas fa-link"></i></a>7.1.3 并发重分配(Concurrent Relocation)</h3>
      <p>是ZGC垃圾回收的核心过程。他将重分配集中的存活对象转移到新的Region中，并在重分配集中建立一个转发表(Forward Table)，用来标记重分配区中旧的Region对象到新的Region对象的转发关系。当用户访问了重分配集中的对象，那么就会被预置的内存屏障所截获，根据转发表的记录转发到新的对象上，并将引用更改到新的对象上，使其指向新的对象。这种行为被称为指针的“自愈”行为。<br>一旦region的存活对象都被复制完毕，那么这个region就可以进行下一轮的内存分配。但是转发表却得等到所有重分配集中的region对象复制完毕才可删除。</p>

        <h3 id="7-1-4-并发重映射-Concurrent-Remap"   >
          <a href="#7-1-4-并发重映射-Concurrent-Remap" class="heading-link"><i class="fas fa-link"></i></a>7.1.4 并发重映射(Concurrent Remap)</h3>
      <p>重映射指的是修正整个堆中指向重分配集中的旧对象的所有引用。可以合并到下一次的并发标记的流程进行，节约一次遍历对象图的操作。</p>

        <h2 id="7-2-ZGC解决并发算法问题的关键——染色指针"   >
          <a href="#7-2-ZGC解决并发算法问题的关键——染色指针" class="heading-link"><i class="fas fa-link"></i></a>7.2 ZGC解决并发算法问题的关键——染色指针</h2>
      <p>将少量标识信息存储在指针上，实现可达性分析，相较于G1的遍历对象图节约了许多时间的成本。<br>三个优点：</p>
<ol>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用。指针的自愈行为使得它拥有即时性，而复制算法则是需要STW进行1：1的复制后才能够实现重用。</li>
<li>染色指针可以大幅度减少在垃圾收集过程中内存屏障的使用数量，内存屏障的功能之一就是记录对象引用的变动情况，而染色指针可以接替这一工作。</li>
<li>可以作为一种可拓展的存储结构用来记录，重定位过程的相关数据，日后可以进一步提升性能。日后标志位可用的提升可以使得其更有扩展性。</li>
</ol>
<p><a href="/images/GCAll.png"></a></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/18463/">C++指针和结构体的浅显认知</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-25</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>因为数据结构中会设计到C++的一些基本指针操作，在进行算法的时候或多或少链表，哈希表，二叉树也会涉及一些相应的指针操作，而本人对于C++这么博大精深的语言体系又只有浅浅的一些了解，所以将这些数据结构涉及到的底层的指针做一个简单的知识梳理，方便以后在理解算法的时候尽量少花点笔墨放在基础语法知识上。</p>
<hr>

        <h1 id="1-指针"   >
          <a href="#1-指针" class="heading-link"><i class="fas fa-link"></i></a>1. 指针</h1>
      
        <h2 id="1-1-指针的意义"   >
          <a href="#1-1-指针的意义" class="heading-link"><i class="fas fa-link"></i></a>1.1 指针的意义</h2>
      <p>对于C++程序的一个数据，我们一般需要做到关注他如下的三个部分：</p>
<ul>
<li><code>data</code> : 数据的内容</li>
<li><code>address</code> : 数据的地址（存储位置）</li>
<li><code>dtype</code> : 数据的类型</li>
</ul>
<p>那么平时我们在定义一个变量的时候，一般只会定义他的数据类型和数据的内容(<code>int a = 5</code>)，那么他的地址又指的是什么呢？</p>
<p>我们可以这样去理解：<mark>代码中出现的变量存放在主机里存储器中的一个个存储单元中，每一个存储单元都有一个地址。</mark>换而言之，我们作为程序员更多的会去关注字面值的内容，而地址更像是计算机底层程序自己考虑的。当我们定义完一个变量要去调用他的时候，我们需要进行的操作仅仅是运用运算符<code>=</code>, 而计算机底层则需要对应的去寻找这个变量的地址，再将其调用出来。指针像是一种<strong>工具</strong>，模拟了这种过程，我们可以通过指针<u><strong>直接知道其指向的地址</strong></u>，也可以<u><strong>获取他指向的值</strong></u>。</p>
<p>用听起来厉害一点的话来讲就是：**<font color=red>指针可以精准控制了内存中的地址，从而高效率的传递和更改数据。</font>**</p>

        <h2 id="1-2-指针和引用"   >
          <a href="#1-2-指针和引用" class="heading-link"><i class="fas fa-link"></i></a>1.2 指针和引用</h2>
      <ul>
<li><p>&amp; ： 取地址运算符<br>针对于变量，<code>&amp; + 变量名称</code>表示的是该变量在内存中的地址。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code></p>
</li>
<li><p>*： 间接运算符</p>
</li>
</ul>
<p>针对的是指针，<code>* + 指针名称</code>表示引用该指针指向的值。<br><code>*p</code>表示取p指针指向地址的值<br><code>int* p</code>表示p的数据类型是<mark>指向int类型的指针</mark></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>* p = &amp;a; <span class="comment">//表示p是指向int类型的a变量的地址的指针</span></span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code>; <code>10</code></p>
<p><font size=2>某种意义上，int*  p &#x3D;int * p ; 但是他们表示的含义完全不同。左值定义了一个指针，右值定义了一个变量。但是他们最终的结果是相等的。但是要注意的是，在程序编译器中，int* p1, p2指的是定义一个p1为指向int类型的指针，p2为int类型的变量。</font></p>
<hr>

        <h1 id="2-结构体"   >
          <a href="#2-结构体" class="heading-link"><i class="fas fa-link"></i></a>2. 结构体</h1>
      
        <h2 id="2-1-结构体的定义"   >
          <a href="#2-1-结构体的定义" class="heading-link"><i class="fas fa-link"></i></a>2.1 结构体的定义</h2>
      <p>类似于类，可以表示一个需要用各种数据类型表示的数据集体，如学生有他的姓名年龄，那么此时就需要进行结构体的定义，将学生封装为<code>char</code>类型的姓名和包括<code>int</code>类型的年龄。<br><br>具体在C++中表达如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>他在数据结构中用处十分之大，比如链表中需要定义<code>data</code>和<code>next</code>，又比如在二叉树中需要定义双亲和头节点等。都需要用到结构体。</p>

        <h2 id="2-2-结构体的初始化"   >
          <a href="#2-2-结构体的初始化" class="heading-link"><i class="fas fa-link"></i></a>2.2 结构体的初始化</h2>
      <p>结构体的初始化有如下两种方式：</p>
<ul>
<li>通过直接定义初始化<br><code>struct Student s1;</code>：表示构造出一个数据类型为<code>Student</code>的学生变量<code>s1</code>。<br>注意：此类型构造需要确定结构体定义的位置，如果在同一个方法内可以调用，在不同方法内不能调用。如果结构体被设置为全局则每个方法都可以引用。</li>
<li>在构造时完成初始化<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,s1,s2</span><br></pre></td></tr></table></div></figure>
这样就表示<code>s1,s2</code>两个变量是<code>Student</code>类型，并且再后续无需再定义就可以直接使用，在构造的时候就完成了初始化。</li>
</ul>

        <h2 id="2-3-typedef关键字"   >
          <a href="#2-3-typedef关键字" class="heading-link"><i class="fas fa-link"></i></a>2.3 typedef关键字</h2>
      <p><code>typedef</code>关键字可以简化结构体变量的初始化，通过该关键字可以给结构体起别名，从而直接实现通过别名来进行调用。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,S,s1</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>其中，S为结构体的别名，s1为结构体类型的变量。</p>
</blockquote>

        <h2 id="2-4-结构体成员变量的调用"   >
          <a href="#2-4-结构体成员变量的调用" class="heading-link"><i class="fas fa-link"></i></a>2.4 结构体成员变量的调用</h2>
      <p>通过<code>.</code>的形式调用。<br>如<code>s1.age</code>表示第一名学生的年龄；<code>s2.name</code>表示第二名学生的姓名。</p>
<hr>

        <h1 id="3-指向结构体的指针"   >
          <a href="#3-指向结构体的指针" class="heading-link"><i class="fas fa-link"></i></a>3. 指向结构体的指针</h1>
      <p>此时结构体可以视为数据类型，所以指针定义写法和原先指针写法差别不大。<br><code>struct Student* p= &amp;s1</code></p>
<blockquote>
<p>指向结构体Student的指针p(左值)，指向(&#x3D;)数据类型为Student的s1的地址(右值)。</p>
</blockquote>
<ul>
<li><font size=4 color=red><b>指针访问结构体成员变量</b></font><br>用箭头函数：<br><code>p-&gt;name</code><blockquote>
<p>无需带变量名，因为p指向了地址，知道需要获取哪个变量的值</p>
</blockquote>
</li>
</ul>
<hr>
<p>本篇只针对于目前个人认为可能会在数据结构中用到的知识点，对于真正的指针和结构体的知识知识九牛一毛不尽完整，而对于有关于理解数据结构语法有帮助的知识点，如有遗漏或者后续想到的，接下来再来进行补充。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/11079/">2.LinkList</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-05</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-链表的基础定义"   >
          <a href="#1-链表的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 链表的基础定义</h1>
      
        <h2 id="1-1-主要组成"   >
          <a href="#1-1-主要组成" class="heading-link"><i class="fas fa-link"></i></a>1.1 主要组成</h2>
      <ul>
<li><code>data</code>域： 用于存储每一个节点的<strong>数据</strong></li>
<li><code>next</code>域： 用于存储指向下一个节点的<strong>指针</strong></li>
</ul>

        <h2 id="1-2-特点"   >
          <a href="#1-2-特点" class="heading-link"><i class="fas fa-link"></i></a>1.2 特点</h2>
      <ul>
<li>最后指向null，意味着链表的结束。</li>
<li>可以无限扩容，通过指针指向其他元素可以实现空间的扩大。</li>
<li><mark>存储结构特点</mark>：链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</li>
<li>相较于数组而言，插入，删除方便，查找不方便（需要一个一个去找）</li>
</ul>

        <h2 id="1-3-图表写法"   >
          <a href="#1-3-图表写法" class="heading-link"><i class="fas fa-link"></i></a>1.3 图表写法</h2>
      <p><img src="/images/LinkListStructure.png"></p>

        <h2 id="1-4-相关类型"   >
          <a href="#1-4-相关类型" class="heading-link"><i class="fas fa-link"></i></a>1.4 相关类型</h2>
      <p>近似的我们可以分为如下几种类型：</p>
<ul>
<li><font size=4><b>单链表</b></font><br>如上图，是一般的数据模型形式。<br><br></li>
<li><font size=4><b>双链表</b></font><br>在单链表的基础上增加了一个<code>next</code>域，即一个节点有两个<code>next</code>域，一个指向前面的节点，一个指向后面的节点。这样能够一定程度上提高查找的效率。<br><img src="/images/doubleLinkList.png"><br></li>
<li><font size=4><b>循环链表</b></font><br>即最后的<code>next</code>指向的是<code>head</code>，实现了链表的循环。可以解决约瑟夫环问题。<br><img src="/images/circleLinkList.png"></li>
</ul>

        <h2 id="1-5-数据结构相关操作"   >
          <a href="#1-5-数据结构相关操作" class="heading-link"><i class="fas fa-link"></i></a>1.5 数据结构相关操作</h2>
      <p>下面是链表有关的数据结构操作：</p>
<ul>
<li><font size=4><b>初始化链表结构</b></font><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct LinkNode&#123;</span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 定义data域内容</span></span><br><span class="line">    ListNode *next; <span class="comment">//指向ListNode类型元素的指针</span></span><br><span class="line">    <span class="comment">// 构造函数的初始化</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="built_in">data</span>(x);</span><br><span class="line">        <span class="built_in">next</span>(null)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br></li>
<li><font size=4><b>初始化节点</b></font><br><code>ListNode* head = new ListNode(5);</code><br><br><br></li>
<li><font size=4><b>删除节点</b></font></li>
</ul>
<p>链表节点删除的主要思想有两个，第一个是<strong>寻找到要删除的位置</strong>，这个很简单实现，比对要删除的元素和指针指向的元素是否相等，如果不相等就<code>p = p-&gt;next</code>，移动到下个节点即可，难点是理解确定寻址指针指向的位置和删除元素的位置关系。而<mark>寻址指针指向的位置是删除元素的前一格</mark>，这个和后面具体删除的思想有关。</p>
<p>第二个是<strong>删除的过程操作</strong>，其中细化出来有两步，第一步是指向要删除的节点，之后直接<code>delete</code>带走即可，第二步是将原来指向删除节点的<code>next</code>域指针指向删除节点的下一个。综合这两个我们可以发现在删除节点前一个节点要做的事情是可以和其他联系起来的，他的<code>next</code>指向的就是删除的，而他的<code>next</code>我们后续也要进行操作。所以这就回应了第一个寻址思想的难点。<br><br><br><img src="/images/LinkListDel.png"><br><strong>实现代码如下：</strong></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteElem</span><span class="params">(link L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link p=L,q;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p||!p-&gt;next)</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;输出位置不合法&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br>
- <font size=4><b>增加节点</b></font>

<p>很简单也是两步操作，<strong>第一步是定位</strong>，定位和操作和删除的差不多；<strong>第二步是增加</strong>，那么应该怎么增加呢？我们需要新引入一个指针来进行节点赋值和节点位置的操作，<u>节点赋值</u>很简单，就是<code>s-&gt;data = elem</code>，<u>节点的位置</u>也不难，因为插入元素，即要插入位置的原来节点得给你让出来，你要干他的事情，你的<code>next</code>就要指向原来节点的<code>next</code>即，<code>s-&gt;next = p-&gt;next</code>，那么你要成为他的一部分得连起来，那么原来的<code>next</code>就要指向你的元素，即<code>p-&gt;next = s</code>。<mark>注意这两步的顺序不可以搞反</mark>。<br><br><br><img src="/images/addElem.png"><br><br><br>代码如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddElem</span><span class="params">(link &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link p = L, s;</span><br><span class="line"> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> p = p-&gt;next;</span><br><span class="line"> j++;</span><br><span class="line"> &#125; <span class="comment">//搜索插入的位置</span></span><br><span class="line"> <span class="keyword">if</span>(!p)</span><br><span class="line">	 &#123;cout&lt;&lt;<span class="string">&quot;增加位置不合法&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> s = <span class="keyword">new</span> Node; <span class="comment">//为新节点创建位置</span></span><br><span class="line"> s-&gt;Data = e; <span class="comment">//赋值</span></span><br><span class="line"> s-&gt;next = p-&gt;next;</span><br><span class="line"> p-&gt;next = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><font size=4><b>寻找data所对应的节点</b></font><br>删除增加的基础，不再赘述。</li>
</ul>
<hr>

        <h1 id="2-链表设计"   >
          <a href="#2-链表设计" class="heading-link"><i class="fas fa-link"></i></a>2. 链表设计</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/" >Problem 203. 移除链表元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/" >Problem 707. 设计链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>很好的数据结构方式，也是数据结构这门课中第一次学到的关于指针类型的数据结构，有一定的难度，又是我们的启蒙，是一门十分值得敬畏的章节。加油吧。不管前路怎么艰辛，这总是你的第一站，第一站总是会变的比较有难度一些的，那么你就一定要坚持下去，同时照顾好自己的身体，资本要有，但挥霍资本的资本也要有。</p>
</blockquote>

        <h2 id="2-1-复杂度"   >
          <a href="#2-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.1 复杂度</h2>
      <p>大部分是<code>O(n)</code></p>

        <h2 id="2-2-主要思想"   >
          <a href="#2-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.2 主要思想</h2>
      <p>这里学到了一个比较重要的东西叫做虚拟头节点，他存在的意义是为了让处理头结点的时候和处理其他节点一样的自然。因为链表这种数据结构本身具有一定的局限性，其头节点无法用next指向，所以设置一个虚拟头节点，可以让头节点获得和其他节点一样的待遇。</p>

        <h2 id="2-3-注意点"   >
          <a href="#2-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.3 注意点</h2>
      <ul>
<li>注意什么时候需要定位到要操作节点的前一个节点，什么时候要确定的定位到那个要操作的节点。要操作节点的前一个节点主要用于添加和删除这两个操作，因为他们都需要用到前一个节点的next指针，来指向下一个节点方能对他们进行操作。而确定的定位到要操作的节点则是根据index取值的操作。</li>
<li>需要警惕提防节点们，因为节点们在你每次更改next域之后，他们之间的关系就进行了一次大洗牌，所以在新增和删除节点的时候一定要按步骤操作好。</li>
<li>有索引就有越界问题，一定看看要搜索定位的索引是否越界或者不存在。</li>
<li>用好<code>while(index--)</code>的写法，他其实和<code>for(int i = 0; i++; i &lt; index)</code>是一样的，但是他的优点就是能加上一些<code>&amp;&amp;</code>，从而可以做出一些防止越界的举动。</li>
<li>记得在操作的时候时刻不要拿着最原始的head变量去操作，因为要返回head的时候能够帮你直接定位，而用一些替代值去进行操作就好了。</li>
</ul>

        <h2 id="2-4-代码实现"   >
          <a href="#2-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>2.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode* next;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">//长度</span></span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(<span class="number">0</span>); <span class="comment">//虚拟头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有下标需要考虑越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(index --) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        cur -&gt; next = dummyHead -&gt; next;</span><br><span class="line">        dummyHead -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        <span class="comment">//把尾节点给找出来</span></span><br><span class="line">        <span class="keyword">while</span>(p -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小于零则在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界则无效</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//虚拟头节点的建立</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">		<span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">    			ListNode* tmp = cur-&gt;next;</span><br><span class="line">        		cur-&gt;next = cur -&gt;next-&gt;next;</span><br><span class="line">        		<span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">        		cur = cur -&gt; next;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		head = dummyHead-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> dummyHead;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        LinkNode* dummyHead;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="3-链表翻转"   >
          <a href="#3-链表翻转" class="heading-link"><i class="fas fa-link"></i></a>3. 链表翻转</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 206 链表翻转</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p>只要实现链表的转向即可，那么就需要有一前一后两个节点，来实现转向的操作，于是链表的转向就可以实现了。 其实这里又是双指针的另一个应用场景，双指针只要涉及到需要对两个东西同时进行操作，他都能够派上用场。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>我感觉这道题没有什么要注意的东西，就算要有吧，也就是要注意转移到下一个节点进行翻转的时候，定位要不能定next了，因为操作过后已经转移了，所以要在翻转前就给<code>cur-&gt;next</code>给标记上temp。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//临时节点，用来存储要操作的下一个节点的</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>; <span class="comment">//指向头节点的前一个节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">//指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next; <span class="comment">//标记</span></span><br><span class="line">            cur-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = cur; <span class="comment">//下一组</span></span><br><span class="line">            cur = temp; <span class="comment">//下一组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="4-两两交换链表中的节点"   >
          <a href="#4-两两交换链表中的节点" class="heading-link"><i class="fas fa-link"></i></a>4. 两两交换链表中的节点</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 24 两两交换链表中的节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="4-1-复杂度"   >
          <a href="#4-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="4-2-主要思想"   >
          <a href="#4-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.2 主要思想</h2>
      <p>要关注好移动的顺序，这道题是很好的让人们能够关注流程顺序的一道题目。<br><img src="/images/LinkListturn.png"></p>

        <h2 id="4-3-注意点"   >
          <a href="#4-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.3 注意点</h2>
      <p>关注好移动的顺序</p>

        <h2 id="4-4-代码实现"   >
          <a href="#4-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode* cur = p;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* temp = cur-&gt;next; <span class="comment">//临时节点1</span></span><br><span class="line">        ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//临时节点2</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//第一步操作，头节点-&gt;第二个</span></span><br><span class="line">        cur-&gt;next-&gt;next = temp; <span class="comment">//第二步操作，第二个-&gt;第一个</span></span><br><span class="line">        cur-&gt;next-&gt;next-&gt;next = temp1; <span class="comment">//第三步操作，第一个-&gt;第三个</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="5-删除列表的倒数第n个节点"   >
          <a href="#5-删除列表的倒数第n个节点" class="heading-link"><i class="fas fa-link"></i></a>5. 删除列表的倒数第n个节点</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" >Problem 19. 删除列表的倒数第n个节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-复杂度"   >
          <a href="#5-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="5-2-主要思想"   >
          <a href="#5-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.2 主要思想</h2>
      <p>还是双指针，删除这种东西好像最好双指针了，一个用来指代他的条件，另一个指针来指向要删除的值，具体而言在这道题上就是慢指针是用来指代值的，快指针的条件判断在于，倒数第几个就移动几次，终止条件本来从虚拟头节点出发到nullptr就遍历完了，那么我们删除倒数第几个就派出另一个往前先走几步就行了，那么先出发的那个到达nullptr的时候就是真正删除的那一个到达要删除的时候。 </p>

        <h2 id="5-3-注意点"   >
          <a href="#5-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.3 注意点</h2>
      <p>就是我们的前进的时候用while循环，其实<code>for(int i=0; i++; i&lt;n)</code>和<code>while(n--)</code>是等价的，但是要考虑他是否越界，所以要添加上<code>fast != null</code>就用while好像更好一点了。</p>

        <h2 id="5-4-代码实现"   >
          <a href="#5-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyList = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyList-&gt;next = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummyList;</span><br><span class="line">		<span class="comment">//很好的判断条件，防止倒数第n个本来就是不存在的情况</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 一起前进</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> dummyList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="6-链表相交"   >
          <a href="#6-链表相交" class="heading-link"><i class="fas fa-link"></i></a>6. 链表相交</h1>
      
        <h2 id="相关题目-4"   >
          <a href="#相关题目-4" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" >Problem 链表相交</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="6-1-复杂度"   >
          <a href="#6-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>6.1 复杂度</h2>
      <p>时间复杂度：<code>O(n + m)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="6-2-主要思想"   >
          <a href="#6-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>6.2 主要思想</h2>
      <p>这道题告诉你之后难度不大，就是看看两个链表的部分是否相等就行了，怎么看呢，一个个移动，直到空为止，很容易知道应该是以最短的那个链表作为基准，因为最短的链表遍历完之后所有有可能的结果也就尘埃落定了。所以我们要做的第一步就是比对两个数组找出长度差值，之后才能够精准的进行定位。</p>

        <h2 id="6-3-注意点"   >
          <a href="#6-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>6.3 注意点</h2>
      <p>计算完长度之后，临时指针要重定向归于原来的头节点，不然他们计算完长度之后的状态是指向nullptr的</p>

        <h2 id="6-4-代码实现"   >
          <a href="#6-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>6.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = headA;</span><br><span class="line">        ListNode* cur2 = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//计算长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span>(cur1, cur2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">			<span class="comment">//移动到同一起跑线</span></span><br><span class="line">        <span class="keyword">while</span>(gap--)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="7-环形链表"   >
          <a href="#7-环形链表" class="heading-link"><i class="fas fa-link"></i></a>7. 环形链表</h1>
      
        <h2 id="相关题目-5"   >
          <a href="#相关题目-5" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/" >Problem 142. 环形链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="7-1-复杂度"   >
          <a href="#7-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>7.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="7-2-主要思想"   >
          <a href="#7-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>7.2 主要思想</h2>
      <p>这道题由两个部分组成，第一个部分是有没有环，第二个部分是环的入口到底在哪？ 首先有没有环的判断就是依据两个指针一快一慢的走，如果相遇了就能证明有环，但是这是一个必要证明，还得加上一个条件就是快指针走两步慢指针走一步，本质上就是一个追赶问题，<strong>快指针每次相对于慢指针多走了一步，那么就是链表中每一个格子都有能够遇上的机会。</strong>所以此时遇上和有环形成了一个充分必要的对应证明条件。 那么入口在哪呢，假设入口离起始点的距离为x，第一次相遇两指针在距离入口y处，环的长度为y+z，那么我们可以推断出，慢指针走了x+y距离，快指针走了x+n(y+z)。那么他们相遇的话，即x+y &#x3D; x+n(y+z)，我们要探究x是多少，即可以把等式变化为：x &#x3D; (n-1)(y+z)+z，那么因为 y+z表示一直在绕圈可以忽略掉 ，所以我们可以得出一个结论叫做，起点到入环点的位置和相遇点到入环点的位置是相等的。</p>
<blockquote>
<p>这里x一定没有绕环的论证在慢指针走一圈的时间快指针能走两圈，而快指针相对于慢指针每次走一步，也就是说快指针速度为2v，慢指针速度为v，快指针追上慢指针需要走的路程为y+z-a(不足一圈)，追上的时间为(y+z-a)&#x2F;(2v-v),慢指针走一圈的时间为(y+z)&#x2F;v，追上的时间小于慢指针走一圈的时间，所以一定能够追得上。</p>
</blockquote>

        <h2 id="7-4-代码实现"   >
          <a href="#7-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>7.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/32766/">数组</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-24</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-数组的基础定义"   >
          <a href="#1-数组的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 数组的基础定义</h1>
      <ul>
<li>数组的下标是从0开始的</li>
<li>数组中的地址是连续的</li>
</ul>
<p>要删除数组中的元素只能用替换去实现，无法直接删去</p>
<hr>

        <h1 id="2-二分法"   >
          <a href="#2-二分法" class="heading-link"><i class="fas fa-link"></i></a>2. 二分法</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/" >Problem 704. 二分查找</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>类似参考题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/" >Problem 35.搜索插入位置 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" >Problem 34.在排序数组中查找元素的第一个和最后一个位置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="2-1-使用条件"   >
          <a href="#2-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>2.1 使用条件</h2>
      <p>在求解寻找数组中的元素，或者满足条件的值会出现在数组的范围内（如求平方根）等内容时可使用；</p>
<p>使用时数组需满足如下条件（或变化后）：</p>
<ul>
<li>数组升序或者降序排列，即有序数组</li>
<li>数组中无重复项的出现</li>
</ul>

        <h2 id="2-2-时间复杂度"   >
          <a href="#2-2-时间复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.2 时间复杂度</h2>
      <ul>
<li>暴力解法时间复杂度：<code>O(n)</code></li>
<li>二分法时间复杂度：<code>O(logn)</code></li>
</ul>

        <h2 id="2-3-主要思想"   >
          <a href="#2-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.3 主要思想</h2>
      <p>通过在有序数组中<strong>划分中间值</strong>，判断所求值与中间值之间的关系，较暴力解法可以<strong>直接排除掉</strong>一些不在范围之内的比较，提升了运行效率。</p>
<p><mark>有序数组：索引定位数据，索引的大小关系即为数组元素的大小关系。</mark></p>
<p>要定义的几个参数：</p>
<p>开始位置：<code>left = 0;</code>（数组下标索引从0开始）</p>
<p>结束位置：<code>right = nums.size() - 1;</code> </p>
<p>中间值：<code>mid = left + ((right - left) &gt;&gt; 1) </code> (位运算，可以防止数组越界现象出现)</p>

        <h2 id="2-4-注意点"   >
          <a href="#2-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.4 注意点</h2>
      <ul>
<li>区间的划分</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原因是此时mid的值一定不是我们寻找的，否则不会出现在这个循环，那么我们在移动的时候也可以不考虑这个值</span></span><br><span class="line"><span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>循环终止判断条件</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="2-5-完整代码"   >
          <a href="#2-5-完整代码" class="heading-link"><i class="fas fa-link"></i></a>2.5 完整代码</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//定义数组的左节点</span></span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//定义数组的右节点</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//定义中间点，防止索引越界</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target == nums[mid]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h1 id="3-双指针法"   >
          <a href="#3-双指针法" class="heading-link"><i class="fas fa-link"></i></a>3. 双指针法</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/" >Problem 27.移除元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/" >Problem 977.有序数组的平方</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-1-使用条件"   >
          <a href="#3-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>3.1 使用条件</h2>
      <p>需要双重遍历：需要实现先定位元素，再实现元素修改的题目，都可以用双指针法。</p>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针<mark>在一个for循环下完成两个for循环</mark>的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向<mark>更新</mark>新数组下标的位置</li>
</ul>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p><code>fastIndex</code>指针用来寻找要<strong>删除</strong>的值，<code>slowIndex</code>指针用来定位要<strong>修改</strong>的值</p>
<p>在删除元素这道题目中，体现在<code>fastIndex</code>在一直在移动，而通过判断<code>if(nums[fastIndex] != val) </code>来控制是否替换，相当于核心思想是在<mark>原有的数组上替换了一个新的数组，这个数组元素所要满足的条件就是if判断的条件</mark>。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>用双指针移动删除元素可以使得时间复杂度下降，只需要一个循环遍历即可，一个指针用来寻找删除元素，另一个指针用来实现替换操作。 这里用for循环，不用while循环的原因是： for循环一般用于有终止条件，变量只有一个并且判断条件可以简单的用一个boolean表达式表现出来，而while循环主要用于迭代条件较为复杂，例如二分查找法的情况，左右节点都需要根据不同情况进行更新。 而在双指针中，fastIndex指针是无条件一直向前运行的，我们只需在循环体中控制slowIndex指针即可。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针删除元素 fast指针用于搜索，slow指针用于替换值</span></span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束条件，搜索指针搜索完成。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex ++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p><font size=4><strong>双指针Pro（相向双指针）：</strong></font></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">            <span class="comment">// 找左边等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边不等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">                rightIndex-- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line">            <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">                nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;   <span class="comment">// leftIndex一定指向了最终数组末尾的下一个元素，原因是因为有几个val就代表被中断了几次，此时只有单向运动，长度就会缩减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="4-滑动窗口"   >
          <a href="#4-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4. 滑动窗口</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" >Problem 209.长度最小的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>

        <h2 id="4-1-使用条件"   >
          <a href="#4-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>4.1 使用条件</h2>
      <p>数组中满足条件的最小子数组。一般求解需要经过两个步骤，首先需要先判断出有哪些满足条件的情况<strong>存在</strong>。之后再去这些满足条件存在中求解<strong>最优</strong>。</p>
<p>一般会出现如下条件需要去定义：</p>
<ul>
<li>滑动窗口的起始点（可以理解为快指针）</li>
<li>滑动窗口的终止点（可以理解为慢指针）</li>
<li>滑动窗口内条件的表示：例如最大值，元素相等之类的</li>
</ul>

        <h2 id="4-2-复杂度"   >
          <a href="#4-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
</ul>
<blockquote>
<p>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
</blockquote>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="4-3-主要思想"   >
          <a href="#4-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.3 主要思想</h2>
      <p>时间复杂度的优化其实可以简略的看成循环的优化，而循环优化的最主要思想之一就是<mark>能否对相关项进行合并</mark>。换而言之就是变量之间能不能够相互解释。</p>
<p>对比暴力解法和滑动窗口能够发现其精妙之处：</p>
<ul>
<li>暴力解法：判断满足条件的子数组存在（一层遍历） &#x3D;&#x3D;&#x3D;&gt; 子数组内判断是否最优（存在遍历中的遍历）&#x3D;&#x3D;&#x3D;&gt; 比较</li>
<li>滑动窗口：移动终止点去判断是否存在 &#x3D;&#x3D;&#x3D;&gt; 移动起始点去求最优</li>
</ul>
<p>这时候我们会发现，其实滑动窗口用了条件这个东西同时判断了两个值， 而暴力解法则是在数组内部又进行了一个数组的判断，所以我们其实可以用两个点窗口大小去表示条件的时候，这样做就相当于实现了循环次数的减少。</p>

        <h2 id="4-4-注意点"   >
          <a href="#4-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.4 注意点</h2>
      <ol>
<li><p>求和的操作很巧妙，融合在一起表现在头指针移动会影响到数组和值，尾指针移动也能够影响到数组的和值。</p>
</li>
<li><p>数组最小长度的迭代更新，首先直接替换肯定不行，因为无法确定最后一个就是最小的。然后自己比自己求最小也不行，因为你需要一个0的初始值。所以在这里需要引入一个新的变量，result &#x3D; INT32_MAX。</p>
</li>
</ol>
<blockquote>
<p>INT32_MAX是一个常量，表示极大值，主要作用是有值时第一次比较时一定会被替换成result, 如果没有被比较到，那么最后返回结果用三元运算符返回0即可。</p>
</blockquote>

        <h2 id="4-5-代码实现"   >
          <a href="#4-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为其要变化两个量：最小数组的开始值，数组的长度，所以可能需要两次for循环来找到答案</span></span><br><span class="line">        <span class="comment">//滑动窗口法:将结果看成是变化，找到大于target的数组，之后不断缩小，贪心算法？</span></span><br><span class="line">        <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="comment">//小于等于是考虑末值的条件</span></span><br><span class="line">        <span class="keyword">for</span>(;fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="comment">//求和放在和</span></span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                length = (fastIndex - slowIndex + <span class="number">1</span>) ;</span><br><span class="line">                result = result &gt; length ? length : result;</span><br><span class="line">                sum -= nums[slowIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="5-螺旋矩阵"   >
          <a href="#5-螺旋矩阵" class="heading-link"><i class="fas fa-link"></i></a>5. 螺旋矩阵</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/" >Problem 59.螺旋矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-使用条件"   >
          <a href="#5-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>5.1 使用条件</h2>
      <p>题目告诉你要用螺旋矩阵，没有什么特别算法的意思，更多的是体现了一种对语言的运用和流程的表述</p>

        <h2 id="5-2-复杂度"   >
          <a href="#5-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.2 复杂度</h2>
      
        <h2 id="5-3-主要思想"   >
          <a href="#5-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.3 主要思想</h2>
      <p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>

        <h2 id="5-4-注意点"   >
          <a href="#5-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.4 注意点</h2>
      <p>开闭区间的判断</p>

        <h2 id="5-5-代码实现"   >
          <a href="#5-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.5 代码实现</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/42640/">JVM概述</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-25</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="一-Java语言及JVM的概述"   >
          <a href="#一-Java语言及JVM的概述" class="heading-link"><i class="fas fa-link"></i></a>一.Java语言及JVM的概述</h1>
      
        <h2 id="1-Java的优点"   >
          <a href="#1-Java的优点" class="heading-link"><i class="fas fa-link"></i></a>1. Java的优点</h2>
      <ul>
<li>一次编译，到处运行。</li>
<li>内存管理访问机制相对安全，尽可能避免内存泄漏和数组指针越界等问题。</li>
<li>热点代码检测，编译优化<blockquote>
<p>编译优化：<code>String c = &quot;a&quot; + &quot;b&quot;; </code> &#x3D;&#x3D;&gt;<code>String c = &quot;ab&quot;;</code></p>
</blockquote>
</li>
<li>第三方类库丰富，开源功能强大</li>
<li>多态</li>
</ul>

        <h2 id="2-JVM"   >
          <a href="#2-JVM" class="heading-link"><i class="fas fa-link"></i></a>2.JVM</h2>
      <p>​		jvm ( Java visual machine )，java虚拟机， 具有控制java内存的能力，可以让程序员在编写程序时享受自动内存管理的诸多优势，但是也需要警惕因为各种原因出现的内存泄露和溢出的问题。</p>
<p> 下图为Java技术体系的三个概念的关系：</p>
<p><img src="/images/JVM.png" alt="image-20221118174353103"></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/myphoto.png" alt="avatar"></div><p class="sidebar-ov-author__text">道阻且长,行则将至</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">12</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">5</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>Arong</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 強力驅動</span><span> v6.3.0</span><span class="footer__devider">|</span><span>主題 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.1.1</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>