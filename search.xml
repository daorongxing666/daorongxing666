<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/post/16107/</url>
    <content><![CDATA[<p>Welcome to <span class="exturl"><a class="exturl__link"   href="https://hexo.io/" >Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/" >documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   href="https://github.com/hexojs/hexo/issues" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/writing.html" >Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server"   >
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/server.html" >Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files"   >
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/generating.html" >Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites"   >
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
]]></content>
  </entry>
  <entry>
    <title>C++指针和结构体的浅显认知</title>
    <url>/post/18463/</url>
    <content><![CDATA[<p>因为数据结构中会设计到C++的一些基本指针操作，在进行算法的时候或多或少链表，哈希表，二叉树也会涉及一些相应的指针操作，而本人对于C++这么博大精深的语言体系又只有浅浅的一些了解，所以将这些数据结构涉及到的底层的指针做一个简单的知识梳理，方便以后在理解算法的时候尽量少花点笔墨放在基础语法知识上。</p>
<hr>

        <h1 id="1-指针"   >
          <a href="#1-指针" class="heading-link"><i class="fas fa-link"></i></a>1. 指针</h1>
      
        <h2 id="1-1-指针的意义"   >
          <a href="#1-1-指针的意义" class="heading-link"><i class="fas fa-link"></i></a>1.1 指针的意义</h2>
      <p>对于C++程序的一个数据，我们一般需要做到关注他如下的三个部分：</p>
<ul>
<li><code>data</code> : 数据的内容</li>
<li><code>address</code> : 数据的地址（存储位置）</li>
<li><code>dtype</code> : 数据的类型</li>
</ul>
<p>那么平时我们在定义一个变量的时候，一般只会定义他的数据类型和数据的内容(<code>int a = 5</code>)，那么他的地址又指的是什么呢？</p>
<p>我们可以这样去理解：<mark>代码中出现的变量存放在主机里存储器中的一个个存储单元中，每一个存储单元都有一个地址。</mark>换而言之，我们作为程序员更多的会去关注字面值的内容，而地址更像是计算机底层程序自己考虑的。当我们定义完一个变量要去调用他的时候，我们需要进行的操作仅仅是运用运算符<code>=</code>, 而计算机底层则需要对应的去寻找这个变量的地址，再将其调用出来。指针像是一种<strong>工具</strong>，模拟了这种过程，我们可以通过指针<u><strong>直接知道其指向的地址</strong></u>，也可以<u><strong>获取他指向的值</strong></u>。</p>
<p>用听起来厉害一点的话来讲就是：**<font color=red>指针可以精准控制了内存中的地址，从而高效率的传递和更改数据。</font>**</p>

        <h2 id="1-2-指针和引用"   >
          <a href="#1-2-指针和引用" class="heading-link"><i class="fas fa-link"></i></a>1.2 指针和引用</h2>
      <ul>
<li><p>&amp; ： 取地址运算符<br>针对于变量，<code>&amp; + 变量名称</code>表示的是该变量在内存中的地址。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code></p>
</li>
<li><p>*： 间接运算符</p>
</li>
</ul>
<p>针对的是指针，<code>* + 指针名称</code>表示引用该指针指向的值。<br><code>*p</code>表示取p指针指向地址的值<br><code>int* p</code>表示p的数据类型是<mark>指向int类型的指针</mark></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>* p = &amp;a; <span class="comment">//表示p是指向int类型的a变量的地址的指针</span></span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code>; <code>10</code></p>
<p><font size=2>某种意义上，int*  p &#x3D;int * p ; 但是他们表示的含义完全不同。左值定义了一个指针，右值定义了一个变量。但是他们最终的结果是相等的。但是要注意的是，在程序编译器中，int* p1, p2指的是定义一个p1为指向int类型的指针，p2为int类型的变量。</font></p>
<hr>

        <h1 id="2-结构体"   >
          <a href="#2-结构体" class="heading-link"><i class="fas fa-link"></i></a>2. 结构体</h1>
      
        <h2 id="2-1-结构体的定义"   >
          <a href="#2-1-结构体的定义" class="heading-link"><i class="fas fa-link"></i></a>2.1 结构体的定义</h2>
      <p>类似于类，可以表示一个需要用各种数据类型表示的数据集体，如学生有他的姓名年龄，那么此时就需要进行结构体的定义，将学生封装为<code>char</code>类型的姓名和包括<code>int</code>类型的年龄。<br><br>具体在C++中表达如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>他在数据结构中用处十分之大，比如链表中需要定义<code>data</code>和<code>next</code>，又比如在二叉树中需要定义双亲和头节点等。都需要用到结构体。</p>

        <h2 id="2-2-结构体的初始化"   >
          <a href="#2-2-结构体的初始化" class="heading-link"><i class="fas fa-link"></i></a>2.2 结构体的初始化</h2>
      <p>结构体的初始化有如下两种方式：</p>
<ul>
<li>通过直接定义初始化<br><code>struct Student s1;</code>：表示构造出一个数据类型为<code>Student</code>的学生变量<code>s1</code>。<br>注意：此类型构造需要确定结构体定义的位置，如果在同一个方法内可以调用，在不同方法内不能调用。如果结构体被设置为全局则每个方法都可以引用。</li>
<li>在构造时完成初始化<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,s1,s2</span><br></pre></td></tr></table></div></figure>
这样就表示<code>s1,s2</code>两个变量是<code>Student</code>类型，并且再后续无需再定义就可以直接使用，在构造的时候就完成了初始化。</li>
</ul>

        <h2 id="2-3-typedef关键字"   >
          <a href="#2-3-typedef关键字" class="heading-link"><i class="fas fa-link"></i></a>2.3 typedef关键字</h2>
      <p><code>typedef</code>关键字可以简化结构体变量的初始化，通过该关键字可以给结构体起别名，从而直接实现通过别名来进行调用。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,S,s1</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>其中，S为结构体的别名，s1为结构体类型的变量。</p>
</blockquote>

        <h2 id="2-4-结构体成员变量的调用"   >
          <a href="#2-4-结构体成员变量的调用" class="heading-link"><i class="fas fa-link"></i></a>2.4 结构体成员变量的调用</h2>
      <p>通过<code>.</code>的形式调用。<br>如<code>s1.age</code>表示第一名学生的年龄；<code>s2.name</code>表示第二名学生的姓名。</p>
<hr>

        <h1 id="3-指向结构体的指针"   >
          <a href="#3-指向结构体的指针" class="heading-link"><i class="fas fa-link"></i></a>3. 指向结构体的指针</h1>
      <p>此时结构体可以视为数据类型，所以指针定义写法和原先指针写法差别不大。<br><code>struct Student* p= &amp;s1</code></p>
<blockquote>
<p>指向结构体Student的指针p(左值)，指向(&#x3D;)数据类型为Student的s1的地址(右值)。</p>
</blockquote>
<ul>
<li><font size=4 color=red><b>指针访问结构体成员变量</b></font><br>用箭头函数：<br><code>p-&gt;name</code><blockquote>
<p>无需带变量名，因为p指向了地址，知道需要获取哪个变量的值</p>
</blockquote>
</li>
</ul>
<hr>
<p>本篇只针对于目前个人认为可能会在数据结构中用到的知识点，对于真正的指针和结构体的知识知识九牛一毛不尽完整，而对于有关于理解数据结构语法有帮助的知识点，如有遗漏或者后续想到的，接下来再来进行补充。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>指针</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>线程与进程</title>
    <url>/post/52642/</url>
    <content><![CDATA[
        <h1 id="1-进程与线程"   >
          <a href="#1-进程与线程" class="heading-link"><i class="fas fa-link"></i></a>1. 进程与线程</h1>
      
        <h2 id="进程与线程"   >
          <a href="#进程与线程" class="heading-link"><i class="fas fa-link"></i></a>进程与线程</h2>
      <ul>
<li>进程：可被视为程序的一个实例，可以视为由指令和数据组成。进程就是用来加载指令，管理内存，管理io的。</li>
<li>线程：一个进程之内可以有多个线程同时运行，线程可以视为是进程的一个子集。可被视为一个个指令流，将指令流中的一条条指令依次顺序执行。<ul>
<li>线程为最小调度单位，进程为资源分配的最小单位</li>
<li>进程拥有共享的资源，如内存空间可以使内部的线程实现共享。</li>
</ul>
</li>
</ul>

        <h2 id="并行和并发"   >
          <a href="#并行和并发" class="heading-link"><i class="fas fa-link"></i></a>并行和并发</h2>
      <ul>
<li>并发是同一时间应对多件事情的能力</li>
<li>并行是同一时间动手做多件事情的能力</li>
</ul>

        <h2 id="同步和异步"   >
          <a href="#同步和异步" class="heading-link"><i class="fas fa-link"></i></a>同步和异步</h2>
      <ul>
<li>同步指的是需要等待结果返回才能继续运行</li>
<li>异步是指无需等待结果返回，仍然能够运行</li>
</ul>
<ol>
<li><p>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 </p>
</li>
<li><p>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分，也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没有意义 </p>
</li>
<li><p>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程</title>
    <url>/post/35861/</url>
    <content><![CDATA[
        <h1 id="创建和运行线程"   >
          <a href="#创建和运行线程" class="heading-link"><i class="fas fa-link"></i></a>创建和运行线程</h1>
      
        <h2 id="直接使用-Thread-创建线程"   >
          <a href="#直接使用-Thread-创建线程" class="heading-link"><i class="fas fa-link"></i></a>直接使用 Thread 创建线程</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新建线程对象 参数为线程名称</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></div></figure>




        <h2 id="使用-Runnable-配合-Thread"   >
          <a href="#使用-Runnable-配合-Thread" class="heading-link"><i class="fas fa-link"></i></a>使用 Runnable 配合 Thread</h2>
      <blockquote>
<p>runnable 代表了可运行的任务，将线程和任务进行分离</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnbale, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t2.start();</span><br></pre></td></tr></table></div></figure>




        <h2 id="FutureTask-配合-Thread"   >
          <a href="#FutureTask-配合-Thread" class="heading-link"><i class="fas fa-link"></i></a>FutureTask 配合 Thread</h2>
      <blockquote>
<p> FutureTask 也是表示了任务，他和 runnable 的区别在于他有返回值，而 Runnable 没有返回值。</p>
</blockquote>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 创建任务对象 泛型表示返回的对象</span></span><br><span class="line"> <span class="comment">// lambda表达式将函数作为参数进行传递</span></span><br><span class="line"> FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line"> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取返回结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br></pre></td></tr></table></div></figure>


        <h2 id="多个线程同时运行"   >
          <a href="#多个线程同时运行" class="heading-link"><i class="fas fa-link"></i></a>多个线程同时运行</h2>
      <ul>
<li>交替运行</li>
<li>先后顺序不由我们控制，而由底层的操作系统进行控制</li>
</ul>

        <h2 id="查看进程线程的方法"   >
          <a href="#查看进程线程的方法" class="heading-link"><i class="fas fa-link"></i></a>查看进程线程的方法</h2>
      
        <h3 id="windows"   >
          <a href="#windows" class="heading-link"><i class="fas fa-link"></i></a>windows</h3>
      <p><code>taskList</code>  查看进程<br><code>taskkill</code> 杀死进程</p>

        <h3 id="linux"   >
          <a href="#linux" class="heading-link"><i class="fas fa-link"></i></a>linux</h3>
      <p><code>ps -fe</code> 查看所有进程<br><code>ps -fT -p &lt;PID&gt;</code> 查看某个进程（PID）的所有线程<br><code>kill</code> 杀死进程</p>

        <h3 id="java"   >
          <a href="#java" class="heading-link"><i class="fas fa-link"></i></a>java</h3>
      <p><code>jps</code> 查看所有的 java 进程<br><code>jstack &lt;PID&gt;</code>  查看某个 Java 进程的所有线程状态<br><code>jconsole</code> 查看运行状态（图形界面）</p>

        <h2 id="线程运行的原理"   >
          <a href="#线程运行的原理" class="heading-link"><i class="fas fa-link"></i></a>线程运行的原理</h2>
      
        <h3 id="栈与栈帧"   >
          <a href="#栈与栈帧" class="heading-link"><i class="fas fa-link"></i></a>栈与栈帧</h3>
      <ul>
<li><p>每个线程启动之后，虚拟机会为其分配一块栈内存。</p>
</li>
<li><p>每个栈由多个栈帧（Frame） 组成，对应着每次方法调用时候所占用的内存</p>
</li>
<li><p>每个线程只能有一个活动栈帧，对应着当前正在执行的方法</p>
</li>
</ul>

        <h3 id="线程的上下文切换"   >
          <a href="#线程的上下文切换" class="heading-link"><i class="fas fa-link"></i></a>线程的上下文切换</h3>
      <p>上下文切换，即 CPU 分配的时间片由一个线程转为另一个线程，也即切换线程<br>导致上下文切换可能的原因：</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收</li>
<li>有更高级的线程需要运行</li>
<li>线程自己调用了 sleep，yield，wait，join，park，synchronized，lock 等方法<br>  当上下文切换执行后，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态。java 中通常通过程序计数器来实现，上下文切换的频繁发生会影响性能。</li>
</ul>

        <h2 id="线程的常见方法"   >
          <a href="#线程的常见方法" class="heading-link"><i class="fas fa-link"></i></a>线程的常见方法</h2>
      
        <h3 id="run-和-Start"   >
          <a href="#run-和-Start" class="heading-link"><i class="fas fa-link"></i></a>run() 和 Start()</h3>
      <ul>
<li>run() 方法是线程中一个重写执行逻辑的方法，如果在主程序单独的调用线程的run方法，只是实现了其中的逻辑，而没有启动线程。</li>
<li>start() 启动了新的线程，在新的线程中执行 run() 方法等方法。</li>
</ul>

        <h3 id="sleep-和-yield"   >
          <a href="#sleep-和-yield" class="heading-link"><i class="fas fa-link"></i></a>sleep() 和 yield()</h3>
      <ul>
<li>sleep()<br>  ○ 调用他会让线程从 Running 进入到 Timed Waiting 状态（阻塞）<br>  ○ 可以使用 interrupt 打断正在睡眠的线程，此时会抛出 InterruptedException错误。</li>
<li>yield()<br>  ○ 调用他会让线程从 Running 进入到 Runnable 状态<br>  ○ 具体执行逻辑取决于任务调度器</li>
</ul>

        <h3 id="join"   >
          <a href="#join" class="heading-link"><i class="fas fa-link"></i></a>join()</h3>
      <p>  等待 join() 的调用者的任务执行完成之后，在进行下一步的操作。可以理解成局部线程的同步。其中参数可以添加时间，取到线程执行任务时间和参数传递的时间的最小值作为最多等待的时间。</p>

        <h3 id="interrupt"   >
          <a href="#interrupt" class="heading-link"><i class="fas fa-link"></i></a>interrupt</h3>
      <p>打断 sleep， wait， join 的线程，并抛出InterruptedException异常，如果是 sleep 状态的线程被打断，会清空打断状态，即t.isInterrupted() &#x3D; false<br>如果是打断正常运行的线程，那么t.isInterrupted() &#x3D; true</p>

        <h2 id="主线程与守护线程"   >
          <a href="#主线程与守护线程" class="heading-link"><i class="fas fa-link"></i></a>主线程与守护线程</h2>
      <p>只要非守护线程运行结束了，那么即使守护线程的代码没有执行完成，也会强制结束。<br>设置守护线程：t1.setDaemon(true);</p>

        <h2 id="线程的状态"   >
          <a href="#线程的状态" class="heading-link"><i class="fas fa-link"></i></a>线程的状态</h2>
      
        <h3 id="五种状态（从操作系统层面来讲）"   >
          <a href="#五种状态（从操作系统层面来讲）" class="heading-link"><i class="fas fa-link"></i></a>五种状态（从操作系统层面来讲）</h3>
      <ul>
<li>[初始状态]，刚 new 出来的对象，仅仅是对象层面，还没有和线程相关联。</li>
<li>[可运行状态]，指该线程已经被创建，可以被 CPU 调度运行。</li>
<li>[运行状态]，获取了CPU时间片的运行中的状态，当 CPU 时间片用完时，会从运行状态转换为可运行状态，导致线程的上下文切换。</li>
<li>[阻塞状态]，线程进行上下文切换到其他的状态，只要一直不被唤醒，调度器就一直不会考虑调度他们。</li>
<li>[终止状态]，表示线程已经执行完毕，生命周期已经结束，不会再转变为其他的状态。</li>
</ul>

        <h3 id="六种状态（从-JAVA-API-的层面描述）"   >
          <a href="#六种状态（从-JAVA-API-的层面描述）" class="heading-link"><i class="fas fa-link"></i></a>六种状态（从 JAVA API 的层面描述）</h3>
      <ul>
<li>new， 如同操作系统中的初始状态，指线程刚刚被创建</li>
<li>runnable， 包括了操作系统中的可运行状态，运行状态和阻塞状态</li>
<li>blocked，加锁导致的阻塞</li>
<li>waiting，调用 wait()方法之后的阻塞</li>
<li>timed_waiting， 调用 wait()方法之后的阻塞，但是有时限</li>
<li>terminated，终止状态。</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM概述</title>
    <url>/post/42640/</url>
    <content><![CDATA[
        <h1 id="一-Java语言及JVM的概述"   >
          <a href="#一-Java语言及JVM的概述" class="heading-link"><i class="fas fa-link"></i></a>一.Java语言及JVM的概述</h1>
      
        <h2 id="1-Java的优点"   >
          <a href="#1-Java的优点" class="heading-link"><i class="fas fa-link"></i></a>1. Java的优点</h2>
      <ul>
<li>一次编译，到处运行。</li>
<li>内存管理访问机制相对安全，尽可能避免内存泄漏和数组指针越界等问题。</li>
<li>热点代码检测，编译优化<blockquote>
<p>编译优化：<code>String c = &quot;a&quot; + &quot;b&quot;; </code> &#x3D;&#x3D;&gt;<code>String c = &quot;ab&quot;;</code></p>
</blockquote>
</li>
<li>第三方类库丰富，开源功能强大</li>
<li>多态</li>
</ul>

        <h2 id="2-JVM"   >
          <a href="#2-JVM" class="heading-link"><i class="fas fa-link"></i></a>2.JVM</h2>
      <p>​		jvm ( Java visual machine )，java虚拟机， 具有控制java内存的能力，可以让程序员在编写程序时享受自动内存管理的诸多优势，但是也需要警惕因为各种原因出现的内存泄露和溢出的问题。</p>
<p> 下图为Java技术体系的三个概念的关系：</p>
<p><img src="/images/JVM.png" alt="image-20221118174353103"></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>线程安全问题</title>
    <url>/post/49820/</url>
    <content><![CDATA[
        <h2 id="两个基本概念"   >
          <a href="#两个基本概念" class="heading-link"><i class="fas fa-link"></i></a>两个基本概念</h2>
      
        <h4 id="临界区"   >
          <a href="#临界区" class="heading-link"><i class="fas fa-link"></i></a>临界区</h4>
      <ul>
<li>多个线程读取共享资源的时候不会出现问题</li>
<li>但是多个线程对共享资源进行写操作的时候可能会出现指令的交错的问题</li>
<li>如果一段代码内存在对于共享资源的多线程读写操作，那么我们称这段代码为临界区</li>
</ul>

        <h4 id="竞态条件"   >
          <a href="#竞态条件" class="heading-link"><i class="fas fa-link"></i></a>竞态条件</h4>
      <p>多个线程在临界区内执行，由于代码的执行序列不同导致结果无法预测，称之为发生了竞态条件</p>

        <h2 id="synchronized"   >
          <a href="#synchronized" class="heading-link"><i class="fas fa-link"></i></a>synchronized</h2>
      <p>对象锁，他采用互斥的方式让同一时刻<strong>最多只有一个线程</strong>能够持有对象锁，其他线程想要读写临界区中的资源，就会进入阻塞状态，不用担心因为线程上下文切换而引发的指令交错问题。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693913543945-670606e2-1e8b-4deb-8310-ea4467172140.png" alt="img"></p>
<p>原理：用 <strong>对象锁</strong> 确保了临界区内代码的原子性</p>
<p>也可以在方法上加上 synchronized</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">等价于</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>注意：</p>
<p>如果加的锁的对象是一致的话，才能够实现原子性，不同锁的对象相当于不加锁，例如：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(A.class) &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span>(B.class) &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>无法实现线程安全，因为他们对于锁的对象的限制是不同的。</p>
<p>同样的，对于 static 方法，也需要注意，因为他们如果加在方法上，说明他们锁的是类对象，而不是实例对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Number</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">a</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Number</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Number</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(num1) &#123;</span><br><span class="line">                <span class="comment">// 临界区</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            Number.a();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>这段代码也没有实现线程安全问题的解决，因为他们加锁的对象不是同一个，其中一个是实例对象类型，一个是 class 类型</p>

        <h2 id="变量的线程安全问题"   >
          <a href="#变量的线程安全问题" class="heading-link"><i class="fas fa-link"></i></a>变量的线程安全问题</h2>
      
        <h4 id="成员变量和局部变量是否线程安全"   >
          <a href="#成员变量和局部变量是否线程安全" class="heading-link"><i class="fas fa-link"></i></a>成员变量和局部变量是否线程安全</h4>
      <ul>
<li><p>如果他们没有共享，则他们是线程安全的。</p>
</li>
<li><p>如果他们被共享了：</p>
</li>
<li><ul>
<li>如果只有只读的操作，则他们线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全问题。</li>
</ul>
</li>
</ul>

        <h4 id="局部变量是否线程安全"   >
          <a href="#局部变量是否线程安全" class="heading-link"><i class="fas fa-link"></i></a>局部变量是否线程安全</h4>
      <ul>
<li><p>局部变量是线程安全的</p>
</li>
<li><p>但局部变量引用的对象不一定</p>
</li>
<li><ul>
<li>如果该对象没有逃离方法的作用访问，那么他是线程安全的</li>
<li>如果该对象逃离方法的作用范围，那么需要考虑线程安全问题(可能同时被其他类引用)</li>
</ul>
</li>
</ul>

        <h2 id="常见线程安全类"   >
          <a href="#常见线程安全类" class="heading-link"><i class="fas fa-link"></i></a>常见线程安全类</h2>
      <ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>HashTable</li>
<li>java.util.concurrent 包下的类</li>
</ul>
<p>他们的方法都是原子的，因为涉及到操作系统底层的内容</p>

        <h2 id="Monitor"   >
          <a href="#Monitor" class="heading-link"><i class="fas fa-link"></i></a>Monitor</h2>
      <p>mark Word对象标记，存储对于该对象的加锁情况：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|             Mark <span class="title function_">Word</span> <span class="params">(<span class="number">32</span> bits)</span>                       |         State      |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|        hashcode:<span class="number">25</span> | age:<span class="number">4</span> | biased_lock:<span class="number">0</span>     | <span class="number">01</span>   |        Normal      |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| thread:<span class="number">23</span> | epoch:<span class="number">2</span> | age:<span class="number">4</span> | biased_lock:<span class="number">1</span>    | <span class="number">01</span>   |        Biased      |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|               ptr_to_lock_record:<span class="number">30</span>            | <span class="number">00</span>   | Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|         ptr_to_heavyweight_monitor:<span class="number">30</span>          | <span class="number">10</span>   | Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|                                                | <span class="number">11</span>   |    Marked <span class="keyword">for</span> GC   |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br></pre></td></tr></table></div></figure>




        <h4 id="Monitor-监视器模型"   >
          <a href="#Monitor-监视器模型" class="heading-link"><i class="fas fa-link"></i></a>Monitor 监视器模型</h4>
      <p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693915171003-d8ab3fb8-b538-4e1c-81e9-016c879522b9.png" alt="img"></p>
<p>上图是Monitor监视器模型，他有<code>WaitSet</code>, <code>EntrySet</code>, <code>Owner</code>三个模型</p>
<p>当调用的临界区加上了 synchronized 对象锁后，就会触发属于该对象的监视器，注意，他和 synchronized 一样，每个对象的监视器是独有的。</p>
<ul>
<li>Thread1 调用了带有 synchronized 的临界区后，他会进入到 monitor 对象，检查其中的 Owner 是否有线程占用，没有的话则自己占用。</li>
<li>Thread2，3，4调用临界区后，发现 Owner 已经被 Thread1 占有了，那么他们会进入到 EntrySet 中进行等待，并且进入 Block 阻塞状态。</li>
<li>Thread0 因为某些原因在运用时候被打断了（比如被别的线程调用wait()指令），那么他就会进入到 WaitSet 区域等待唤醒，并且进入 Waiting 状态。</li>
</ul>

        <h2 id="Synchronized"   >
          <a href="#Synchronized" class="heading-link"><i class="fas fa-link"></i></a>Synchronized</h2>
      
        <h4 id="Synchronized-原理"   >
          <a href="#Synchronized-原理" class="heading-link"><i class="fas fa-link"></i></a>Synchronized 原理</h4>
      <p>字节码：</p>
<figure class="highlight ocaml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> // &lt;- lock引用 （synchronized开始）</span><br><span class="line"> <span class="number">3</span>: dup</span><br><span class="line"> <span class="number">4</span>: astore_1 // lock引用 -&gt; slot <span class="number">1</span></span><br><span class="line"> <span class="number">5</span>: monitorenter // 将 lock对象 <span class="type">MarkWord</span> 置为 <span class="type">Monitor</span> 指针</span><br><span class="line"> <span class="number">6</span>: getstatic #<span class="number">3</span> // &lt;- i</span><br><span class="line"> <span class="number">9</span>: iconst_1 // 准备常数 <span class="number">1</span></span><br><span class="line"> <span class="number">10</span>: iadd // +<span class="number">1</span></span><br><span class="line"> <span class="number">11</span>: putstatic #<span class="number">3</span> // -&gt; i</span><br><span class="line"> <span class="number">14</span>: aload_1 // &lt;- lock引用</span><br><span class="line"> <span class="number">15</span>: monitorexit // 将 lock对象 <span class="type">MarkWord</span> 重置, 唤醒 <span class="type">EntryList</span></span><br></pre></td></tr></table></div></figure>

<p>我们可以看到，他实质上是运用了<code>monitorenter</code>和<code>monitorexit</code>进行对象的监控，也就是说，Synchronized 是基于 Monitor 使用的。</p>

        <h4 id="轻量级锁"   >
          <a href="#轻量级锁" class="heading-link"><i class="fas fa-link"></i></a>轻量级锁</h4>
      <p>如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>对于使用者，仍是调用<code>Synchronized</code>，但底层已经优化</p>

        <h4 id="Synchronized-加锁的过程"   >
          <a href="#Synchronized-加锁的过程" class="heading-link"><i class="fas fa-link"></i></a>Synchronized 加锁的过程</h4>
      <ul>
<li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916026850-43da5061-dc78-4536-afac-64c41878d75a.png" alt="img"></p>
<ul>
<li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916049588-b7d95d2f-681d-4d02-af4b-b3be52287819.png" alt="img"></p>
<ul>
<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916071476-d200ce33-50a0-44f4-b9af-9cb3f86d0b6e.png" alt="img"></p>
<ul>
<li><p>如果 cas 失败，有两种情况 </p>
</li>
<li><ul>
<li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 </li>
<li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li>
</ul>
</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916102239-5717ab49-caba-49ec-a084-4ba3d1d1a977.png" alt="img"></p>
<ul>
<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916126612-65fb28f2-3618-4acb-939d-cc100cc6a2f9.png" alt="img"></p>
<ul>
<li><p>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 </p>
</li>
<li><ul>
<li>成功，则解锁成功 </li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>

        <h4 id="锁膨胀"   >
          <a href="#锁膨胀" class="heading-link"><i class="fas fa-link"></i></a>锁膨胀</h4>
      <p>开始我们检测到 synchronized 时候，加上的是轻量级锁，那么当我们要用 cas 操作加上轻量级锁的时候发现操作失败，说明有一种情况是已经有轻量级锁的存在了，那么这时候需要将锁升级为重量级锁。这个过程就叫做<strong>锁膨胀</strong></p>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916798091-891a3843-6bf2-4527-ba2b-eb37a3e436cc.png" alt="img"></p>
<ul>
<li><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 </p>
</li>
<li><ul>
<li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li>
<li>然后自己进入 Monitor 的 EntryList BLOCKED</li>
</ul>
</li>
</ul>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693916831099-155b5aab-2452-46ae-8a5e-34dec6bdcb0b.png" alt="img"></p>
<ul>
<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程</li>
</ul>

        <h4 id="自旋优化"   >
          <a href="#自旋优化" class="heading-link"><i class="fas fa-link"></i></a>自旋优化</h4>
      <p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。即多试几次。</p>
<p>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋。</p>

        <h4 id="偏向锁"   >
          <a href="#偏向锁" class="heading-link"><i class="fas fa-link"></i></a>偏向锁</h4>
      <p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p>
<p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>
<p>开启偏向锁后，对象的 markword 值最后三位是 101</p>
<p>没有开启偏向锁，对象创建后 markword 的值为 001</p>

        <h4 id="撤销偏向锁"   >
          <a href="#撤销偏向锁" class="heading-link"><i class="fas fa-link"></i></a>撤销偏向锁</h4>
      <ul>
<li>调用对象 hashCode</li>
<li>其它线程使用对象</li>
<li>调用 wait&#x2F;notify</li>
</ul>

        <h4 id="批量重偏向"   >
          <a href="#批量重偏向" class="heading-link"><i class="fas fa-link"></i></a>批量重偏向</h4>
      <p>当撤销偏向锁阈值超过 20 次后，jvm 给这些对象加锁时重新偏向至加锁线程</p>

        <h4 id="批量撤销"   >
          <a href="#批量撤销" class="heading-link"><i class="fas fa-link"></i></a>批量撤销</h4>
      <p>当撤销偏向锁阈值超过 40 次后，整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p>

        <h4 id="锁消除"   >
          <a href="#锁消除" class="heading-link"><i class="fas fa-link"></i></a>锁消除</h4>
      <p>当只有一个临界区加上锁，且只有一个线程执行，那么系统会自动运用锁消除技术。减轻系统负担。</p>

        <h2 id="wait-notify-notifyAll"   >
          <a href="#wait-notify-notifyAll" class="heading-link"><i class="fas fa-link"></i></a>wait notify notifyAll</h2>
      
        <h4 id="sleep-和-wait-的区别"   >
          <a href="#sleep-和-wait-的区别" class="heading-link"><i class="fas fa-link"></i></a>sleep() 和 wait() 的区别</h4>
      <ol>
<li>sleep() 是 Thread 类的方法，wait() 是 object 类的方法</li>
<li>wait() 一定要在 synchronized 代码块中使用，而 sleep() 不一定</li>
<li>sleep() 不会释放对象锁，wait() 会释放对象锁</li>
<li>它们的状态都是 TIMED_WAITING</li>
</ol>
<p>notify 随机唤醒线程，并不固定，可以采用 notifyAll 进行全部唤醒</p>

        <h2 id="同步设计模式——保护式暂停"   >
          <a href="#同步设计模式——保护式暂停" class="heading-link"><i class="fas fa-link"></i></a>同步设计模式——保护式暂停</h2>
      
        <h3 id="guardObject"   >
          <a href="#guardObject" class="heading-link"><i class="fas fa-link"></i></a>guardObject</h3>
      <p>两个线程同时监听着一个中间件，生产者将产品置为成员变量，消费者监听到成员变量里的值不为null，才取出产品。</p>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693997334508-36faae9e-6ae0-45db-b75f-9f65dc2c9323.png" alt="img"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.GuardedSuspension&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedSuspension</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardObject</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObject</span>();</span><br><span class="line">        <span class="comment">// 线程1 等待 线程2 传递的资源</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始等待获取结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> go.get();</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了结果: &#123;&#125;&quot;</span>, o);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                go.complete(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardObject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果储存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="comment">// 没有值的情况下，一直等待</span></span><br><span class="line">            <span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到结果：&#123;&#125;&quot;</span>, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="带超时版"   >
          <a href="#带超时版" class="heading-link"><i class="fas fa-link"></i></a>带超时版</h3>
      <p>这个的设计主要就是 <code>join()</code>方法的设计，其主要运用了当前时间和运行时间的比较，再将他们进行对比。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.GuardedSuspensionPassedTime&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedSuspensionPassedTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GuardObjectPassedTime</span> <span class="variable">go</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardObjectPassedTime</span>();</span><br><span class="line">        <span class="comment">// 线程1 等待 线程2 传递的资源</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;开始等待获取结果&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> go.get(<span class="number">3000L</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;获取到了结果: &#123;&#125;&quot;</span>, o);</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                go.complete(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;获取结果成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.GuardObjectPassedTime&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardObjectPassedTime</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果储存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">current</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">passed</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="comment">// 没有值的情况下，一直等待</span></span><br><span class="line">            <span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(passed &gt;= millis) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(millis - passed);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 已经等待的时间</span></span><br><span class="line">                passed = System.currentTimeMillis() - current;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="面向对象demo"   >
          <a href="#面向对象demo" class="heading-link"><i class="fas fa-link"></i></a>面向对象demo</h3>
      <p>主要运用了一个 <code>Futures</code>中间件，将对象们封装了起来</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.GuardedSuspensionMutiple&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GuardedSuspensionMutiple</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">People</span>().start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span>(Integer id : Futures.getKeySet()) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Postman</span>(id, <span class="string">&quot;message&quot;</span> + id).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.People&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始等待收信&quot;</span>);</span><br><span class="line">        <span class="type">GuardMutipleObject</span> <span class="variable">guardMutipleObject</span> <span class="operator">=</span> Futures.createGuardMutipleObject();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> guardMutipleObject.get();</span><br><span class="line">        log.debug(<span class="string">&quot;收到信了: id: &#123;&#125; response: &#123;&#125;&quot;</span>,guardMutipleObject.getId(), o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.Postman&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Postman</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer postmanId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Postman</span><span class="params">(Integer postmanId, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.postmanId = postmanId;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getPostmanId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> postmanId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardMutipleObject</span> <span class="variable">guardMutipleObject</span> <span class="operator">=</span> Futures.getGuardMutipleObject(postmanId);</span><br><span class="line">        log.debug(<span class="string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, postmanId, message);</span><br><span class="line">        guardMutipleObject.complete(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Futures</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, GuardMutipleObject&gt; guardMutipleObjectMap = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Integer <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务并且移除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardMutipleObject <span class="title function_">getGuardMutipleObject</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> guardMutipleObjectMap.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardMutipleObject <span class="title function_">createGuardMutipleObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardMutipleObject</span> <span class="variable">guardMutipleObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardMutipleObject</span>(generateId());</span><br><span class="line">        guardMutipleObjectMap.put(guardMutipleObject.getId(), guardMutipleObject);</span><br><span class="line">        <span class="keyword">return</span> guardMutipleObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取任务编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getKeySet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> guardMutipleObjectMap.keySet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GuardMutipleObject</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardMutipleObject</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结果储存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">            <span class="comment">// 没有值的情况下，一直等待</span></span><br><span class="line">            <span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;获取到结果：&#123;&#125;&quot;</span>, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="异步设计模式——消费者和生产者"   >
          <a href="#异步设计模式——消费者和生产者" class="heading-link"><i class="fas fa-link"></i></a>异步设计模式——消费者和生产者</h2>
      <p>类比消息队列，但是消息队列中是进程之间的关系，而这里是线程之间的关系</p>
<p><img src="/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.assets/1693997637001-ed8d54c5-a686-4048-aa99-a477626660c8.png" alt="img"></p>
<p>这里主要相比较于前面的同步，无需再做到对象的一一对应，生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据。且他是有容量限制的，满时不会再加入数据，空时不会再消耗数据</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.arong.JUC.async;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MessageQueue</span> <span class="variable">mq</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">StandardMessage</span> <span class="variable">message</span> <span class="operator">=</span> mq.take();</span><br><span class="line">                <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> message.getMessage();</span><br><span class="line">                log.debug(<span class="string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">StandardMessage</span> <span class="variable">standardMessage</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardMessage</span>(i, <span class="string">&quot;往消息队列发送了消息：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;发送消息： &#123;&#125;&quot;</span>, standardMessage);</span><br><span class="line">                mq.put(standardMessage);</span><br><span class="line">            &#125;,<span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Integer Capacity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储信息的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;StandardMessage&gt; list  = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    MessageQueue(Integer capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.Capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(StandardMessage sm)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="comment">// 队列满了的时候</span></span><br><span class="line">            <span class="keyword">while</span>(list.size() == Capacity) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;队列已满&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.addFirst(sm);</span><br><span class="line">            list.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> StandardMessage <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">            <span class="keyword">while</span>(list.isEmpty()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;队列已空&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">StandardMessage</span> <span class="variable">standardMessage</span> <span class="operator">=</span> list.removeLast();</span><br><span class="line">            list.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> standardMessage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StandardMessage</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;StandardMessage&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, message=&#x27;&quot;</span> + message + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StandardMessage</span><span class="params">(Integer id, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h2 id="Park-amp-UnPark"   >
          <a href="#Park-amp-UnPark" class="heading-link"><i class="fas fa-link"></i></a>Park &amp; UnPark</h2>
      <p>与 Object 的 wait &amp; notify 相比 ：</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 </li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>

        <h2 id="线程状态"   >
          <a href="#线程状态" class="heading-link"><i class="fas fa-link"></i></a>线程状态</h2>
      <p>假设有线程 Thread t </p>

        <h4 id="情况-1-NEW-–-gt-RUNNABLE"   >
          <a href="#情况-1-NEW-–-gt-RUNNABLE" class="heading-link"><i class="fas fa-link"></i></a>情况 1 NEW –&gt; RUNNABLE</h4>
      <ul>
<li>当调用 <code>t.start()</code> 方法时，由 <code>NEW --&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-2-RUNNABLE-lt-–-gt-WAITING"   >
          <a href="#情况-2-RUNNABLE-lt-–-gt-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 2 RUNNABLE &lt;–&gt; WAITING</h4>
      <p><strong>t 线程</strong>用 <code>synchronized(obj)</code> 获取了对象锁后 </p>
<ul>
<li><p>调用 <code>obj.wait()</code> 方法时，<strong>t 线程</strong>从 <code>RUNNABLE --&gt; WAITING</code> </p>
</li>
<li><p>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时 </p>
</li>
<li><ul>
<li>竞争锁成功，<strong>t 线程</strong>从<code>WAITING --&gt; RUNNABLE</code></li>
<li>竞争锁失败，<strong>t 线程</strong>从<code>WAITING --&gt; BLOCKED</code></li>
</ul>
</li>
</ul>

        <h4 id="情况-3-RUNNABLE-lt-–-gt-WAITING"   >
          <a href="#情况-3-RUNNABLE-lt-–-gt-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 3 RUNNABLE &lt;–&gt; WAITING</h4>
      <ul>
<li><strong>当前线程</strong>调用 t.join() 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; WAITING</code></li>
</ul>
<p>注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待 </p>
<ul>
<li><strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的 interrupt() 时，<strong>当前线程</strong>从<code>WAITING --&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-4-RUNNABLE-lt-–-gt-WAITING"   >
          <a href="#情况-4-RUNNABLE-lt-–-gt-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 4 RUNNABLE &lt;–&gt; WAITING</h4>
      <ul>
<li>当前线程调用 LockSupport.park() 方法会让当前线程从 <code>RUNNABLE --&gt; WAITING</code> </li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 <code>WAITING --&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING"   >
          <a href="#情况-5-RUNNABLE-lt-–-gt-TIMED-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 5 RUNNABLE &lt;–&gt; TIMED_WAITING</h4>
      <ul>
<li><p>调用 obj.wait(long n) 方法时，<strong>t 线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code> </p>
</li>
<li><p><strong>t 线程</strong>等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 </p>
</li>
<li><ul>
<li>竞争锁成功，<strong>t 线程</strong>从 <code>TIMED_WAITING --&gt; RUNNABLE</code> </li>
<li>竞争锁失败，<strong>t 线程</strong>从 <code>TIMED_WAITING --&gt; BLOCKED</code></li>
</ul>
</li>
</ul>

        <h4 id="情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING"   >
          <a href="#情况-6-RUNNABLE-lt-–-gt-TIMED-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 6 RUNNABLE &lt;–&gt; TIMED_WAITING</h4>
      <ul>
<li><strong>当前线程</strong>调用 t.join(long n) 方法时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
</ul>
<p>注意是<strong>当前线程</strong>在<strong>t 线程对象</strong>的监视器上等待 </p>
<ul>
<li><strong>当前线程</strong>等待时间超过了 n 毫秒，或<strong>t 线程</strong>运行结束，或调用了<strong>当前线程</strong>的 interrupt() 时，<strong>当前线程</strong>从 <code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING"   >
          <a href="#情况-7-RUNNABLE-lt-–-gt-TIMED-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 7 RUNNABLE &lt;–&gt; TIMED_WAITING</h4>
      <ul>
<li>当前线程调用 Thread.sleep(long n) ，当前线程从 <code>RUNNABLE --&gt; TIMED_WAITING</code> </li>
<li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从<code>TIMED_WAITING --&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING"   >
          <a href="#情况-8-RUNNABLE-lt-–-gt-TIMED-WAITING" class="heading-link"><i class="fas fa-link"></i></a>情况 8 RUNNABLE &lt;–&gt; TIMED_WAITING</h4>
      <ul>
<li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，<strong>当前线程</strong>从 <code>RUNNABLE --&gt; TIMED_WAITING</code></li>
<li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从<code>TIMED_WAITING--&gt; RUNNABLE</code></li>
</ul>

        <h4 id="情况-9-RUNNABLE-lt-–-gt-BLOCKED"   >
          <a href="#情况-9-RUNNABLE-lt-–-gt-BLOCKED" class="heading-link"><i class="fas fa-link"></i></a>情况 9 RUNNABLE &lt;–&gt; BLOCKED</h4>
      <ul>
<li><strong>t线程</strong>用synchronized(obj) 获取了对象锁时如果竞争失败，从<code>RUNNABLE --&gt; BLOCKED</code> </li>
<li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 <strong>t 线程</strong>竞争成功，从 <code>BLOCKED --&gt; RUNNABLE</code> ，其它失败的线程仍然<code>BLOCKED</code></li>
</ul>

        <h4 id="情况-10-RUNNABLE-lt-–-gt-TERMINATED"   >
          <a href="#情况-10-RUNNABLE-lt-–-gt-TERMINATED" class="heading-link"><i class="fas fa-link"></i></a>情况 10 RUNNABLE &lt;–&gt; TERMINATED</h4>
      <ul>
<li>当前线程所有代码运行完毕，进入 <code>TERMINATED</code></li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>GC</title>
    <url>/post/370/</url>
    <content><![CDATA[
        <h1 id="1-内存分配与回收原则"   >
          <a href="#1-内存分配与回收原则" class="heading-link"><i class="fas fa-link"></i></a>1. 内存分配与回收原则</h1>
      
        <h2 id="1-1-对象优先在Eden区进行分配"   >
          <a href="#1-1-对象优先在Eden区进行分配" class="heading-link"><i class="fas fa-link"></i></a>1.1 对象优先在Eden区进行分配</h2>
      <p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。若无法存入survivor区，则通过<strong>分配担保机制</strong>把新生代的对象提前转移到老年代中去 </p>
<blockquote>
<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p>
</blockquote>

        <h2 id="1-2-大对象直接进入老年代"   >
          <a href="#1-2-大对象直接进入老年代" class="heading-link"><i class="fas fa-link"></i></a>1.2 大对象直接进入老年代</h2>
      <p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。<br>大对象直接进入老年代主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>

        <h2 id="1-3-长期存活的对象进入老年代"   >
          <a href="#1-3-长期存活的对象进入老年代" class="heading-link"><i class="fas fa-link"></i></a>1.3 长期存活的对象进入老年代</h2>
      <p>大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。<br>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p>

        <h2 id="1-4-GC的分类"   >
          <a href="#1-4-GC的分类" class="heading-link"><i class="fas fa-link"></i></a>1.4 GC的分类</h2>
      <p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<ul>
<li>部分收集 (Partial GC)：<br>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；<br>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；<br>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
<li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li>
</ul>

        <h1 id="2-如何判断对象可以被回收-死亡对象的判断"   >
          <a href="#2-如何判断对象可以被回收-死亡对象的判断" class="heading-link"><i class="fas fa-link"></i></a>2. 如何判断对象可以被回收(死亡对象的判断)</h1>
      
        <h2 id="2-1-引用计数法"   >
          <a href="#2-1-引用计数法" class="heading-link"><i class="fas fa-link"></i></a>2.1 引用计数法</h2>
      <p>通过调用对象的次数计数，调用了一次+1，调用了两次+2；如果失去引用了，计数器-1；<br>弊端：循环引用可能导致计数次数无法归零，进而导致内存泄漏。</p>

        <h2 id="2-2-可达性分析算法"   >
          <a href="#2-2-可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a>2.2 可达性分析算法</h2>
      <p>先确立一个根对象(<code>GC Root</code>)，看有没有对象和根对象直接或者间接的引用，如果有，那就是不能被垃圾回收的对象。<br>可作为<code>GC Root</code>对象的有：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>

        <h2 id="2-3-四种引用"   >
          <a href="#2-3-四种引用" class="heading-link"><i class="fas fa-link"></i></a>2.3 四种引用</h2>
      
        <h3 id="2-3-1-强引用"   >
          <a href="#2-3-1-强引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.1 强引用</h3>
      <p>沿着根对象能找到的A对象，那么A对象称为被强引用。仅当强引用与A对象断开时，可被回收。</p>

        <h3 id="2-3-2-软引用"   >
          <a href="#2-3-2-软引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.2 软引用</h3>
      <p><code>SoftRenference&lt;byte[]&gt; ref = new SoftRenference&lt;&gt;(new byte[])</code><br><strong>没有被强引用所引用</strong>，垃圾回收发生时都<u>有可能</u>被回收。<br>当发生过一次垃圾回收且内存仍然不够时，会回收<strong>被软引用引用的对象</strong>。<br>软引用一般适用于一些非必要的场景，比如说网页图片，没有必要一直占着内存空间，等到需要的时候再加载就可以了。</p>
<ul>
<li>具体案例如下：<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">soft</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// list --&gt; SoftReference --&gt; byte[]</span></span><br><span class="line"></span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB]);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<strong>输出结果：</strong><blockquote>
<p>[B@330bedb4<br>1<br>[B@2503dbd3<br>2<br>[B@4b67cf4d<br>3<br>[GC (Allocation Failure) [PSYoungGen: 2162K-&gt;488K(6144K)] 14450K-&gt;13074K(19968K), 0.0019161 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br><mark>内存不足，进行一次垃圾回收。</mark><br>[B@7ea987ac<br>4<br>[GC (Allocation Failure) –[PSYoungGen: 4696K-&gt;4696K(6144K)] 17282K-&gt;17290K(19968K), 0.0006865 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>[Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4535K(6144K)] [ParOldGen: 12594K-&gt;12545K(13824K)] 17290K-&gt;17080K(19968K), [Metaspace: 3373K-&gt;3373K(1056768K)], 0.&gt; &gt; 0045075 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]<br>[GC (Allocation Failure) –[PSYoungGen: 4535K-&gt;4535K(6144K)] 17080K-&gt;17096K(19968K), 0.0006433 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs]<br>[Full GC (Allocation Failure) [PSYoungGen: 4535K-&gt;0K(6144K)] [ParOldGen: 12561K-&gt;677K(8704K)] 17096K-&gt;677K(14848K), [Metaspace: 3373K-&gt;3373K(1056768K)], 0.&gt; &gt; 0059614 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs]<br><mark>进行一次垃圾回收之后内存仍然不足，触发软引用机制，将软引用创建的对象所垃圾回收释放空间。</mark><br>[B@12a3a380<br>5<br>循环结束：5<br>null<br>null<br>null<br>null<br>[B@12a3a380</p>
</blockquote>
</li>
</ul>

        <h3 id="2-3-3-引用队列"   >
          <a href="#2-3-3-引用队列" class="heading-link"><i class="fas fa-link"></i></a>2.3.3 引用队列</h3>
      <p>软弱引用无引用对象时，自动进入引用队列</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用队列</span></span><br><span class="line">    ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 关联了引用队列， 当软引用所关联的 byte[]被回收时，软引用自己会加入到 queue 中去</span></span><br><span class="line">        SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">        System.out.println(ref.get());</span><br><span class="line">        list.add(ref);</span><br><span class="line">        System.out.println(list.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从队列中获取无用的 软引用对象，并移除</span></span><br><span class="line">    Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">    <span class="keyword">while</span>( poll != <span class="literal">null</span>) &#123;</span><br><span class="line">        list.remove(poll);</span><br><span class="line">        poll = queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; reference : list) &#123;</span><br><span class="line">        System.out.println(reference.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>输出：</p>
<blockquote>
<p>[B@4aa8f0b4 (最后结果)</p>
</blockquote>

        <h3 id="2-3-4-弱引用"   >
          <a href="#2-3-4-弱引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.4 弱引用</h3>
      <p>只要当发生了垃圾回收，被<strong>弱引用引用的对象</strong>会被回收。<br>不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>类似于软引用。</p>

        <h3 id="2-3-5-虚引用"   >
          <a href="#2-3-5-虚引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.5 虚引用</h3>
      <p>必须配合引用队列来使用。创建时即关联引用队列。缓存时会留下直接内存，当<code>StringBuffer</code>对象被回收时，他的直接内存没有被回收掉，此时虚引用对象进入引用队列，调用线程清理直接内存。<br>虚引用主要用来跟踪对象被垃圾回收的活动。起到触发器的作用，当虚引用的对象意识到自己快要被回收了，会做出一些相应的程序。</p>

        <h3 id="2-3-6-终结器引用"   >
          <a href="#2-3-6-终结器引用" class="heading-link"><i class="fas fa-link"></i></a>2.3.6 终结器引用</h3>
      <p>当<code>finallize()</code>将要被垃圾回收时，将终结器引用放入引用队列，由<code>finallizeHandler</code>去由终结器引用的对象去销毁对象<br>所以说当对象不可达的时候不会被立刻销毁，而要经历两次标记之后才确定要被销毁。<br>缺点：<code>finallizeHandler</code>优先级很低，且销毁流程漫长，需要两次GC才能销毁完成，易造成内存泄漏 。</p>

        <h1 id="3-三种垃圾收集算法"   >
          <a href="#3-三种垃圾收集算法" class="heading-link"><i class="fas fa-link"></i></a>3. 三种垃圾收集算法</h1>
      
        <h2 id="3-1-标记——清除算法-Mark-Clear"   >
          <a href="#3-1-标记——清除算法-Mark-Clear" class="heading-link"><i class="fas fa-link"></i></a>3.1 标记——清除算法(Mark-Clear)</h2>
      <ul>
<li>流程：首先标记出需要垃圾回收的对象，标记完成后，统一回收被标记的对象。也可以相反。</li>
<li>缺点：<br><strong>执行效率不稳定</strong>，随着对象增长降低效率不断变化；<br><strong>内存空间碎片化</strong>，需要分配较大内存时无法找到足够连续内存不得不提前进行一次垃圾回收操作。<br><img src="/images/Mark-Sweep.png"></li>
</ul>

        <h2 id="3-2-标记——复制算法-Mark-Copy"   >
          <a href="#3-2-标记——复制算法-Mark-Copy" class="heading-link"><i class="fas fa-link"></i></a>3.2 标记——复制算法(Mark-Copy)</h2>
      <ul>
<li>流程：<strong>半区复制。</strong> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，这一块的内存用完了，就将存活着的对象复制到另一块的上面，然后再把已使用的内存空间一次性清理掉。</li>
<li>优点：解决了碎片空间的问题，只需要移动栈顶指针，按顺序分配即可</li>
<li>缺点：<strong>内存缩小到原来的一半</strong>，造成空间浪费<br><img src="/images/Mark-Copy.png"></li>
</ul>
<p>拓展：APPel式回收<br>把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用一块Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor仍然存活的对象一次性复制到另一块Survivor中，直接清理掉原来的两块对象。<br><img src="/images/Appel.png"></p>
<blockquote>
<p>理论依据：HotSpot默认Eden和Survivor的大小比为8：1，即新生代内存空间占总内存空间的90%，相比于标记复制算法节约了巨大的内存空间，而“朝生夕灭”理论认为，新生代中有98%的对象熬不过第一轮收集，所以内存空间时绰绰有余的。</p>
</blockquote>

        <h2 id="3-3-标记——整理算法-Mark-Compact"   >
          <a href="#3-3-标记——整理算法-Mark-Compact" class="heading-link"><i class="fas fa-link"></i></a>3.3 标记——整理算法(Mark-Compact)</h2>
      <ul>
<li>流程：标记算法和前两者一样，而在回收的时候不同于前者，是先让所有存活的对象往内存空间的一侧进行移动，然后直接清理掉边界之外的内存。</li>
<li>缺点：移动更新对象任务量及其庞大，需要全程暂停用户应用程序才能进行。易形成<code>Stop The World</code>现象。</li>
<li>移动和不移动的利弊比较：<br>是否移动对象都存在弊端，<strong>移动则内存回收</strong>时会更复杂，<strong>不移动则内存分配</strong>时会更复杂；从<strong>垃圾收集的停顿时间</strong>来看，<strong>不移动</strong>对象停顿时间会更短，甚至可以不需要停顿，但是从整个<strong>程序的吞吐量</strong>来看，<strong>移动对象会更划算</strong>；即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要 高得多，这部分的耗时增加，总吞吐量仍然是下降的</li>
</ul>

        <h2 id="4-垃圾分代回收"   >
          <a href="#4-垃圾分代回收" class="heading-link"><i class="fas fa-link"></i></a>4. 垃圾分代回收</h2>
      <p>(面试题)原因：<br>因为将对象分代可以根据各个年代的特点选择合适的垃圾分配机制。<br>比如在新生代，大部分(约98%)的对象都会被回收，那么这时候就可以使用标记——复制算法，只需要复制少量的存活对象，节约内存成本。而在老年代对象存活较多的情况下，也没有足够多的空间为其进行分配担保，所以使用“标记——清除”或者“标记——整理”分类方法。</p>

        <h2 id="4-1-分代垃圾回收机制"   >
          <a href="#4-1-分代垃圾回收机制" class="heading-link"><i class="fas fa-link"></i></a>4.1 分代垃圾回收机制</h2>
      <p><img src="/images/GC.png"></p>
<ul>
<li>对象首先分配在伊甸园区域</li>
<li>新生代空间不足时，触发 minor gc，伊甸园和 from 存活的对象使用 copy 复制到 to 中，存活的对象年龄加 1并且交换 from to。</li>
<li>minor gc 会引发 stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>当对象寿命超过阈值时，会晋升至老年代，最大寿命是15（4bit）。</li>
<li>当老年代空间不足，会先尝试触发 minor gc，如果之后空间仍不足，那么触发 full gc，STW的时间更长。</li>
<li>当新生代内存无法容纳对象大小，直接晋升为老年代</li>
<li>线程中出现OOM异常时，他占据的内存资源会全部释放掉，不会影响其他线程的运行</li>
</ul>

        <h2 id="4-2-VM相关参数"   >
          <a href="#4-2-VM相关参数" class="heading-link"><i class="fas fa-link"></i></a>4.2 VM相关参数</h2>
      <p><img src="/images/VMparams.png"></p>

        <h1 id="5-垃圾回收器"   >
          <a href="#5-垃圾回收器" class="heading-link"><i class="fas fa-link"></i></a>5. 垃圾回收器</h1>
      <blockquote>
<p>serial: 串行    单线程,一个方法执行完下个方法才能够执行<br>parallel : 并行   多线程,可以同时执行垃圾回收, 但其他无法方法运行 STW 相当于所有线程都归垃圾回收所有<br>concurrent : 并发   多线程,其他方法和垃圾回收可以同时执行,但是只能逐个进行垃圾回收,相当于平等的线程分配给每一个方法</p>
</blockquote>

        <h2 id="5-1-串行垃圾回收器-Serial-x2F-Serial-Old"   >
          <a href="#5-1-串行垃圾回收器-Serial-x2F-Serial-Old" class="heading-link"><i class="fas fa-link"></i></a>5.1 串行垃圾回收器(Serial&#x2F; Serial Old)</h2>
      <p>单线程。适用于堆内存较少的情况，适合个人电脑<br><code>-XX:+UseSerialGC = Serial + SerialOld</code><br><img src="/images/serial.png"><br>新生代用“标记——复制”算法，老年代用“标记——整理”算法</p>

        <h2 id="5-2-吞吐量优先-Parallel-x2F-Parallel-Old"   >
          <a href="#5-2-吞吐量优先-Parallel-x2F-Parallel-Old" class="heading-link"><i class="fas fa-link"></i></a>5.2 吞吐量优先(Parallel&#x2F; Parallel Old)</h2>
      <p>多线程，堆内存较大，多核CPU<br>单位时间内,完成STW次数越少(STW的时间占总用户时间)<br>关注吞吐量<br><code>XX:+UseparalellGC</code><br><code>-XX:ParallelGCThreads:n</code> :允许同时允许的线程数量<br><code>-XX:+UseAdaptSizePolicy</code> :自适应调整新生代的大小<br><code>-XX:GCTimeRadio:radio</code> : 最多允许<strong>垃圾回收时间占总线程时间</strong>的<mark>1&#x2F;(1+radio)</mark>,希望堆大，关注的是吞吐量<br><code>-XX:MaxGCPauseMillis=is</code> : default是200ms,表示<strong>最长垃圾回收时间</strong>,希望堆小,与上一个冲突，关注的是响应时间</p>

        <h2 id="5-2-响应时间优先-CMS-Concurrent-Marking-Sweep"   >
          <a href="#5-2-响应时间优先-CMS-Concurrent-Marking-Sweep" class="heading-link"><i class="fas fa-link"></i></a>5.2 响应时间优先(CMS Concurrent Marking Sweep)</h2>
      <p>多线程，堆内存较大，多核CPU<br>注重STW时间的长度(单独只考虑STW的时间)</p>
<ul>
<li>初始标记: 需要STW，但仅标记与GC Root关联的对象,速度快</li>
<li>并发标记: 从GC Root直接关联对象开始遍历整个对象图, 耗时长,但并发运行</li>
<li>重新标记: 需要STW, 修正因并发导致的对象标记变动</li>
<li>并发清除: 清理标记对象<br><strong><font color=red>只有在初始标记和重新标记时候才会STW</font></strong><br>三个缺点:</li>
<li>对CPU占用低,只占用了一部分进行GC, 但拖慢了用户进行的CPU量, 对吞吐量有影响.</li>
<li>并发过程中产生的浮动垃圾难以处理</li>
<li>使用“标记——清除”算法大量空间碎片的产生<br><code>-XX:+UseConcMarkSweepGC</code><br><code>-XX:ConcGCThreads=thread</code>:运用于垃圾回收的线程,一般是总线程数的1&#x2F;4<br><code>-XX:CMSInitiatingOccupancyFraction : percent</code> :触发垃圾回收阈值<br>剩下内存空间留给其他进行的进程以及浮动垃圾; 阈值过高可能导致并发失败<br><img src="/images/CMS.png"></li>
</ul>

        <h1 id="6-G1"   >
          <a href="#6-G1" class="heading-link"><i class="fas fa-link"></i></a>6. G1</h1>
      <blockquote>
<p>难点，一款很多知识点的垃圾回收器，牵涉到很多新概念</p>
</blockquote>

        <h2 id="6-1-基础概念的了解"   >
          <a href="#6-1-基础概念的了解" class="heading-link"><i class="fas fa-link"></i></a>6.1 基础概念的了解</h2>
      
        <h3 id="6-1-1-写屏障"   >
          <a href="#6-1-1-写屏障" class="heading-link"><i class="fas fa-link"></i></a>6.1.1 写屏障</h3>
      <p>可以看成是虚拟机层面对”引用类型字段赋值”这个动作的AOP切面, 在引用对象赋值的时候会形成一个环形,供程序执行额外的操作,而我们解决这种想要在编译场景中赋值的操作,就可以使用写屏障这种在机械码方面操作的手段,简单的来说,写屏障就是负责对在编译阶段中产生改变内容的处理的.</p>

        <h3 id="6-1-2-记忆集和卡表"   >
          <a href="#6-1-2-记忆集和卡表" class="heading-link"><i class="fas fa-link"></i></a>6.1.2 记忆集和卡表</h3>
      <p>这两者的出现是为了解决对象跨代引用所带来的问题的.跨代引用会导致老年代向新生代的引用难以通过只扫描新生代的对象去识别, 而如果要进行对老年代和新生代进行同时扫描的话, 那么STW的时间会变长, 性能较差.而记忆集是一种抽象的数据结构, 主要是用于记录非搜集区域指向搜集区域的指针集合的抽象数据结构.其在G1垃圾处理器中被安排在新生代中.而卡表是记忆集的一种具体实现.卡表主要运用在老年代, 当有一个老年代对象引用了新生代的时候, 卡表就会在对应的数组元素值标记为1, 表示这个元素为脏.之后通过写屏障在引用对象的行为发生时进行标记, 之后在新生代垃圾回收扫描时,这个对象就会被视为活对象了.</p>

        <h2 id="6-2-三色标记算法"   >
          <a href="#6-2-三色标记算法" class="heading-link"><i class="fas fa-link"></i></a>6.2 三色标记算法</h2>
      
        <h3 id="6-2-1-基本概念"   >
          <a href="#6-2-1-基本概念" class="heading-link"><i class="fas fa-link"></i></a>6.2.1 基本概念</h3>
      <p>这是垃圾回收在新生代回收时根据GC Root的遍历所进行标记的一种算法.具体实现为将对象标为黑灰白三种对象, 其划分标准如下: </p>
<ul>
<li>黑: 已经被垃圾回收器访问过, 其所有引用已经全部被扫描过了, 保证其是安全存活的, 且不会再进行扫描;</li>
<li>灰: 被垃圾回收器访问过, 但是他身上的至少一个引用还没有被垃圾回收器访问, 是扫描引用他的灰色对象之后形成的;</li>
<li>白: 没有被垃圾回收器访问过, 开始的时候所有对象都是白色的, 当垃圾回收扫描完成时, 还是白色的对象说明对象是不可达的.<br>扫描完成的标志: 没有灰色对象的存在</li>
</ul>

        <h3 id="6-2-2-遍历过程"   >
          <a href="#6-2-2-遍历过程" class="heading-link"><i class="fas fa-link"></i></a>6.2.2 遍历过程</h3>
      <p>1.初始时，全部对象都是白色的<br>2.GC Roots直接引用的对象变成灰色<br>3.从灰色集合中获取元素：<br>    3.1 将本对象直接引用的对象标记为灰色<br>    3.2 将本对象标记为黑色<br>4.重复步骤3，直到灰色的对象集合变为空<br>5.结束后，仍然被标记为白色的对象就是不可达对象，视为垃圾对象</p>

        <h3 id="6-2-3-存在问题"   >
          <a href="#6-2-3-存在问题" class="heading-link"><i class="fas fa-link"></i></a>6.2.3 存在问题</h3>
      <p>标记算法存在的问题都是基于并发执行下产生的, 因为用户线程在进行的时候, 对象的调用总是会进行, 而同时进行对对象的操作有可能导致引用的错误.</p>
<ol>
<li>漏删<br>把原本死亡的对象标记为存活, 会发生的情况为因为A到B的引用,B被标灰了,但之后引用就断开了, 此时B没有对象引用他, 但是他的标记是灰色, 不会被回收, 这种我们把它叫做浮动垃圾. 这种解决方案十分简单, 下次扫描的时候, 因为没有对象引用他, 他就会自动被删除的.</li>
<li>多删<br>原本是黑色的对象被标记为白色.具体造成原因为如下两点:</li>
</ol>
<ul>
<li>插入了一条或者多条黑色对象对白色对象的引用</li>
<li>删除了所有灰色对象对白色对象的直接或者间接引用<br>这种问题很大, 因为本来程序运行所需要的一个对象被销毁了, 会导致程序的异常, 那么垃圾回收器给出了我们两种如下解决方案.</li>
</ul>

        <h3 id="6-2-4-解决方案"   >
          <a href="#6-2-4-解决方案" class="heading-link"><i class="fas fa-link"></i></a>6.2.4 解决方案</h3>
      <ul>
<li>增量更新(Increment update)<br>破坏的是第一个条件, 他会将这个新插入的引用记录下来, 扫描结束之后会以黑色对象为根重新进行扫描,可以理解为这个技术可以使得产生的新引用的黑色节点变灰.其主要实现为写屏障; 主要用于CMS中</li>
<li>原始快照(SnapShot At The Beginning)<br>破坏的主要是第二个条件, 他会在断开连接时将断开连接前的一瞬间记录下来, 再将他放到一个独立的内存区域中, 扫描结束后, 重新以灰色节点为根重新进行扫描.</li>
</ul>

        <h2 id="6-3-G1垃圾回收器的垃圾处理流程"   >
          <a href="#6-3-G1垃圾回收器的垃圾处理流程" class="heading-link"><i class="fas fa-link"></i></a>6.3 G1垃圾回收器的垃圾处理流程</h2>
      
        <h3 id="6-3-1-以rigion为分区的回收范围改变"   >
          <a href="#6-3-1-以rigion为分区的回收范围改变" class="heading-link"><i class="fas fa-link"></i></a>6.3.1 以rigion为分区的回收范围改变</h3>
      <p>首先我们需要知道，G1相较于CMS包括之前的垃圾回收器做出了一个巨大的改变，就是垃圾回收区域的划分，以前分代收集理论是垃圾回收器的主流理论，而G1将其做了一个更新包装，其面向堆内任何部分来组成回收集(Cset)，每一个回收集被叫做region区域，每一个区域中也可扮演为Eden，Survivor空间，每次回收的最小单元是一个region，而对于不同的region区域采取不同的策略，对于垃圾回收产生了更为优秀的结果。G1收集器会自动的去评估每个region区域的回收价值大小，根据<code>-XX:MaxGCPauseMillis</code>参数来确定回收策略，我们叫这种模式为<code>Mixed GC</code>。相比于之前，有两个优点，一个是变得更加灵活了，有回收策略了；另一个是不再需要连续了，内存空间的分配也会更加合理。<br>那么在我们了解了这种化整为零的内存空间分配策略后，我们需要知道整个G1回收器的垃圾回收流程：<br><img src="/images/G1.png"></p>

        <h3 id="6-3-2-Young-GC"   >
          <a href="#6-3-2-Young-GC" class="heading-link"><i class="fas fa-link"></i></a>6.3.2 Young GC</h3>
      <p>程序在运行的时候，随着对象不断创建，许多内存进行Eden区，当Eden区被占满时，会自动触发一次<code>Young GC</code>，此时会引起STW，此时G1涉及的对象只有Eden区和Survivor区,回收的内存进入<code>Cset</code>中进行回收;运用了复制算法,将存活单位复制到新的survivor区域.</p>
<ul>
<li>扫描根和rset, 此时会有一个小的短暂的STW;</li>
<li>运用写屏障更新rset,此时所有跨代引用对象不会被视为垃圾;</li>
<li>复制算法,实现Eden区和Survivor区的存活对象到新的Survivor区的转移</li>
<li>处理软弱虚引用.</li>
</ul>

        <h3 id="6-3-3-Young-GC-Concurrent-Marking"   >
          <a href="#6-3-3-Young-GC-Concurrent-Marking" class="heading-link"><i class="fas fa-link"></i></a>6.3.3 Young GC + Concurrent Marking</h3>
      <ul>
<li>首先进行一次young GC, 同时进行一次进行一次初始标记, 标记GC Root对象, 此时会发生STW;</li>
<li>并发标记, 沿着GC Root遍历对象, 同时将所有跨代引用的标记变脏,此时属于并发标记, 不会STW; 同时也会进行SATB, 对漏标的对象进行了处理;</li>
<li>再次标记, 处理原来SATB的对象; </li>
<li>独占清理, 对每一块内存区域进行排序, 为下阶段Mixed GC做准备;</li>
<li>清理本阶段内存.</li>
</ul>

        <h3 id="6-3-4-Mixed-GC"   >
          <a href="#6-3-4-Mixed-GC" class="heading-link"><i class="fas fa-link"></i></a>6.3.4 Mixed GC</h3>
      <p>此时会根据<code>-XX:MaxGCPauseMillis</code>实现清理策略, 在这个阶段会做三件事:</p>
<ul>
<li>新生代的垃圾回收: Eden区存活对象到survivor区; Survivor区存活对象到新的survivor区; </li>
<li>晋升: Survivor区达到晋升阈值的对象晋升到老年代</li>
<li>老年代的垃圾回收: 结合<code>-XX:MaxGCPauseMillis</code>和上一阶段的排序, 将部分老年代进行回收;<br>这个阶段也说明了Garbage First这个垃圾回收器名字的由来, 就是会在这个环节优先回收占用内存较多的区域.<blockquote>
<p><code>-XX:MaxGCPauseMillis</code>: 最大暂停时间过短, 回收速度小于产生速度, 触发单线程的Full GC; 正常情况, 回收速度大于产生速度, Concurrent mark;<br><code>-XX：G1MixedGCLiveThresholdPercent</code>: 回收阈值,默认为65%; 达到之后才会触发回收, 过小意味着存活对象多,复制时间浪费多, STW时间长．</p>
</blockquote>
</li>
</ul>

        <h2 id="6-4-新增功能"   >
          <a href="#6-4-新增功能" class="heading-link"><i class="fas fa-link"></i></a>6.4 新增功能</h2>
      
        <h3 id="6-4-1-字符串去重"   >
          <a href="#6-4-1-字符串去重" class="heading-link"><i class="fas fa-link"></i></a>6.4.1 字符串去重</h3>
      <ul>
<li>优点：节省大量内存</li>
<li>缺点：略微多占用了 cpu 时间，新生代回收时间略微增加<br><code>-XX:+UseStringDeduplication</code><br>将所有新分配的字符串放入一个队列; 当新生代回收时，G1并发检查是否有字符串重复; 如果它们值一样，让它们引用同一个 char[]<blockquote>
<p>注意: 与 String.intern() 不一样; String.intern() 关注的是字符串对象; 而字符串去重关注的是 char[]; 在 JVM 内部，使用了不同的字符串表</p>
</blockquote>
</li>
</ul>

        <h3 id="6-4-2-类卸载"   >
          <a href="#6-4-2-类卸载" class="heading-link"><i class="fas fa-link"></i></a>6.4.2 类卸载</h3>
      <p>所有对象都经过并发标记后，就能知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类<br>-XX:+ClassUnloadingWithConcurrentMark 默认启用</p>

        <h3 id="6-4-3-巨型对象管理"   >
          <a href="#6-4-3-巨型对象管理" class="heading-link"><i class="fas fa-link"></i></a>6.4.3 巨型对象管理</h3>
      <p>一个对象大于 region 的一半时，称之为巨型对象<br>G1 不会对巨型对象进行拷贝<br>回收时被优先考虑<br>G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为0 的巨型对象就可以在新生代垃圾回收时处理掉</p>

        <h1 id="7-ZGC收集器"   >
          <a href="#7-ZGC收集器" class="heading-link"><i class="fas fa-link"></i></a>7. ZGC收集器</h1>
      <p>是一款低延迟垃圾收集器, 希望在对吞吐量影响不大的前提下, 把垃圾收集的停顿时间缩短在10ms以内。<br>其内存布局也是和G1一样划分为若干Region区，但其具有动态的容量大小和动态创建和销毁的特征，可以分为如下三种容量：</p>
<ul>
<li>大： 不固定可以动态变换，但是一定为2MB的整数倍，不会被重分配。</li>
<li>中： 容量固定为32MB， 用来存储256KB ~ 4MB的对象</li>
<li>小： 容量固定为2MB， 用来存储0 ~ 256KB的对象</li>
</ul>

        <h2 id="7-1-ZGC的垃圾收集流程"   >
          <a href="#7-1-ZGC的垃圾收集流程" class="heading-link"><i class="fas fa-link"></i></a>7.1 ZGC的垃圾收集流程</h2>
      
        <h3 id="7-1-1-并发标记-Concurrent-Marking"   >
          <a href="#7-1-1-并发标记-Concurrent-Marking" class="heading-link"><i class="fas fa-link"></i></a>7.1.1 并发标记(Concurrent Marking)</h3>
      <p>只会在开始标记GC Root的时候有小小的停顿，剩下的标记活动都是并发运行的。和G1需要STW进行三色算法不同，ZGC的标记位置是在指针上的，所以可以省略去遍历对象图的流程</p>

        <h3 id="7-1-2-并发预备重分配-Concurrent-Perpare-for-Relocation"   >
          <a href="#7-1-2-并发预备重分配-Concurrent-Perpare-for-Relocation" class="heading-link"><i class="fas fa-link"></i></a>7.1.2 并发预备重分配(Concurrent Perpare for Relocation)</h3>
      <p>通过并发标记得出的结论查询到底有哪些垃圾是需要回收的，然后将需要回收的Region区组成重分配集(Relocation Set)。因为ZGC不区分新生代老年代的特点，所以该阶段的扫描是针对全堆的，但同时相较于G1也省去了记忆集的维护成本。</p>
<blockquote>
<p>ZGC的重分配集只是决定了里面的存活对象会被重新复制到其他的Region中，而不是说回收的行为针对这个集合里面的region进行。</p>
</blockquote>

        <h3 id="7-1-3-并发重分配-Concurrent-Relocation"   >
          <a href="#7-1-3-并发重分配-Concurrent-Relocation" class="heading-link"><i class="fas fa-link"></i></a>7.1.3 并发重分配(Concurrent Relocation)</h3>
      <p>是ZGC垃圾回收的核心过程。他将重分配集中的存活对象转移到新的Region中，并在重分配集中建立一个转发表(Forward Table)，用来标记重分配区中旧的Region对象到新的Region对象的转发关系。当用户访问了重分配集中的对象，那么就会被预置的内存屏障所截获，根据转发表的记录转发到新的对象上，并将引用更改到新的对象上，使其指向新的对象。这种行为被称为指针的“自愈”行为。<br>一旦region的存活对象都被复制完毕，那么这个region就可以进行下一轮的内存分配。但是转发表却得等到所有重分配集中的region对象复制完毕才可删除。</p>

        <h3 id="7-1-4-并发重映射-Concurrent-Remap"   >
          <a href="#7-1-4-并发重映射-Concurrent-Remap" class="heading-link"><i class="fas fa-link"></i></a>7.1.4 并发重映射(Concurrent Remap)</h3>
      <p>重映射指的是修正整个堆中指向重分配集中的旧对象的所有引用。可以合并到下一次的并发标记的流程进行，节约一次遍历对象图的操作。</p>

        <h2 id="7-2-ZGC解决并发算法问题的关键——染色指针"   >
          <a href="#7-2-ZGC解决并发算法问题的关键——染色指针" class="heading-link"><i class="fas fa-link"></i></a>7.2 ZGC解决并发算法问题的关键——染色指针</h2>
      <p>将少量标识信息存储在指针上，实现可达性分析，相较于G1的遍历对象图节约了许多时间的成本。<br>三个优点：</p>
<ol>
<li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能被释放和重用。指针的自愈行为使得它拥有即时性，而复制算法则是需要STW进行1：1的复制后才能够实现重用。</li>
<li>染色指针可以大幅度减少在垃圾收集过程中内存屏障的使用数量，内存屏障的功能之一就是记录对象引用的变动情况，而染色指针可以接替这一工作。</li>
<li>可以作为一种可拓展的存储结构用来记录，重定位过程的相关数据，日后可以进一步提升性能。日后标志位可用的提升可以使得其更有扩展性。</li>
</ol>
<p><a href="/images/GCAll.png"></a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/post/27692/</url>
    <content><![CDATA[
        <h1 id="JVM内存结构"   >
          <a href="#JVM内存结构" class="heading-link"><i class="fas fa-link"></i></a>JVM内存结构</h1>
      <p><img src="/images/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<p>内存结构基本示意图：</p>
<p><img src="/images/MemoryStructure.png"></p>

        <h2 id="1-程序计数器"   >
          <a href="#1-程序计数器" class="heading-link"><i class="fas fa-link"></i></a>1. 程序计数器</h2>
      
        <h3 id="1-1-定义"   >
          <a href="#1-1-定义" class="heading-link"><i class="fas fa-link"></i></a>1.1 定义</h3>
      <p>行号指示器，字节码解释器运行时通过改变计数器值来选取下一条需要执行的字节码指令。</p>

        <h3 id="1-2-特点"   >
          <a href="#1-2-特点" class="heading-link"><i class="fas fa-link"></i></a>1.2 特点</h3>
      <p>每条线程都需要有独立的程序计数器，<strong>线程私有</strong></p>
<p><mark>唯一一个</mark>不会出现<font color=red>OutOfMemoryError</font>情况的内存区域</p>

        <h2 id="2-栈"   >
          <a href="#2-栈" class="heading-link"><i class="fas fa-link"></i></a>2. 栈</h2>
      
        <h3 id="2-1-栈和栈帧"   >
          <a href="#2-1-栈和栈帧" class="heading-link"><i class="fas fa-link"></i></a>2.1 栈和栈帧</h3>
      <ul>
<li><p><strong>栈：线程运行所需要的内存空间</strong></p>
<ol>
<li>线程生命周期和栈的生命周期相同</li>
<li>栈的内存空间和线程数呈负相关</li>
</ol>
</li>
<li><p><strong>栈帧：每个方法运行时所需要的内存</strong></p>
<ol>
<li>存储局部变量表，操作数栈，动态连接，方法出口等</li>
<li>生命周期和方法相同，每个方法调用直到执行完毕，就对应着栈帧入栈到出栈的过程。</li>
</ol>
</li>
</ul>
<blockquote>
<p>局部变量表：用于存储方法参数和局部变量等 </p>
</blockquote>

        <h3 id="2-2-栈的线程安全"   >
          <a href="#2-2-栈的线程安全" class="heading-link"><i class="fas fa-link"></i></a>2.2 栈的线程安全</h3>
      <p><font size=5 color="red"><strong>！！！方法内的局部变量是否涉及线程安全：</strong></font></p>
<blockquote>
<p>线程安全：保证多个线程同时对某一对象或资源进行操作时不会出错</p>
</blockquote>
<ol>
<li>如果方法内局部变量没有<mark>逃离方法作用范围</mark>，那么他是**<u>线程安全</u>**的:</li>
</ol>
<p>​		没有逃离方法的作用范围，局部变量无逃逸，无法被其他线程访问。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<ol start="2">
<li><p>如果局部变量引用了对象，并<mark>逃离方法的作用范围</mark>，那么他是**<u>不安全</u>**的:</p>
<p>作为参数传参进入，可以会有被别的对象调用的风险。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p>​		存在返回值，有可能被他人调用：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">m3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    sb.append(<span class="number">1</span>);</span><br><span class="line">    sb.append(<span class="number">2</span>);</span><br><span class="line">    sb.append(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="2-3-栈的有关异常"   >
          <a href="#2-3-栈的有关异常" class="heading-link"><i class="fas fa-link"></i></a>2.3 栈的有关异常</h3>
      <ol>
<li><strong><font color=red>StackOverFlowError</font></strong>: 线程请求的栈深度大于虚拟机所允许的深度</li>
</ol>
<p>​			一般出现原因为<mark>递归</mark>调用<mark>无设置终止条件</mark>或者<mark>终止条件无法达到</mark></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo1_2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        method1(); <span class="comment">//递归调用自己，但是没有设置终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol start="2">
<li><font color=red><strong>OutOfMemoryError</strong></font>: 栈无法申请到足够多的内存空间时</li>
</ol>
<p>​			与内存空间有关。</p>

        <h2 id="3-本地方法栈"   >
          <a href="#3-本地方法栈" class="heading-link"><i class="fas fa-link"></i></a>3. 本地方法栈</h2>
      <p>为本地方法运行提供空间的内存空间</p>
<p><code>public native int hashCode();</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>含有**<u>native关键字</u>**修饰的方法<br>    object: motify, add, hashcode….</p>

        <h2 id="4-堆"   >
          <a href="#4-堆" class="heading-link"><i class="fas fa-link"></i></a>4. 堆</h2>
      
        <h3 id="4-1-定义"   >
          <a href="#4-1-定义" class="heading-link"><i class="fas fa-link"></i></a>4.1 定义</h3>
      <p>是被所有<mark>线程共享</mark>的一块区域，在<mark>虚拟机启动</mark>的时候自动创建，目的是<mark>存放对象实例(new)</mark>。</p>

        <h3 id="4-2-特点"   >
          <a href="#4-2-特点" class="heading-link"><i class="fas fa-link"></i></a>4.2 特点</h3>
      <ul>
<li>线程共享，需要考虑线程安全的问题</li>
<li>在虚拟机启动的时候自动创建</li>
<li>有垃圾回收机制</li>
</ul>

        <h3 id="4-3-堆内存溢出"   >
          <a href="#4-3-堆内存溢出" class="heading-link"><i class="fas fa-link"></i></a>4.3 堆内存溢出</h3>
      <p> <strong>java.lang.OutOfMemoryError:  Java heap space：</strong></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a); <span class="comment">// hello, hellohello, hellohellohellohello ...</span></span><br><span class="line">            a = a + a;  <span class="comment">// hellohellohellohello</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="4-4-堆内存诊断"   >
          <a href="#4-4-堆内存诊断" class="heading-link"><i class="fas fa-link"></i></a>4.4 堆内存诊断</h3>
      <ul>
<li><strong>JPS： 查看系统中有哪些java进程</strong></li>
</ul>
<p>直接在<code>Terminal</code>窗口输入jps中可得到下图结果。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进程编号         //进程名称</span></span><br><span class="line"><span class="number">11936</span>              Jps</span><br><span class="line"><span class="number">13664</span>              Demo1_4</span><br><span class="line"><span class="number">436</span>              </span><br><span class="line"><span class="number">9388</span>              Launcher</span><br></pre></td></tr></table></div></figure>

<ul>
<li><strong>Jmap：观测指定进程的内存情况</strong></li>
</ul>
<p>用<code> jmap -heap + 进程编号</code>查看当前进程的运行情况</p>
<img src="/images/jmap1.png" style="zoom: 67%;" title="堆配置信息" align="left"/>

<figure class="highlight plaintext"><figcaption><span>Configuration```： 堆配置信息</span></figcaption><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```MaxHeapSize```： 最大堆空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/jmap2.png&quot; style=&quot;zoom:67%;&quot; align=&quot;left&quot;/&gt;</span><br><span class="line"></span><br><span class="line">```Heap Usage```： 堆使用情况</span><br><span class="line"></span><br><span class="line">```used```： 已经使用</span><br><span class="line"></span><br><span class="line">```free```： 未使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- **Jconsole：图形化页面监测工具，可以实现动态的检测**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;/images/jconsole.png&quot; style=&quot;zoom:50%;&quot; align=&quot;left&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5. 方法区</span><br><span class="line"></span><br><span class="line">### 5.1 作用</span><br><span class="line"></span><br><span class="line">存储被虚拟机加载的类型信息，常量，静态变量，代码缓存等数据</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.2  JVM1.8和1.6不同的组成</span><br><span class="line"></span><br><span class="line">![](/images/MethodArea.png)</span><br><span class="line"></span><br><span class="line">主要变化：实现方式由永久代转变为了元空间，常量池中```StringTable```放到了堆内存中。</span><br><span class="line"></span><br><span class="line">原因：永久代垃圾回收机制为```Full GC```，回收效率低，易导致临时变量占据空间过多，堆内存中垃圾回收机制较永久代灵活</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.3 方法区内存溢出</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int j = 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            Demo1_8 test = new Demo1_8();</span><br><span class="line">            for (int i = 0; i &lt; 10000; i++, j++) &#123;</span><br><span class="line">                // ClassWriter 作用是生成类的二进制字节码</span><br><span class="line">                ClassWriter cw = new ClassWriter(0);</span><br><span class="line">                // 版本号， public， 类名, 包名, 父类， 接口</span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, &quot;Class&quot; + i, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">                // 返回 byte[]</span><br><span class="line">                byte[] code = cw.toByteArray();</span><br><span class="line">                // 执行了类的加载</span><br><span class="line">                test.defineClass(&quot;Class&quot; + i, code, 0, code.length); // Class 对象</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>1.8 元空间内存溢出</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.OutOfMemoryError: Metaspace</span></span><br><span class="line"><span class="comment">// -XX:MaxMetaspaceSize=8m</span></span><br></pre></td></tr></table></div></figure>



<ul>
<li>1.6 永久代内存溢出</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java.lang.OutOfMemoryError: PermGen space</span></span><br><span class="line"><span class="comment">// -XX:MaxPermSize=8m</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="6-常量池"   >
          <a href="#6-常量池" class="heading-link"><i class="fas fa-link"></i></a>6. 常量池</h2>
      <p>作用：用于存储信息，本身时二进制字节码对象，常量池中的信息，都会被加载到运行时常量池中， 这时 a b ab 都是常量池中的符号，还没有变为 java 字符串对象</p>
<p>通过<code>javap -v HelloWorld.class</code>可以获得class二进制字节码文件的基本信息</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// 基本配置信息</span></span><br><span class="line">  Last modified <span class="number">2022</span>-<span class="number">11</span>-<span class="number">24</span>; size <span class="number">442</span> bytes</span><br><span class="line">  MD5 checksum 103606e24ec918e862312533fda15bbc</span><br><span class="line">  Compiled from <span class="string">&quot;HelloWorld.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cn</span>.itcast.jvm.t5.HelloWorld</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">      <span class="comment">//常量池</span></span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">15</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">16.</span>#<span class="number">17</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">18</span>            <span class="comment">// hello world</span></span><br><span class="line">   #<span class="number">4</span> = Methodref          #<span class="number">19.</span>#<span class="number">20</span>        <span class="comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">21</span>            <span class="comment">// cn/itcast/jvm/t5/HelloWorld</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">22</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">8</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">9</span> = Utf8               Code</span><br><span class="line">  #<span class="number">10</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">11</span> = Utf8               main</span><br><span class="line">  #<span class="number">12</span> = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #<span class="number">13</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">14</span> = Utf8               HelloWorld.java</span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">23</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">24</span>:#<span class="number">25</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               hello world</span><br><span class="line">  #<span class="number">19</span> = Class              #<span class="number">26</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">20</span> = NameAndType        #<span class="number">27</span>:#<span class="number">28</span>        <span class="comment">// println:(Ljava/lang/String;)V</span></span><br><span class="line">  #<span class="number">21</span> = Utf8               cn/itcast/jvm/t5/HelloWorld</span><br><span class="line">  #<span class="number">22</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">24</span> = Utf8               out</span><br><span class="line">  #<span class="number">25</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">26</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">27</span> = Utf8               println</span><br><span class="line">  #<span class="number">28</span> = Utf8               (Ljava/lang/String;)V</span><br><span class="line">                             </span><br><span class="line">   <span class="comment">// 类方法定义</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> cn.itcast.jvm.t5.HelloWorld();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">4</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: ldc           #<span class="number">3</span>                  <span class="comment">// String hello world</span></span><br><span class="line">         <span class="number">5</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>主要操作流程： 根据指令后面编号去查找相应内容</p>

        <h2 id="7-StringTable"   >
          <a href="#7-StringTable" class="heading-link"><i class="fas fa-link"></i></a>7. StringTable</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// ab</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;   <span class="comment">// new String(&quot;ab&quot;)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问</span></span><br><span class="line">        System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">        System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">        System.out.println(s3 == s6); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>); <span class="comment">// new String(&quot;cd&quot;)</span></span><br><span class="line">        x2.intern();</span><br><span class="line">        <span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">&quot;cd&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 问，如果调换了【最后两行代码】的位置呢，如果是jdk1.6呢</span></span><br><span class="line">        System.out.println(x1 == x2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="7-1-常量池与串池之间的关系"   >
          <a href="#7-1-常量池与串池之间的关系" class="heading-link"><i class="fas fa-link"></i></a>7.1 常量池与串池之间的关系</h3>
      <p>常量池中存储的信息只是作为一个符号，通过方法调用（<code>String a = &quot;a&quot;</code>）或引用的时候才能真正的成为一个对象，而这时候如果串池中没有该对象的时候，将对象放入串池</p>
<p><mark>懒惰性：用到了才会在串池中创建，没有用到不会创建<strong>（延迟加载）</strong></mark></p>
<p>HashCode结构</p>

        <h3 id="7-2-字符串拼接"   >
          <a href="#7-2-字符串拼接" class="heading-link"><i class="fas fa-link"></i></a>7.2 字符串拼接</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()-&gt; new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="comment">// toString()方法生成了一个新的String对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> s3 == s4; <span class="comment">//false</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="7-3-编译期优化"   >
          <a href="#7-3-编译期优化" class="heading-link"><i class="fas fa-link"></i></a>7.3 编译期优化</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">//编译期的优化：两个常量之和是确定的</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> s3 == s4 <span class="comment">//true</span></span><br></pre></td></tr></table></div></figure>




        <h3 id="7-4-intern-方法"   >
          <a href="#7-4-intern-方法" class="heading-link"><i class="fas fa-link"></i></a>7.4 intern()方法</h3>
      <ul>
<li>1.8</li>
</ul>
<p>将字符串对象放入串池，有则不会放入，无则放入后返回</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</span></span><br><span class="line"> 	<span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    System.out.println( s2 == x); <span class="comment">//true</span></span><br><span class="line">    System.out.println( s == x ); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>1.6</li>
</ul>
<p>地址复制后放入串池（和原来的地址不相同）</p>
<p>public static void main(String[] args) {</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆  new String(&quot;a&quot;)   new String(&quot;b&quot;) new String(&quot;ab&quot;)</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern(); <span class="comment">// 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串池中的对象返回</span></span><br><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println( s2 == x); <span class="comment">//true</span></span><br><span class="line">System.out.println( s == x ); <span class="comment">//false   因为s2是复制的，和原来地址并不一样</span></span><br></pre></td></tr></table></div></figure>
<p>}</p>

        <h3 id="7-5-性能调优"   >
          <a href="#7-5-性能调优" class="heading-link"><i class="fas fa-link"></i></a>7.5 性能调优</h3>
      <ul>
<li>调整-XX:StringTableSize&#x3D;桶个数：桶个数多有利于提高效率</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            line = reader.readLine();</span><br><span class="line">            <span class="keyword">if</span> (line == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            line.intern();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;cost:&quot;</span> + (System.nanoTime() - start) / <span class="number">1000000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>考虑串是否入池：重复字符串入池有助于提高效率</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; address = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    System.in.read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;linux.words&quot;</span>), <span class="string">&quot;utf-8&quot;</span>))) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                line = reader.readLine();</span><br><span class="line">                <span class="keyword">if</span>(line == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                address.add(line.intern());</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;cost:&quot;</span> +(System.nanoTime()-start)/<span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.in.read();</span><br></pre></td></tr></table></div></figure>


        <h2 id="8-直接内存"   >
          <a href="#8-直接内存" class="heading-link"><i class="fas fa-link"></i></a>8. 直接内存</h2>
      
        <h3 id="8-1-作用"   >
          <a href="#8-1-作用" class="heading-link"><i class="fas fa-link"></i></a>8.1 作用</h3>
      <p>是一种操作系统的内存，可以通过NIO中的directBuffer对象来实现内存调用的效率提高</p>
<p>直接用buffer调用需要通过系统缓冲区和Java缓冲区，而directMomery可以直接访问</p>

        <h3 id="8-2-特点"   >
          <a href="#8-2-特点" class="heading-link"><i class="fas fa-link"></i></a>8.2 特点</h3>
      <ol>
<li>分配回收成本高，读写性能高</li>
<li>和系统内存相关，和java本身堆大小无关</li>
</ol>

        <h3 id="8-3-内存释放"   >
          <a href="#8-3-内存释放" class="heading-link"><i class="fas fa-link"></i></a>8.3 内存释放</h3>
      <p>通过unsafe对象对于directMomery对象的调用</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>类结构和类加载</title>
    <url>/post/24714/</url>
    <content><![CDATA[
        <h1 id="1-类文件结构"   >
          <a href="#1-类文件结构" class="heading-link"><i class="fas fa-link"></i></a>1. 类文件结构</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="1-1-魔数-amgic"   >
          <a href="#1-1-魔数-amgic" class="heading-link"><i class="fas fa-link"></i></a>1.1 魔数(amgic)</h2>
      <p>唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。即进行<strong>类型识别</strong>。使用魔数而不使用文件拓展名是为了安全考虑。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u4             magic; <span class="comment">//Class 文件的标志</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-2-版本号-minor-version-amp-major-version"   >
          <a href="#1-2-版本号-minor-version-amp-major-version" class="heading-link"><i class="fas fa-link"></i></a>1.2 版本号(minor_version &amp; major_version)</h2>
      <p>高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">u2             major_version;<span class="comment">//Class 的大版本号</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-3-常量池"   >
          <a href="#1-3-常量池" class="heading-link"><i class="fas fa-link"></i></a>1.3 常量池</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></table></div></figure>
<p><code>constant_pool_count</code>表示常量池的容量，索引从1开始，到他的数量-1.第0项常量表示不引用任何常量，默认为空。</p>
<blockquote>
<p>0x0016：表示为十进制是22，表示有21个常量，索引从1-21<br>主要存放两类常量：字面量和符号引用<br>每一项常量都是一个表，表开始是u1类型的标志位。<br><img src="/images/1bcc0033df92b50d7db8ef484f54e88.png"></p>
</blockquote>

        <h2 id="1-4-访问标志"   >
          <a href="#1-4-访问标志" class="heading-link"><i class="fas fa-link"></i></a>1.4 访问标志</h2>
      <p>识别类或接口层次的访问消息。<br><img src="/images/ca3c4e7fd521b481e238d400f9a4757.png"></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-5-类索引，父类索引和接口索引集合"   >
          <a href="#1-5-类索引，父类索引和接口索引集合" class="heading-link"><i class="fas fa-link"></i></a>1.5 类索引，父类索引和接口索引集合</h2>
      <p>当前类要设置全限名，所有的都有父类，除了java.lang.Object，接口可以多实现。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">u2             super_class;<span class="comment">//父类</span></span><br><span class="line">u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="1-6-字段表集合"   >
          <a href="#1-6-字段表集合" class="heading-link"><i class="fas fa-link"></i></a>1.6 字段表集合</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">field_info     fields[fields_count];<span class="comment">//一个类会可以有多个字段</span></span><br></pre></td></tr></table></div></figure>
<p>字段表格式：</p>
<ul>
<li><code>access_flags</code>: 字段的作用域（public ,private,protected修饰符），是实例变量还是类变量（static修饰符）,可否被序列化（transient 修饰符）,可变性（final）,可见性（volatile 修饰符，是否强制从主内存读写）。</li>
<li><code>name_index</code>: 对常量池的引用，表示的字段的名称；</li>
<li><code>descriptor_index</code>: 对常量池的引用，表示字段和方法的描述符；</li>
<li><code>attributes_count</code>: 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><code>attributes[attributes_count]</code>: 存放具体属性具体内容。<br>字段表标志位：<br><img src="/images/ba74348c5a074791abadabda1534dbf3.png"></li>
</ul>

        <h2 id="1-7-方法表集合"   >
          <a href="#1-7-方法表集合" class="heading-link"><i class="fas fa-link"></i></a>1.7 方法表集合</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></table></div></figure>
<p>方法表结构：<br><img src="/images/4efb6101e08445499f2faf59f34963f4.png"><br>方法表标志位：<br><img src="/images/d8137412775c419b948902e79dee14da.png"></p>

        <h1 id="2-类加载机制"   >
          <a href="#2-类加载机制" class="heading-link"><i class="fas fa-link"></i></a>2. 类加载机制</h1>
      <p>类的生命周期：<br><img src="/images/b724a4d759f8f67fbdac422a0eac658.png"><br>类加载的时机：</p>
<ul>
<li>创建类的实例，也就是<code>new</code>一个对象。</li>
<li>访问类的静态方法或者静态变量（包含静态变量赋值）。</li>
<li>使用<code>Class.forName()</code>反射类。</li>
<li>子类初始化的时候。</li>
<li>JVM启动时标明的启动类。</li>
</ul>

        <h2 id="2-1-加载"   >
          <a href="#2-1-加载" class="heading-link"><i class="fas fa-link"></i></a>2.1 加载</h2>
      <ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个流的静态存储结构转换为方法区运行时数据结构。</li>
<li>生成一个Class对象<br>jvm是<strong>懒加载</strong>，所以只有使用到类时才会加载，例如调用类的main()方法，new对象等等 ，主类在运行过程中如果使用到其它类，会逐步加载这些类。</li>
</ol>

        <h2 id="2-2-验证"   >
          <a href="#2-2-验证" class="heading-link"><i class="fas fa-link"></i></a>2.2 验证</h2>
      <ul>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ul>

        <h2 id="2-3-准备"   >
          <a href="#2-3-准备" class="heading-link"><i class="fas fa-link"></i></a>2.3 准备</h2>
      <p>为类中定义的变量(被<code>static</code>修饰过的变量)分配内存并设置类变量初始值。此阶段不包含实例变量的赋值。</p>

        <h2 id="2-4-解析"   >
          <a href="#2-4-解析" class="heading-link"><i class="fas fa-link"></i></a>2.4 解析</h2>
      <p>将符号引用转换为直接引用。</p>
<ul>
<li>符号引用： 描述对象，包括如下三种：<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符</li>
<li>直接引用：<br>变量有一个内存地址来标识，如果我们用一个指针指向这个内存地址，这个指针就是直接引用。<br>等我们需要用到这个变量的时候，就可以直接通过指针指向的地址找到。<br>而我们在加载类的时候，解析代码并指向内存某个地址，然后将符号引用 obj和这个内存地址进行映射的过程，就是解析这个步骤要做的事，也叫做符号引用转换为直接引用。</li>
</ul>

        <h2 id="2-5-初始化"   >
          <a href="#2-5-初始化" class="heading-link"><i class="fas fa-link"></i></a>2.5 初始化</h2>
      <p>（1）对类的静态变量初始化为指定的值<br><code>int initData = 666</code><br>（2）执行静态代码块<br><code>&lt;clinit&gt;()</code></p>

        <h1 id="3-类加载器"   >
          <a href="#3-类加载器" class="heading-link"><i class="fas fa-link"></i></a>3. 类加载器</h1>
      
        <h2 id="3-1-类加载器的种类"   >
          <a href="#3-1-类加载器的种类" class="heading-link"><i class="fas fa-link"></i></a>3.1 类加载器的种类</h2>
      <p><img src="/images/47266cb826c74981b21ded13641ed666.png"></p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：负责加载Java类的核心类(<code>&lt;JAVA_HOME&gt;\lib</code>目录下，能被<code>-Xbootclasspath</code>参数所指定路径存放的)，是用C++代码实现的，无法被java代码直接引用。</li>
<li>扩展类加载器（Extensions ClassLoader）：负责加载JRE的扩展目录lib&#x2F;ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为Null。</li>
<li>应用程序类加载器（Application ClassLoader）： 负责加载用户类路径 classpath 上所有的 jar 包和 .class 文件。</li>
</ul>

        <h2 id="3-2-双亲委派模型"   >
          <a href="#3-2-双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a>3.2 双亲委派模型</h2>
      <p>工作过程：<br>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的夹杂请求最终都应该传送到顶层的启动类加载器中，只有父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。<br>简而言之：<font color=red>自下而上请求，自上而下加载</font><br>优势：<br>父类加载器成功加载则返回，子类加载器不会再加载，防止了重复加载。<br>防止核心API库被随意篡改。比如有一个要加载java.lang.Integer类的请求，通过双亲委派进制加载传递到启动类加载器，在在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，可以防止核心API被随意篡改。</p>
<p><a href="/images.classAll.png"></a></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/post/10764/</url>
    <content><![CDATA[
        <h1 id="1-树"   >
          <a href="#1-树" class="heading-link"><i class="fas fa-link"></i></a>1. 树</h1>
      
        <h2 id="1-1-树的基本概念"   >
          <a href="#1-1-树的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.1 树的基本概念</h2>
      <p>定义：除了根节点，每个节点有且仅有一个前驱<br>基本术语：</p>
<ul>
<li>节点：树上的一个个元素，包含数据元素和指向子树的指针</li>
<li>节点的度： 节点的子树个数</li>
<li>树的度： 树中各节点的度的最大值</li>
<li>叶子节点： 又称<strong>终端节点</strong>，指度为0的节点</li>
<li>分支节点： 又称<strong>非终端节点</strong>，指度不为0的节点</li>
<li>孩子： 节点的子树的根</li>
<li>双亲： 孩子的上一个节点</li>
<li>兄弟： 同一个双亲的孩子之间互为兄弟</li>
<li>祖先： 根到某节点路径上的所有节点，都是这个节点的祖先</li>
<li>层次：根为第一层，往下为第二层</li>
<li>高度：树中节点的最大层次</li>
</ul>

        <h2 id="1-2-树的存储结构"   >
          <a href="#1-2-树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>1.2 树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>浪费空间，一般不使用</li>
<li>链式存储结构</li>
</ol>
<ul>
<li>孩子存储结构</li>
<li>双亲存储结构</li>
<li>孩子兄弟存储结构</li>
</ul>

        <h1 id="2-二叉树"   >
          <a href="#2-二叉树" class="heading-link"><i class="fas fa-link"></i></a>2. 二叉树</h1>
      <p>定义：<br>每个节点最多只能有两个子树，即每个子树的度为0，1，2<br>且有左右之分，不能颠倒</p>

        <h2 id="2-1-二叉树的主要性质"   >
          <a href="#2-1-二叉树的主要性质" class="heading-link"><i class="fas fa-link"></i></a>2.1 二叉树的主要性质</h2>
      <ol>
<li>非空二叉树上叶子节点数等于双分支节点数加1<br>即：<code>n0 = n2 + 1</code><br>证明：设二叉树上叶子节点数为n0，单分支节点数为n1，双分支节点数为n2；<br>则总结点数为<code>n0+n1+n2</code><br>总分支数为<code>n1+2n2</code><br>根据总分支数&#x3D;总节点数-1，有<code>n0+n1+n2-1 = n1+2n2</code><br>化简后得到：<code>n0 = n2 + 1</code></li>
<li>二叉树上的第i层最多有<code>2^(i-1)</code>个节点</li>
<li>高度为h的二叉树最多有<code>2^h - 1</code>个节点</li>
<li>在有n个节点的完全二叉树下，如果i为某节点的编号，那么有</li>
</ol>
<ul>
<li>i&#x2F;2（向下取整）为其双亲的节点编号</li>
<li>2i为其左孩子编号，2i+1为其右孩子编号(若&gt;n,那么无左右孩子)</li>
</ul>
<ol start="5">
<li>具有n个节点的完全二叉树的高度为log2 n + 1(向下取整)</li>
</ol>

        <h2 id="2-2-二叉树的存储结构"   >
          <a href="#2-2-二叉树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.2 二叉树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>最适用于完全二叉树，适用于普通二叉树易导致浪费存储空间</li>
<li>链式存储结构<br>用一个节点和两个树之间的关系表示二叉树的链式存储结构<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    Elemtype data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchlid;  <span class="comment">//左指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchlid;  <span class="comment">//右指针域</span></span><br><span class="line">&#125;BTNode；</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h2 id="2-3-二叉树的遍历算法"   >
          <a href="#2-3-二叉树的遍历算法" class="heading-link"><i class="fas fa-link"></i></a>2.3 二叉树的遍历算法</h2>
      <ul>
<li>先序遍历(根 -&gt; 左 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>中序遍历(左 -&gt; 根 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>后序遍历(左 -&gt; 右 -&gt; 根)<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>层序遍历<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    BTNode *queue[maxSize];</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">        queue[rear] = p;</span><br><span class="line">        <span class="keyword">while</span>(front != rear) &#123;</span><br><span class="line">            front = (front + <span class="number">1</span>)% maxSize;</span><br><span class="line">            q = queue[front];</span><br><span class="line">            <span class="built_in">visit</span>(q);</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="2-4-线索二叉树"   >
          <a href="#2-4-线索二叉树" class="heading-link"><i class="fas fa-link"></i></a>2.4 线索二叉树</h2>
      <p>节点定义：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;  <span class="comment">//线索标记，判断是子树还是线索</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *rchild;</span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></div></figure>

<p>中序遍历线索二叉树算法：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != null) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p -&gt; lchild, pre); <span class="comment">// 递归，左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p -&gt; lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立当前节点的前驱线索</span></span><br><span class="line">            p -&gt; lchild = pre;</span><br><span class="line">            p -&gt; ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre -&gt; rchlid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立前驱节点的后继线索</span></span><br><span class="line">            p -&gt; rchild = p;</span><br><span class="line">            p -&gt; rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;rchlid;</span><br><span class="line">        <span class="built_in">InThread</span>(p,pre); <span class="comment">// 递归，右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInThread</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">    TBTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(root, pre);</span><br><span class="line">        pre -&gt; rchild = null;  <span class="comment">//非空二叉树线索化</span></span><br><span class="line">        pre -&gt; rtag = <span class="number">1</span>;   <span class="comment">// 处理中序最后一个节点 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-5-树和二叉树的应用"   >
          <a href="#2-5-树和二叉树的应用" class="heading-link"><i class="fas fa-link"></i></a>2.5 树和二叉树的应用</h2>
      
        <h3 id="2-5-1-二叉排序树-BTS"   >
          <a href="#2-5-1-二叉排序树-BTS" class="heading-link"><i class="fas fa-link"></i></a>2.5.1 二叉排序树(BTS)</h3>
      
        <h4 id="2-5-1-1-定义"   >
          <a href="#2-5-1-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.1 定义</h4>
      <ol>
<li>若其左子树不为空，则左子树上所有关键字的值均不大于根关键字的值；</li>
<li>若其右子树不为空，则右子树上所有关键字的值均不小于根关键字的值；</li>
<li>每个根节点下的子树都满足此规则</li>
</ol>

        <h4 id="2-5-1-2-存储结构"   >
          <a href="#2-5-1-2-存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.2 存储结构</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-查找"   >
          <a href="#2-5-1-3-查找" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 查找</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BSTSearch</span><span class="params">(BTNode* bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> bt;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-插入"   >
          <a href="#2-5-1-3-插入" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 插入</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSTInsert</span><span class="params">(BTNode* &amp;bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到插入位置，创建新节点并插入</span></span><br><span class="line">    <span class="keyword">if</span>(bt == null) &#123;</span><br><span class="line">        bt = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode)); <span class="comment">//创建新节点</span></span><br><span class="line">        bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt-&gt;key = key;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//节点不为空，查找插入位置，和查找算法类似</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 已经存在值，不用插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-4-构造"   >
          <a href="#2-5-1-4-构造" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.4 构造</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBTS</span><span class="params">(BTNode *&amp;bt, <span class="type">int</span> key[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一棵空树</span></span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 逐个插入节点</span></span><br><span class="line">        <span class="built_in">BSTInsert</span>(bt, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-5-删除"   >
          <a href="#2-5-1-5-删除" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.5 删除</h4>
      <ol>
<li>p节点为叶子节点，直接删除</li>
<li>p节点只有左子树或者右子树，直接删除，将子树与原来双亲节点连接即可</li>
<li>p节点既有左子树又有右子树，将其直接前驱(或后继)作为双亲节点的连接点</li>
</ol>

        <h3 id="2-5-2-平衡二叉树-AVL树"   >
          <a href="#2-5-2-平衡二叉树-AVL树" class="heading-link"><i class="fas fa-link"></i></a>2.5.2 平衡二叉树(AVL树)</h3>
      
        <h4 id="2-5-2-1-定义"   >
          <a href="#2-5-2-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.1 定义</h4>
      <p>是一种特殊的二叉排序树，其左右子树高度的差的绝对值不超过1；其考点主要为平衡调整，共有LL, RR, LR, RL四种类型</p>

        <h4 id="2-5-2-2-LL"   >
          <a href="#2-5-2-2-LL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.2 LL</h4>
      <ol>
<li>当前操作节点是A （A这个节点是最小失衡树的根节点)</li>
<li>断开该节点的根节点的左孩子连接线 (此时变成了两棵树，设以A为根节点的树为原根树，以B为根节点的树为新根树)</li>
<li>判断新根树的根节点的右子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的右子树。</li>
<li>若不空:<br>– 将新根树的根节点的右子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的左子树。<br>– 把原根树作为新根树的右子树。</li>
</ul>

        <h4 id="2-5-2-3-RR"   >
          <a href="#2-5-2-3-RR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.3 RR</h4>
      <ol>
<li>当前操作节点是66 （66这个节点是最小失衡树的根节点)</li>
<li>断开该节点的右孩子连接线 (此时变成了两棵树，设以66为根节点的树为原根树，以77为根节点的树为新根树)</li>
<li>判断新根树的根节点的左子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的左子树。</li>
<li>若不空:<br>– 将新根树的根节点的左子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的右子树。<br>– 把原根树作为新根树的左子树。</li>
</ul>

        <h4 id="2-5-2-4-LR"   >
          <a href="#2-5-2-4-LR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.4 LR</h4>
      <p>先左旋，再右旋</p>

        <h4 id="2-5-2-5-RL"   >
          <a href="#2-5-2-5-RL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.5 RL</h4>
      <p>先右旋，再左旋</p>

        <h3 id="2-5-3-哈夫曼树与哈夫曼编码"   >
          <a href="#2-5-3-哈夫曼树与哈夫曼编码" class="heading-link"><i class="fas fa-link"></i></a>2.5.3 哈夫曼树与哈夫曼编码</h3>
      
        <h3 id="2-5-4-并查集"   >
          <a href="#2-5-4-并查集" class="heading-link"><i class="fas fa-link"></i></a>2.5.4 并查集</h3>
      
        <h3 id="2-5-5-红黑树"   >
          <a href="#2-5-5-红黑树" class="heading-link"><i class="fas fa-link"></i></a>2.5.5 红黑树</h3>
      
        <h4 id="2-5-5-1-性质"   >
          <a href="#2-5-5-1-性质" class="heading-link"><i class="fas fa-link"></i></a>2.5.5.1 性质</h4>
      <ol>
<li>节点包含红黑信息，根节点是黑色</li>
<li>所有叶子节点都是黑色，标记为NIL节点</li>
<li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql基础知识</title>
    <url>/post/15761/</url>
    <content><![CDATA[
        <h2 id="mysql的执行过程"   >
          <a href="#mysql的执行过程" class="heading-link"><i class="fas fa-link"></i></a>mysql的执行过程</h2>
      
        <h3 id="连接器"   >
          <a href="#连接器" class="heading-link"><i class="fas fa-link"></i></a>连接器</h3>
      <p>首先需要先登录账号密码，使mysql服务器和客户端进行连接，一个服务器可以连接多个客户端，和HTTP一样，连接都需要经过三次握手，都有默认开启长连接以节约多次请求反复连接带来的性能损耗。</p>

        <h3 id="查询缓存"   >
          <a href="#查询缓存" class="heading-link"><i class="fas fa-link"></i></a>查询缓存</h3>
      <p>这是mysql5.7的功能，到mysql8.0被废弃了。原因是因为缓存的使用效率极低，在一个频繁需要更新的表中，每进行更新一次，缓存就会全部清除，不管更新的和你缓存中的字段的关系大不大。所以mysql中查询缓存的命中率极低。在mysql8.0被废除。</p>
<p>mysql5.7查询缓存的主要流程为先判断客户端发送的sql语句的第一个关键字段，如果是<code>select</code>才进行查询缓存的操作，若不是则进行接下来的后续操作。缓存会以<code>(key, value)</code>记录先前的查询的sql语句以及查询的结果，如果缓存命中了，则直接返回其<code>value</code>值。如果查询不到缓存，则查询后将查询结果加入缓存中。</p>

        <h3 id="解析器"   >
          <a href="#解析器" class="heading-link"><i class="fas fa-link"></i></a>解析器</h3>
      <ul>
<li>词法解析<br>  mysql会分析sql语句，将每一个字段构建成为语法树。方便后续获取表名称，字段名称，where查询条件等。 </li>
<li>语法分析<br>  根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。<br>  如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我把 from 写成了 form，这时 MySQL 解析器就会给报错。<br>  此时报错仅仅是sql关键字的鉴别报错，如果输入了不存在的表名或者字段名时，在此阶段不会报错</li>
</ul>

        <h3 id="预处理器"   >
          <a href="#预处理器" class="heading-link"><i class="fas fa-link"></i></a>预处理器</h3>
      <ul>
<li>判断语法树中的字段在表中字段中是否存在</li>
<li>将所有的<code>*</code> 解析为表中的所有字段</li>
</ul>

        <h3 id="优化器"   >
          <a href="#优化器" class="heading-link"><i class="fas fa-link"></i></a>优化器</h3>
      <p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong></p>
<p>这一部分主要是索引的优化，sql优化器会通过对比，选择出主键索引，联合索引，二级索引中执行效率最高的方式，并在后面执行器中执行。</p>

        <h3 id="执行器"   >
          <a href="#执行器" class="heading-link"><i class="fas fa-link"></i></a>执行器</h3>
      <ul>
<li>主键索引查询</li>
<li>全表扫描</li>
<li>索引下推</li>
</ul>
<p>通过遍历的方式进行执行(while循环)，先去逐条查询所有的语句，之后再与条件进行对比，如果匹配条件的话，则将其加入结果集中，如果不匹配条件的话，则进行下一条的筛选，直至表中的字段被筛选结束。</p>
<p>没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，进行二次判断</p>
<ul>
<li>存储引擎定位到二级索引后，<strong>先不执行回表</strong>操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果<strong>条件不成立</strong>，则直接<strong>跳过该二级索引</strong>。如果<strong>成立</strong>，则<strong>执行回表</strong>操作，将完成记录返回给 Server 层。</li>
</ul>
<p>所以我们可以认为，索引下推使用到了联合索引的特性，将联合索引中另一个索引的值在存储引擎层就已经进行查询了。</p>

        <h2 id="mysql记录存储结构"   >
          <a href="#mysql记录存储结构" class="heading-link"><i class="fas fa-link"></i></a>mysql记录存储结构</h2>
      
        <h3 id="mysql数据存储文件"   >
          <a href="#mysql数据存储文件" class="heading-link"><i class="fas fa-link"></i></a>mysql数据存储文件</h3>
      <p>一个表对应了三个文件对数据库进行存储：</p>
<figure class="highlight shell"><div class="table-container"><table><tr><td class="code"><pre><span class="line">db.opt  </span><br><span class="line">t_order.frm  </span><br><span class="line">t_order.ibd</span><br></pre></td></tr></table></div></figure>



<ul>
<li><code>.opt</code> 文件是对于文件字符集和默认字符校验规则的规定</li>
<li><code>.frm</code>文件是对于对<strong>表结构</strong>格式的存储，存储的是表结构的元数据，如列名，表名，存储引擎等基本数据结构。</li>
<li><code>.ibd</code>文件是对于<strong>表数据</strong>的存储。</li>
</ul>

        <h3 id="表空间文件结构"   >
          <a href="#表空间文件结构" class="heading-link"><i class="fas fa-link"></i></a>表空间文件结构</h3>
      <p>从小到大，依次为段(<strong>segment</strong>) &gt; 区(<strong>entend</strong>) &gt; 页(<strong>page</strong>) &gt; 行(<strong>row</strong>)</p>

        <h4 id="行"   >
          <a href="#行" class="heading-link"><i class="fas fa-link"></i></a>行</h4>
      <p>其中，行为最小的存储结构，可以看作对应的是表中的每个对象，一个对象即为一行，一行的大小规定最大为<code>65535</code>个字节，初始化定义的时候超过该大小则会报错。</p>

        <h4 id="页"   >
          <a href="#页" class="heading-link"><i class="fas fa-link"></i></a>页</h4>
      <p>但是数据表的读取和写入不以行为单位，为了避免传输的时候资源的浪费，以页为单位进行读取和写入，一页的大小为<code>16kb</code>，页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的</p>

        <h4 id="区"   >
          <a href="#区" class="heading-link"><i class="fas fa-link"></i></a>区</h4>
      <p>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了。</p>

        <h4 id="段"   >
          <a href="#段" class="heading-link"><i class="fas fa-link"></i></a>段</h4>
      <ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，事务隔离 (opens new window)介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>

        <h3 id="COMPACT行格式"   >
          <a href="#COMPACT行格式" class="heading-link"><i class="fas fa-link"></i></a>COMPACT行格式</h3>
      <ul>
<li><p>记录的额外信息 </p>
</li>
<li><ul>
<li>变长字段列表</li>
<li>Null值列表</li>
<li>记录头信息</li>
</ul>
</li>
<li><p>记录的真实数据 </p>
</li>
<li><ul>
<li>row_id</li>
<li>trx_id</li>
<li>roll_ptr</li>
</ul>
</li>
</ul>

        <h4 id="变长字段列表"   >
          <a href="#变长字段列表" class="heading-link"><i class="fas fa-link"></i></a>变长字段列表</h4>
      <p><code>char(n)</code>  和 <code>varchar(n)</code> 的区别为前者为不可变长的字符串类型，后者为可变长的字符串类型，后者的n表示的是该字符串允许的最大<strong>字符数</strong>。如果不存在可变长的类型，那么该额外信息字段将会被取消。存储的时候，存储的是其字符串的字符长度，比如存储<strong>aaa</strong>到 <code>varchar(256)</code> 的字段中，那么变长字段长度列表就会存储一个 <code>3</code> 。注意当出现多个可变长字段列表的时候，在表中的顺序越靠近左边的，在变长字段长度列表中存储的位置是靠右边的。这是因为记录头信息中有一个指针由该行指向下一行，他的位置是记录头信息的末尾，也就是接近真实数据和额外数据的分界线。那么他读取的时候，会左右都读，往左边读的时候可以理解成从后往前，所以变长字段长度列表从后往前进行记录也是符合底层存储引擎读取的顺序，能一定程度上提高性能。Null值列表也是同理的。</p>
<p>注意这里的n指的是字符数而不是字节数。比如在<code>ascii</code>字符集中，一个字符占一个字节，而在<code>UTF-8</code>字符集中，一个字符占了三个字节。</p>

        <h4 id="Null值列表"   >
          <a href="#Null值列表" class="heading-link"><i class="fas fa-link"></i></a>Null值列表</h4>
      <p>同理的，Null值列表也不是一定要存在的，其只有在某个或者某些字段规定允许为空的时候出现。所以我们平时设计数据库表的时候能设置非空就设置非空可以一定程度上节约数据库存储的额外性能。那么非空字段存储是通过二进制位来进行表示的，其非空字段必须为8的整数倍，高位用0补齐。如只有三个非空字段且其均为空，那么该行的非空字段可以表示为 <code>00000111</code>，注意，其也是逆序排序的。一行就是一个字节甚至根据非空字段的大小可能更多，所以尽可能的少用空字段。</p>
<p>当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推。</p>

        <h4 id="记录头信息"   >
          <a href="#记录头信息" class="heading-link"><i class="fas fa-link"></i></a>记录头信息</h4>
      <ul>
<li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>

        <h4 id="记录的真实数据"   >
          <a href="#记录的真实数据" class="heading-link"><i class="fas fa-link"></i></a>记录的真实数据</h4>
      <ul>
<li>row_id</li>
</ul>
<p>如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。</p>
<ul>
<li>trx_id</li>
</ul>
<p>事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。</p>
<ul>
<li>roll_pointer</li>
</ul>
<p>这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。</p>

        <h3 id="varchar-n-取值最大为多少"   >
          <a href="#varchar-n-取值最大为多少" class="heading-link"><i class="fas fa-link"></i></a>varchar(n) 取值最大为多少</h3>
      <p><strong>结论：varchar(n)中n的最大值为65533</strong></p>
<p>首先我们知道一行最大能承受的字节数为65535，那么n代表了字符数，我们以最小兑换比例1：1的ascii进行兑换，那么可以存储65535个字符，但是不是这样的，我们从上面 <strong>COMPACT行格式</strong> 中可以看出，字段中除了记录的真实数据，还有记录的额外信息，那么这些额外信息也需要占用一定的字节。我们在考虑可变长字符串的最大长度的时候就要将其考虑进去。那么可变长字符串有一个分界线为255字节，当其小于255时候，长度为1个字节，大于时长度为2字节。所以需要减去记录其长度的两个字节，那么就是65533了</p>
<p>如果当我们设置该字段为允许为空时，我们还需要考虑Null值列表。即使存储的数据字段不为空，那么也会存储0表示存储的是空值，以区分数据传输时候丢失和传入的值本来就为空。所以此时，需要加上一个字节。</p>
<p>当然，前面考虑的都是一行只有一个varchar(n)字段，当有多个字段的时候，能够存储的空间就更加小了。</p>
<p>记得有一道面试题，数据库一行能存储下一本小说吗？其实就是说的这个，短篇小说应该还是可以的，还得是英文小说，不然ascii字符集没有对应的中文就不好了。如果是中文小说，那么最多只能存储65533&#x2F;3的字节长度，也就是最多2w多字了。</p>

        <h3 id="行溢出后mysql如何处理"   >
          <a href="#行溢出后mysql如何处理" class="heading-link"><i class="fas fa-link"></i></a>行溢出后mysql如何处理</h3>
      <p>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/post/62546/</url>
    <content><![CDATA[
        <h1 id="事务的ACID的原则"   >
          <a href="#事务的ACID的原则" class="heading-link"><i class="fas fa-link"></i></a>事务的ACID的原则</h1>
      
        <h2 id="一致性-Consistency"   >
          <a href="#一致性-Consistency" class="heading-link"><i class="fas fa-link"></i></a>一致性(Consistency)</h2>
      <p>一致性放在最前面因为其实ACID是有逻辑关系的。一致性是其他三个性质的结果，其他三个性质都是为了一致性服务。一致性指的事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</p>

        <h2 id="隔离性-Isolation"   >
          <a href="#隔离性-Isolation" class="heading-link"><i class="fas fa-link"></i></a>隔离性(Isolation)</h2>
      <p>隔离性指的是事务和事务之间的关系。指的是每个事务之间都是独立的，可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。比如一个用户在执行对商品的购买的同时不会影响到其他用户对于商品的操作。</p>

        <h2 id="原子性-Atomacity"   >
          <a href="#原子性-Atomacity" class="heading-link"><i class="fas fa-link"></i></a>原子性(Atomacity)</h2>
      <p>原子性指的是一个事务内部之间的关系。原子性指的是该单位是不可分割的，要么全部执行成功，要么全部执行失败。也就是防止了因为意外情况数据库数据中止在中间状态。一旦执行到中间遇到意外事故，该条执行语句会选择回滚。</p>

        <h2 id="持久性-Durability"   >
          <a href="#持久性-Durability" class="heading-link"><i class="fas fa-link"></i></a>持久性(Durability)</h2>
      <p>持久性指的是数据库的语句一旦发生修改之后，该值就会持久的保留下来。</p>
<ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>

        <h1 id="并行事务引发的问题"   >
          <a href="#并行事务引发的问题" class="heading-link"><i class="fas fa-link"></i></a>并行事务引发的问题</h1>
      
        <h2 id="脏读"   >
          <a href="#脏读" class="heading-link"><i class="fas fa-link"></i></a>脏读</h2>
      <p>脏读指的是一个事务读取到了另一个事务正在修改但还未提交的数据。如果事务A在操作数据库的时候，执行成功了还未提交，这时突然发生错误了，数据进行回滚，但是事务B读取到了修改一半的数据。这个数据就不应该存在，那么我们说此时出现了脏读的情况。事务B读取到了一个不存在的数据。</p>

        <h2 id="不可重复读"   >
          <a href="#不可重复读" class="heading-link"><i class="fas fa-link"></i></a>不可重复读</h2>
      <p>指的是同一个事务两次读取的数据是不一样的。这个产生的原因主要在于读取的中间可能突然有另一个事务对于数据进行修改，那么这时候事务A读取的数据就不是原子性的了，前后读取的不一样就被称为不可重复读了。</p>

        <h2 id="幻读"   >
          <a href="#幻读" class="heading-link"><i class="fas fa-link"></i></a>幻读</h2>
      <p>幻读指的是同一个事务两次读取的数据条目数是不同的。这个和不可重复读产生的原因类似，都是两次读取操作没有保持原子性。但区别是不可重复读主要是针对于数据的内容，而幻读主要是针对于数据的条目数量。</p>

        <h1 id="事务的隔离级别"   >
          <a href="#事务的隔离级别" class="heading-link"><i class="fas fa-link"></i></a>事务的隔离级别</h1>
      
        <h2 id="读未提交（read-uncommitted）"   >
          <a href="#读未提交（read-uncommitted）" class="heading-link"><i class="fas fa-link"></i></a>读未提交（read uncommitted）</h2>
      <p>指一个事务还没提交时，它做的变更就能被其他事务看到；</p>

        <h2 id="读提交（read-committed）"   >
          <a href="#读提交（read-committed）" class="heading-link"><i class="fas fa-link"></i></a>读提交（read committed）</h2>
      <p>指一个事务提交之后，它做的变更才能被其他事务看到；</p>

        <h2 id="可重复读（repeatable-read）"   >
          <a href="#可重复读（repeatable-read）" class="heading-link"><i class="fas fa-link"></i></a>可重复读（repeatable read）</h2>
      <p>指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；</p>

        <h2 id="串行化（serializable-）"   >
          <a href="#串行化（serializable-）" class="heading-link"><i class="fas fa-link"></i></a>串行化（serializable ）</h2>
      <p>会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</p>

        <h1 id="Read-View-在-MVCC-里如何工作的？"   >
          <a href="#Read-View-在-MVCC-里如何工作的？" class="heading-link"><i class="fas fa-link"></i></a>Read View 在 MVCC 里如何工作的？</h1>
      <ul>
<li>针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li>
<li>针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
<p>Read View 有四个重要的字段：</p>
<ul>
<li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li>
<li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li>
<li>max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li>
<li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id。<img src="/%E4%BA%8B%E5%8A%A1.assets/1685543399796-f8c4babb-cc92-486a-ae56-fedb4af312bf.png" alt="img"></li>
</ul>
<p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p>
<ul>
<li><p>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。</p>
</li>
<li><p>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。</p>
</li>
<li><p>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：</p>
</li>
<li><ul>
<li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li>
<li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring_1</title>
    <url>/post/3701/</url>
    <content><![CDATA[
        <h2 id="Spring-day01"   >
          <a href="#Spring-day01" class="heading-link"><i class="fas fa-link"></i></a>Spring_day01</h2>
      <p><strong>今日目标</strong></p>
<blockquote>
<ul>
<li>掌握Spring相关概念</li>
<li>完成IOC&#x2F;DI的入门案例编写</li>
<li>掌握IOC的相关配置与使用</li>
<li>掌握DI的相关配置与使用</li>
</ul>
</blockquote>

        <h2 id="1，课程介绍"   >
          <a href="#1，课程介绍" class="heading-link"><i class="fas fa-link"></i></a>1，课程介绍</h2>
      <p>对于一门新技术，我们需要从<code>为什么要学</code>、<code>学什么</code>以及<code>怎么学</code>这三个方向入手来学习。那对于Spring来说:</p>

        <h3 id="1-1-为什么要学"   >
          <a href="#1-1-为什么要学" class="heading-link"><i class="fas fa-link"></i></a>1.1 为什么要学?</h3>
      <ul>
<li><p>从使用和占有率看</p>
<ul>
<li><p>Spring在市场的占有率与使用率高</p>
</li>
<li><p>Spring在企业的技术选型命中率高</p>
</li>
<li><p>所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;&#x3D;&#x3D;90%&#x3D;&#x3D;</p>
<p><img src="/images/image-20210729171139088.png"></p>
<p><strong>说明</strong>:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。</p>
</li>
</ul>
</li>
<li><p>从专业角度看</p>
<ul>
<li>随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决?<ul>
<li>Spring可以&#x3D;&#x3D;简化开发&#x3D;&#x3D;，降低企业级开发的复杂性，使开发变得更简单快捷</li>
</ul>
</li>
<li>随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作?<ul>
<li>Spring可以&#x3D;&#x3D;框架整合&#x3D;&#x3D;，高效整合其他技术，提高企业级应用开发与运行效率</li>
</ul>
</li>
</ul>
<p>综上所述，&#x3D;&#x3D;Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-2-学什么"   >
          <a href="#1-2-学什么" class="heading-link"><i class="fas fa-link"></i></a>1.2 学什么?</h3>
      <p>从上面的介绍中，我们可以看到Spring框架主要的优势是在<code>简化开发</code>和<code>框架整合</code>上，至于如何实现就是咱们要学习Spring框架的主要内容:</p>
<ul>
<li><p>简化开发: Spring框架中提供了两个大的核心技术，分别是:</p>
<ul>
<li>&#x3D;&#x3D;IOC&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP&#x3D;&#x3D;<ul>
<li>&#x3D;&#x3D;事务处理&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p> 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。</p>
<p> 2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。</p>
</li>
<li><p>框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:</p>
<ul>
<li>&#x3D;&#x3D;MyBatis&#x3D;&#x3D;</li>
<li>MyBatis-plus</li>
<li>Struts</li>
<li>Struts2</li>
<li>Hibernate</li>
<li>……</li>
</ul>
<p>这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。</p>
<p>综上所述，对于Spring的学习，主要学习四块内容:</p>
<p>&#x3D;&#x3D;(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-3-怎么学"   >
          <a href="#1-3-怎么学" class="heading-link"><i class="fas fa-link"></i></a>1.3 怎么学?</h3>
      <ul>
<li>学习Spring框架设计思想<ul>
<li>对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的<code>思想</code>上。</li>
</ul>
</li>
<li>学习基础操作，思考操作与思想间的联系<ul>
<li>掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系</li>
</ul>
</li>
<li>学习案例，熟练应用操作的同时，体会思想<ul>
<li>会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。</li>
</ul>
</li>
</ul>
<p>介绍完<code>为什么要学</code>、<code>学什么</code>和<code>怎么学</code>Spring框架后，大家需要重点掌握的是:</p>
<ul>
<li>Spring很优秀，需要认真重点的学习</li>
<li>Spring的学习主线是IOC、AOP、声明式事务和整合MyBais</li>
</ul>
<p>接下来，咱们就开始进入Spring框架的学习。</p>

        <h2 id="2，Spring相关概念"   >
          <a href="#2，Spring相关概念" class="heading-link"><i class="fas fa-link"></i></a>2，Spring相关概念</h2>
      
        <h3 id="2-1-初识Spring"   >
          <a href="#2-1-初识Spring" class="heading-link"><i class="fas fa-link"></i></a>2.1 初识Spring</h3>
      <p>在这一节，主要通过以下两个点来了解下Spring:</p>

        <h4 id="2-1-1-Spring家族"   >
          <a href="#2-1-1-Spring家族" class="heading-link"><i class="fas fa-link"></i></a>2.1.1 Spring家族</h4>
      <ul>
<li><p>官网：<a href="https://spring.io，从官网我们可以大概了解到：">https://spring.io，从官网我们可以大概了解到：</a></p>
<ul>
<li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li>
<li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li>
</ul>
</li>
<li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p>
<ul>
<li><p>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</p>
</li>
<li><p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图所示</p>
<p><img src="/images/image-20210729171850181.png"></p>
<p><strong>说明:</strong></p>
<p>图中的图标都代表什么含义，可以进入<code>https://spring.io/projects</code>网站进行对比查看。</p>
<p>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p>
<p><img src="/images/1629714811435.png"></p>
<ul>
<li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li>
<li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li>
<li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li>
</ul>
<p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="2-1-2-了解Spring发展史"   >
          <a href="#2-1-2-了解Spring发展史" class="heading-link"><i class="fas fa-link"></i></a>2.1.2 了解Spring发展史</h4>
      <p> 接下来我们介绍下Spring Framework这个技术是如何来的呢?</p>
<p><img src="/images/image-20210729171926576.png"></p>
<p>Spring发展史</p>
<ul>
<li>IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。</li>
<li>Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的<code>Expert One-on-One J2EE Design and Development</code>,书中有阐述在开发中使用EJB该如何做。</li>
<li>Rod Johnson在2004年出版的<code>Expert One-on-One J2EE Development without EJB</code>,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。</li>
<li>随着时间推移，版本不断更新维护，目前最新的是Spring5<ul>
<li>Spring1.0是纯配置文件开发</li>
<li>Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式</li>
<li>Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主</li>
<li>Spring4.0根据JDK的版本升级对个别API进行了调整</li>
<li>Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版</li>
</ul>
</li>
</ul>
<p>本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是:</p>
<ul>
<li>今天所学的Spring其实是Spring家族中的Spring Framework</li>
<li>Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础</li>
</ul>

        <h3 id="2-2-Spring系统架构"   >
          <a href="#2-2-Spring系统架构" class="heading-link"><i class="fas fa-link"></i></a>2.2 Spring系统架构</h3>
      <p>前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?</p>
<p>针对这些问题，我们将从<code>系统架构图</code>和<code>课程学习路线</code>来进行说明:</p>

        <h4 id="2-2-1-系统架构图"   >
          <a href="#2-2-1-系统架构图" class="heading-link"><i class="fas fa-link"></i></a>2.2.1 系统架构图</h4>
      <ul>
<li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p>
</li>
<li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p>
<p><img src="/images/image-20210729172153796.png"></p>
</li>
<li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p>
<p><img src="/images/1629720945720.png"></p>
<p>(1)核心层</p>
<ul>
<li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li>
</ul>
<p>(2)AOP层</p>
<ul>
<li>AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D;</li>
<li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li>
</ul>
<p>(3)数据层</p>
<ul>
<li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li>
<li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li>
<li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li>
</ul>
<p>(4)Web层</p>
<ul>
<li>这一层的内容将在SpringMVC框架具体学习</li>
</ul>
<p>(5)Test层</p>
<ul>
<li>Spring主要整合了Junit来完成单元测试和集成测试</li>
</ul>
</li>
</ul>

        <h4 id="2-2-2-课程学习路线"   >
          <a href="#2-2-2-课程学习路线" class="heading-link"><i class="fas fa-link"></i></a>2.2.2 课程学习路线</h4>
      <p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p>
<ul>
<li>&#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;Spring的AOP&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D;</li>
</ul>
<p><img src="/images/1629722300996.png"></p>
<p>对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。</p>

        <h3 id="2-3-Spring核心概念"   >
          <a href="#2-3-Spring核心概念" class="heading-link"><i class="fas fa-link"></i></a>2.3 Spring核心概念</h3>
      <p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p>

        <h4 id="2-3-1-目前项目中的问题"   >
          <a href="#2-3-1-目前项目中的问题" class="heading-link"><i class="fas fa-link"></i></a>2.3.1 目前项目中的问题</h4>
      <p>一个概念的提出，总是因为有对应的问题需要去解决，那么我们就需要先分析下目前咱们代码在编写过程中遇到的问题:</p>
<p><img src="/images/1629723232339.png"></p>
<p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p>
<p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p>
<p>(3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D; <strong>耦合度偏高</strong> &#x3D;&#x3D;</p>
<p>针对这个问题，该如何解决呢?</p>
<p><img src="/images/1629724206002.png"></p>
<p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p>
<p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p>
<p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p>
<p>针对这个问题，Spring就提出了一个解决方案:</p>
<ul>
<li>使用对象时，<mark>在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象</mark></li>
</ul>
<p>这种实现思就是Spring的一个核心概念</p>

        <h4 id="2-3-2-IOC、IOC容器、Bean、DI"   >
          <a href="#2-3-2-IOC、IOC容器、Bean、DI" class="heading-link"><i class="fas fa-link"></i></a>2.3.2 IOC、IOC容器、Bean、DI</h4>
      <ol>
<li>&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;</li>
</ol>
<p>(1)什么是控制反转呢？</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li>
<li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li>
<li>这种思想就是控制反转</li>
<li>别人[外部]指定是什么呢?继续往下学</li>
</ul>
</li>
</ul>
<p>(2)Spring和IOC之间的关系是什么呢?</p>
<ul>
<li>Spring技术对IOC思想进行了<strong>实现</strong></li>
<li>Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部”， IOC容器是IOC思想的具体实现</li>
<li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li>
</ul>
<p>(3)IOC容器的作用以及内部存放的是什么?</p>
<ul>
<li>IOC容器<strong>负责对象的创建</strong>、初始化等一系列工作，其中包含了数据层和业务层的类对象</li>
<li>被创建或被管理的<strong>对象</strong>在IOC容器中统称为**&#x3D;&#x3D;Bean&#x3D;&#x3D;**</li>
<li>IOC容器中放的就是一个个的Bean对象</li>
</ul>
<p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p>
<ul>
<li>不行，因为service运行需要依赖dao对象</li>
<li>IOC容器中虽然有service和dao对象</li>
<li>但是service对象和dao对象没有任何关系</li>
<li>需要把dao对象交给service,也就是说要<strong>绑定service和dao对象之间的关系</strong></li>
</ul>
<p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p>
<ol start="2">
<li>&#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D;</li>
</ol>
<p><img src="/images/1629735078619.png"></p>
<p>(1)什么是依赖注入呢?</p>
<ul>
<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li>
<li>这种思想就是依赖注入</li>
</ul>
</li>
</ul>
<p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p>
<ul>
<li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li>
</ul>
<p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠:</p>
<ul>
<li>使用IOC容器管理bean（IOC)</li>
<li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li>
<li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li>
</ul>

        <h4 id="2-3-3-核心概念小结"   >
          <a href="#2-3-3-核心概念小结" class="heading-link"><i class="fas fa-link"></i></a>2.3.3 核心概念小结</h4>
      <p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p>
<p>(1)什么IOC&#x2F;DI思想?</p>
<ul>
<li>IOC:控制反转，控制反转的是对象的创建权</li>
<li>DI:依赖注入，绑定对象与对象之间的依赖关系</li>
</ul>
<p>(2)什么是IOC容器?</p>
<p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p>
<p>(3)什么是Bean?</p>
<p>容器中所存放的一个个对象就叫Bean或Bean对象</p>

        <h2 id="3，入门案例"   >
          <a href="#3，入门案例" class="heading-link"><i class="fas fa-link"></i></a>3，入门案例</h2>
      <p>介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p>

        <h3 id="3-1-IOC入门案例"   >
          <a href="#3-1-IOC入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.1 IOC入门案例</h3>
      <p>对于入门案例，我们得先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-1-1-入门案例思路分析"   >
          <a href="#3-1-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.1.1 入门案例思路分析</h4>
      <p>(1)Spring是使用容器来管理bean对象的，那么管什么? </p>
<ul>
<li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li>
</ul>
<p>(2)如何将被管理的对象告知IOC容器?</p>
<ul>
<li>使用配置文件</li>
</ul>
<p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p>
<ul>
<li>Spring框架提供相应的接口</li>
</ul>
<p>(4)IOC容器得到后，如何从容器中获取bean?</p>
<ul>
<li>调用Spring框架提供对应接口中的方法</li>
</ul>
<p>(5)使用Spring导入哪些坐标?</p>
<ul>
<li>用别人的东西，就需要在pom.xml添加对应的依赖</li>
</ul>

        <h4 id="3-1-2-入门案例代码实现"   >
          <a href="#3-1-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.1.2 入门案例代码实现</h4>
      <blockquote>
<p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p>
<p>1.创建Maven的java项目</p>
<p>2.pom.xml添加Spring的依赖jar包</p>
<p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<p>4.resources下添加spring配置文件，并完成bean的配置</p>
<p>5.使用Spring提供的接口完成IOC容器的创建</p>
<p>6.从容器中获取对象进行方法调用</p>
</blockquote>

        <h5 id="步骤1-创建Maven项目"   >
          <a href="#步骤1-创建Maven项目" class="heading-link"><i class="fas fa-link"></i></a>步骤1:创建Maven项目</h5>
      <p><img src="/images/1629734010072.png"></p>

        <h5 id="步骤2-添加Spring的依赖jar包"   >
          <a href="#步骤2-添加Spring的依赖jar包" class="heading-link"><i class="fas fa-link"></i></a>步骤2:添加Spring的依赖jar包</h5>
      <p>pom.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-添加案例中需要的类"   >
          <a href="#步骤3-添加案例中需要的类" class="heading-link"><i class="fas fa-link"></i></a>步骤3:添加案例中需要的类</h5>
      <p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-添加spring配置文件"   >
          <a href="#步骤4-添加spring配置文件" class="heading-link"><i class="fas fa-link"></i></a>步骤4:添加spring配置文件</h5>
      <p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p>
<p><img src="/images/1629734336440.png"></p>

        <h5 id="步骤5-在配置文件中完成bean的配置"   >
          <a href="#步骤5-在配置文件中完成bean的配置" class="heading-link"><i class="fas fa-link"></i></a>步骤5:在配置文件中完成bean的配置</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>&#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D;</strong></p>

        <h5 id="步骤6-获取IOC容器"   >
          <a href="#步骤6-获取IOC容器" class="heading-link"><i class="fas fa-link"></i></a>步骤6:获取IOC容器</h5>
      <p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤7-从容器中获取对象进行方法调用"   >
          <a href="#步骤7-从容器中获取对象进行方法调用" class="heading-link"><i class="fas fa-link"></i></a>步骤7:从容器中获取对象进行方法调用</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤8-运行程序"   >
          <a href="#步骤8-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤8:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p>

        <h3 id="3-2-DI入门案例"   >
          <a href="#3-2-DI入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.2 DI入门案例</h3>
      <p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-2-1-入门案例思路分析"   >
          <a href="#3-2-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.2.1 入门案例思路分析</h4>
      <p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p>
<ul>
<li>DI的入门案例要依赖于前面IOC的入门案例</li>
</ul>
<p>(2)Service中使用new形式创建的Dao对象是否保留?</p>
<ul>
<li>需要删除掉，最终要使用IOC容器中的bean对象</li>
</ul>
<p>(3)Service中需要的Dao对象如何进入到Service中?</p>
<ul>
<li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li>
</ul>
<p>(4)Service与Dao间的关系如何描述?</p>
<ul>
<li>使用配置文件</li>
</ul>

        <h4 id="3-2-2-入门案例代码实现"   >
          <a href="#3-2-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.2.2 入门案例代码实现</h4>
      <blockquote>
<p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p>
<p>1.删除业务层中使用new的方式创建的dao对象</p>
<p>2.在业务层提供BookDao的setter方法</p>
<p>3.在配置文件中添加依赖注入的配置</p>
<p>4.运行程序调用方法</p>
</blockquote>

        <h5 id="步骤1-去除代码中的new"   >
          <a href="#步骤1-去除代码中的new" class="heading-link"><i class="fas fa-link"></i></a>步骤1: 去除代码中的new</h5>
      <p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-为属性提供setter方法"   >
          <a href="#步骤2-为属性提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤2:为属性提供setter方法</h5>
      <p>在BookServiceImpl类中,为BookDao提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-修改配置完成注入"   >
          <a href="#步骤3-修改配置完成注入" class="heading-link"><i class="fas fa-link"></i></a>步骤3:修改配置完成注入</h5>
      <p>在配置文件中添加依赖注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        		name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        		ref属性表示参照哪一个bean</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D;</p>
<ul>
<li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li>
<li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li>
<li>综上所述，对应关系如下:</li>
</ul>
<p><img src="/images/1629736314989.png"></p>

        <h5 id="步骤4-运行程序"   >
          <a href="#步骤4-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤4:运行程序</h5>
      <p>运行，测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>

        <h2 id="4，IOC相关内容"   >
          <a href="#4，IOC相关内容" class="heading-link"><i class="fas fa-link"></i></a>4，IOC相关内容</h2>
      <p>通过前面两个案例，我们已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p>

        <h3 id="4-1-bean基础配置"   >
          <a href="#4-1-bean基础配置" class="heading-link"><i class="fas fa-link"></i></a>4.1 bean基础配置</h3>
      <p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容：</p>

        <h4 id="4-1-1-bean基础配置-id与class"   >
          <a href="#4-1-1-bean基础配置-id与class" class="heading-link"><i class="fas fa-link"></i></a>4.1.1 bean基础配置(id与class)</h4>
      <p>对于bean的基础配置，在前面的案例中已经使用过:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p>
<p><img src="/images/image-20210729183500978.png"></p>
<p>这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。</p>
<p><strong>思考：</strong></p>
<ul>
<li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li>
</ul>
<p>答案肯定是不行，因为接口是没办法创建对象的。</p>
<ul>
<li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li>
</ul>
<p>在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案:</p>
<ul>
<li><p>使用前面IOC和DI的案例</p>
</li>
<li><p>重新搭建一个新的案例环境,目的是方便大家查阅代码</p>
<ul>
<li><p>搭建的内容和前面的案例是一样的，内容如下：</p>
<p><img src="/images/1629769227068.png"></p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-1-2-bean的name属性"   >
          <a href="#4-1-2-bean的name属性" class="heading-link"><i class="fas fa-link"></i></a>4.1.2 bean的name属性</h4>
      <p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p>
<p>首先来看下别名的配置说明:</p>
<p><img src="/images/image-20210729183558051.png"></p>

        <h5 id="步骤1：配置别名"   >
          <a href="#步骤1：配置别名" class="heading-link"><i class="fas fa-link"></i></a>步骤1：配置别名</h5>
      <p>打开spring的配置文件applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p>

        <h5 id="步骤2-根据名称容器中获取bean对象"   >
          <a href="#步骤2-根据名称容器中获取bean对象" class="heading-link"><i class="fas fa-link"></i></a>步骤2:根据名称容器中获取bean对象</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序"   >
          <a href="#步骤3-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p>
<p><img src="/images/1629771744003.png"></p>
</li>
<li><p>如果不存在,则会报错，如下:</p>
<p><img src="/images/1629771880920.png"></p>
<p>这个错误大家需要特别关注下:</p>
<p><img src="/images/1629771972886.png"></p>
<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p>
</li>
</ul>

        <h4 id="4-1-3-bean作用范围scope配置"   >
          <a href="#4-1-3-bean作用范围scope配置" class="heading-link"><i class="fas fa-link"></i></a>4.1.3 bean作用范围scope配置</h4>
      <p>关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。</p>
<p>看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?</p>
<p>我们先来看下<code>bean作用范围的配置属性</code>:</p>
<p><img src="/images/image-20210729183628138.png"></p>

        <h5 id="4-1-3-1-验证IOC容器中对象是否为单例"   >
          <a href="#4-1-3-1-验证IOC容器中对象是否为单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.1 验证IOC容器中对象是否为单例</h5>
      
        <h6 id="验证思路"   >
          <a href="#验证思路" class="heading-link"><i class="fas fa-link"></i></a>验证思路</h6>
      <p>​	同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p>

        <h6 id="具体实现"   >
          <a href="#具体实现" class="heading-link"><i class="fas fa-link"></i></a>具体实现</h6>
      <ul>
<li><p>创建一个AppForScope的类，在其main方法中来验证</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>打印，观察控制台的打印结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>结论:默认情况下，Spring创建的bean对象都是单例的</p>
</li>
</ul>
<p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p>

        <h5 id="4-1-3-2-配置bean为非单例"   >
          <a href="#4-1-3-2-配置bean为非单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.2 配置bean为非单例</h5>
      <p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p>
<ul>
<li><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>将scope设置为<code>singleton</code></p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>将scope设置为<code>prototype</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772928714.png"></p>
</li>
<li><p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p>
<ul>
<li><code>singleton</code>默认为单例</li>
<li><code>prototype</code>为非单例</li>
</ul>
</li>
</ul>

        <h5 id="4-1-3-3-scope使用后续思考"   >
          <a href="#4-1-3-3-scope使用后续思考" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.3 scope使用后续思考</h5>
      <p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p>
<ul>
<li><p>为什么bean默认为单例?</p>
<ul>
<li>bean为单例的意思是在Spring的IOC容器中<strong>只会有该类的一个对象</strong></li>
<li>bean对象只有一个就<strong>避免了对象的频繁创建与销毁</strong>，达到了bean对象的<strong>复用，性能高</strong></li>
</ul>
</li>
<li><p>bean在容器中是单例的，会不会产生<strong>线程安全</strong>问题?</p>
<ul>
<li><p>如果对象是<mark>有状态</mark>对象，即该对象有成员变量可以用来存储数据的，</p>
<p>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</p>
</li>
<li><p>如果对象是<mark>无状态</mark>对象，即该对象没有成员变量没有进行数据存储的，</p>
<p>因方法中的<strong>局部变量在方法调用完成后会被销毁</strong>，所以不会存在线程安全问题。</p>
</li>
</ul>
</li>
<li><p>哪些bean对象适合交给容器进行管理?</p>
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
</li>
<li><p>哪些bean对象不适合交给容器进行管理?</p>
<ul>
<li>封装<strong>实例</strong>的域对象，因为会引发线程安全问题，所以不适合。</li>
</ul>
</li>
</ul>

        <h4 id="4-14-bean基础配置小结"   >
          <a href="#4-14-bean基础配置小结" class="heading-link"><i class="fas fa-link"></i></a>4.14 bean基础配置小结</h4>
      <p>关于bean的基础配置中，需要大家掌握以下属性:</p>
<p><img src="/images/1631529887695.png"></p>

        <h3 id="4-2-bean实例化"   >
          <a href="#4-2-bean实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2 bean实例化</h3>
      <p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p>
<p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p>
<ul>
<li>bean是如何创建的</li>
<li>实例化bean的三种方式，<code>构造方法(重点)</code>,<code>静态工厂</code>，<code>实例工厂()</code>，<code>FactoryBean()(重点)</code></li>
</ul>
<p>在讲解这三种创建方式之前，我们需要先确认一件事:</p>
<p>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</p>
<p>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</p>

        <h4 id="4-2-1-环境准备"   >
          <a href="#4-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.1 环境准备</h4>
      <p>为了方便大家阅读代码，重新准备个开发环境，</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629775585694.png"></p>

        <h4 id="4-2-2-构造方法实例化"   >
          <a href="#4-2-2-构造方法实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.2 构造方法实例化</h4>
      <p>在上述的环境下，我们来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p>

        <h5 id="步骤1-准备需要被创建的类"   >
          <a href="#步骤1-准备需要被创建的类" class="heading-link"><i class="fas fa-link"></i></a>步骤1:准备需要被创建的类</h5>
      <p>准备一个BookDao和BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-将类配置到Spring容器"   >
          <a href="#步骤2-将类配置到Spring容器" class="heading-link"><i class="fas fa-link"></i></a>步骤2:将类配置到Spring容器</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-编写运行程序"   >
          <a href="#步骤3-编写运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:编写运行程序</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-类中提供构造函数测试"   >
          <a href="#步骤4-类中提供构造函数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤4:类中提供构造函数测试</h5>
      <p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤5-将构造函数改成private测试"   >
          <a href="#步骤5-将构造函数改成private测试" class="heading-link"><i class="fas fa-link"></i></a>步骤5:将构造函数改成private测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,因为无论私有公有都能够被访问，所以我们可以说，<strong>Spring底层用的是反射</strong></p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤6-构造函数中添加一个参数测试"   >
          <a href="#步骤6-构造函数中添加一个参数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤6:构造函数中添加一个参数测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，</p>
<p>程序会报错，说明Spring底层使用的是<strong>类的无参构造方法</strong>。</p>
<p>（原因：有参构造器通常意味着类要进行实例化，而实例化的类在IOC的单例模式下很容易造成线程安全问题，所以IOC拒绝访问有参构造器生成的对象）</p>
<p><img src="/images/1629776331499.png"></p>
<p><mark>底层是运用反射获取类的无参构造器来构造类的单例对象。</mark></p>

        <h4 id="4-2-3-分析Spring的错误信息-简单看看就好了"   >
          <a href="#4-2-3-分析Spring的错误信息-简单看看就好了" class="heading-link"><i class="fas fa-link"></i></a>4.2.3 分析Spring的错误信息(简单看看就好了)</h4>
      <p>接下来，我们主要研究下Spring的报错信息来学一学如阅读。</p>
<ul>
<li><p>错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面</p>
<blockquote>
<p>Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>Caused by 翻译为<code>引起</code>，即出现错误的原因</li>
<li>java.lang.NoSuchMethodException:抛出的异常为<code>没有这样的方法异常</code></li>
<li>com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>():哪个类的哪个方法没有被找到导致的异常，<code>&lt;init&gt;</code>()指定是类的构造方法，即该类的无参构造方法</li>
</ul>
</li>
</ul>
<p>如果最后一行错误获取不到错误信息，接下来查看第二层:</p>
<blockquote>
<p> Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>nested:嵌套的意思，后面的异常内容和最底层的异常是一致的<ul>
<li>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; <ul>
<li>Caused by: <code>引发</code></li>
<li>BeanInstantiationException:翻译为<code>bean实例化异常</code></li>
<li>No default constructor found:没有一个默认的构造函数被发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看到这其实错误已经比较明显，给大家个练习，把倒数第三层的错误分析下吧:</p>
<blockquote>
<p> Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bookDao’ defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()。</p>
</blockquote>
<p>至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做。这也是我们以后比较常用的一种方式。</p>

        <h4 id="4-2-4-静态工厂实例化"   >
          <a href="#4-2-4-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4 静态工厂实例化</h4>
      <p>接下来研究Spring中的第二种bean的创建方式<code>静态工厂实例化</code>:</p>

        <h5 id="4-2-4-1-工厂方式创建bean"   >
          <a href="#4-2-4-1-工厂方式创建bean" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.1 工厂方式创建bean</h5>
      <p>在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式:</p>
<p>(1)准备一个OrderDao和OrderDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> OrderDaoFactory.getOrderDao();</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?</p>

        <h5 id="4-2-4-2-静态工厂实例化"   >
          <a href="#4-2-4-2-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.2 静态工厂实例化</h5>
      <p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</p>
<p>(1)在spring的配置文件application.properties中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>class:工厂类的类全名</p>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>对应关系如下图:</p>
<p><img src="/images/image-20210729195248948.png"></p>
<p>(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> (OrderDao) ctx.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        orderDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么?</p>
<p>主要的原因是:</p>
<ul>
<li>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如:</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory setup....&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果:</p>
<p><img src="/images/1629788036885.png"></p>
<p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。</p>

        <h4 id="4-2-5-实例工厂与FactoryBean"   >
          <a href="#4-2-5-实例工厂与FactoryBean" class="heading-link"><i class="fas fa-link"></i></a>4.2.5 实例工厂与FactoryBean</h4>
      <p>接下来继续来研究Spring的第三种bean的创建方式<code>实例工厂实例化</code>:</p>

        <h5 id="4-2-3-1-环境准备"   >
          <a href="#4-2-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.1 环境准备</h5>
      <p>(1)准备一个UserDao和UserDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceUser运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">UserDaoFactory</span> <span class="variable">userDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> userDaoFactory.getUserDao();</span><br><span class="line">        userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>对于上面这种实例工厂的方式如何交给Spring管理呢?</p>

        <h5 id="4-2-3-2-实例工厂实例化"   >
          <a href="#4-2-3-2-实例工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.2 实例工厂实例化</h5>
      <p>具体实现步骤为:</p>
<p>(1)在spring的配置文件中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>实例化工厂运行的顺序是:</p>
<ul>
<li><p>创建实例化工厂对象,对应的是第一行配置</p>
</li>
<li><p>调用对象中的方法来创建bean，对应的是第二行配置</p>
<ul>
<li><p>factory-bean:工厂的实例对象</p>
</li>
<li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p>
<p><img src="/images/image-20210729200203249.png"></p>
</li>
</ul>
</li>
</ul>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p>

        <h5 id="4-2-3-3-FactoryBean的使用"   >
          <a href="#4-2-3-3-FactoryBean的使用" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.3 FactoryBean的使用</h5>
      <p>具体的使用步骤为:</p>
<p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)在Spring的配置文件中进行配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p>
<p><img src="/images/1629788769436.png"></p>
<p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。</p>
<p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p>
<p>方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象</p>
<p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?</p>
<p>思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>打印结果，如下:</p>
<p><img src="/images/1629790070607.png"></p>
<p>通过验证，会发现默认是单例，那如果想改成单例具体如何实现?</p>
<p>只需要将isSingleton()方法进行重写，修改返回为false，即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FactoryBean创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForInstanceUser，查看结果</p>
<p><img src="/images/1629790197860.png"></p>
<p>从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。</p>

        <h4 id="4-2-6-bean实例化小结"   >
          <a href="#4-2-6-bean实例化小结" class="heading-link"><i class="fas fa-link"></i></a>4.2.6 bean实例化小结</h4>
      <p>通过这一节的学习，需要掌握:</p>
<p>(1)bean是如何创建的呢?</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></div></figure>

<p>(2)Spring的IOC实例化对象的三种方式分别是:</p>
<ul>
<li>构造方法(常用)</li>
<li>静态工厂(了解)</li>
<li>实例工厂(了解)<ul>
<li>FactoryBean(实用)</li>
</ul>
</li>
</ul>
<p>这些方式中，重点掌握<code>构造方法</code>和<code>FactoryBean</code>即可。</p>
<p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p>

        <h3 id="4-3-bean的生命周期"   >
          <a href="#4-3-bean的生命周期" class="heading-link"><i class="fas fa-link"></i></a>4.3 bean的生命周期</h3>
      <p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解:</p>
<ul>
<li>首先理解下什么是生命周期?<ul>
<li>从创建到消亡的完整过程,例如人<strong>从出生到死亡</strong>的整个过程就是一个生命周期。</li>
</ul>
</li>
<li>bean生命周期是什么?<ul>
<li>bean对象从创建到销毁的整体过程。</li>
</ul>
</li>
<li>bean生命周期控制是什么?<ul>
<li>在bean创建后到销毁前做一些事情。</li>
</ul>
</li>
</ul>
<p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p>

        <h4 id="4-3-1-环境准备"   >
          <a href="#4-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.3.1 环境准备</h4>
      <p>还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629791473409.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        	<span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-3-2-生命周期设置"   >
          <a href="#4-3-2-生命周期设置" class="heading-link"><i class="fas fa-link"></i></a>4.3.2 生命周期设置</h4>
      <p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p>
<ul>
<li>bean<strong>创建之后</strong>，想要添加内容，比如用<strong>来初始化需要用到资源</strong></li>
<li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li>
</ul>

        <h5 id="步骤1-添加初始化和销毁方法"   >
          <a href="#步骤1-添加初始化和销毁方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加初始化和销毁方法</h5>
      <p>针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置生命周期"   >
          <a href="#步骤2-配置生命周期" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置生命周期</h5>
      <p>在配置文件添加配置，如下:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-1"   >
          <a href="#步骤3-运行程序-1" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForLifeCycle打印结果为:</p>
<p><img src="/images/1629792339889.png"></p>
<p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p>
<ul>
<li>Spring的IOC容器是运行在JVM中</li>
<li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li>
<li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li>
<li>所以没有调用对应的destroy方法</li>
</ul>
<p>知道了出现问题的原因，具体该如何解决呢?</p>

        <h4 id="4-3-3-close关闭容器"   >
          <a href="#4-3-3-close关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.3 close关闭容器</h4>
      <ul>
<li><p>ApplicationContext中没有close方法</p>
</li>
<li><p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>调用ctx的close()方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>运行程序，就能执行destroy方法的内容</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>

        <h4 id="4-3-4-注册钩子关闭容器"   >
          <a href="#4-3-4-注册钩子关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.4 注册钩子关闭容器</h4>
      <ul>
<li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p>
</li>
<li><p>调用ctx的<code>registerShutdownHook()</code>方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></div></figure>

<p>**注意:**registerShutdownHook在ApplicationContext中也没有</p>
</li>
<li><p>运行后，查询打印结果</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>
<p>两种方式介绍完后，close和registerShutdownHook选哪个?</p>
<p>相同点:这两种都能用来关闭容器</p>
<p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p>
<p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p>
<p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p>
<p>接下来在BookServiceImpl完成这两个接口的使用:</p>
<p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForLifeCycle类，</p>
<p><img src="/images/1629794527419.png"></p>
<p>那第二种方式的实现，我们也介绍完了。</p>
<p><strong>小细节</strong></p>
<ul>
<li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p>
</li>
<li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p>
</li>
<li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p>
</li>
<li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p>
<ul>
<li><p>从方法名分析，猜想应该是setBookDao方法先执行</p>
</li>
<li><p>验证思路，在setBookDao方法中添加一句话</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>重新运行AppForLifeCycle，打印结果如下:</p>
<p><img src="/images/1629794928636.png"></p>
<p>验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-3-5-bean生命周期小结"   >
          <a href="#4-3-5-bean生命周期小结" class="heading-link"><i class="fas fa-link"></i></a>4.3.5 bean生命周期小结</h4>
      <p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p>
<ul>
<li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li>
<li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li>
</ul>
<p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p>
<ul>
<li>初始化容器<ul>
<li>1.创建对象(内存分配)</li>
<li>2.执行构造方法</li>
<li>3.执行属性注入(set操作)</li>
<li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li>
</ul>
</li>
<li>使用bean<ul>
<li>1.执行业务操作</li>
</ul>
</li>
<li>关闭&#x2F;销毁容器<ul>
<li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p>(3)关闭容器的两种方式:</p>
<ul>
<li>ConfigurableApplicationContext是ApplicationContext的子类<ul>
<li>close()方法</li>
<li>registerShutdownHook()方法</li>
</ul>
</li>
</ul>

        <h2 id="5，DI相关内容"   >
          <a href="#5，DI相关内容" class="heading-link"><i class="fas fa-link"></i></a>5，DI相关内容</h2>
      <p>前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p>
<p>我们先来思考</p>
<ul>
<li>向一个类中传递数据的方式有几种?<ul>
<li>普通方法(set方法)</li>
<li>构造方法</li>
</ul>
</li>
<li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?<ul>
<li>引用类型</li>
<li>简单类型(基本数据类型与String)</li>
</ul>
</li>
</ul>
<p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p>
<ul>
<li>setter注入<ul>
<li>简单类型</li>
<li>&#x3D;&#x3D;引用类型&#x3D;&#x3D;</li>
</ul>
</li>
<li>构造器注入<ul>
<li>简单类型</li>
<li>引用类型</li>
</ul>
</li>
</ul>
<p>依赖注入的方式已经介绍完，接下来挨个学习下:</p>

        <h3 id="5-1-setter注入"   >
          <a href="#5-1-setter注入" class="heading-link"><i class="fas fa-link"></i></a>5.1 setter注入</h3>
      <ol>
<li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li>
</ol>
<ul>
<li>在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-1-1-环境准备"   >
          <a href="#5-1-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 环境准备</h4>
      <p>为了更好的学习下面内容，我们依旧准备一个新环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629799214191.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDISet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成setter注入的学习:</p>

        <h4 id="5-1-2-注入引用数据类型"   >
          <a href="#5-1-2-注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 注入引用数据类型</h4>
      <blockquote>
<p>需求:在bookServiceImpl对象中注入userDao</p>
<p>1.在BookServiceImpl中声明userDao属性</p>
<p>2.为userDao属性提供setter方法</p>
<p>3.在配置文件中使用property标签注入</p>
</blockquote>

        <h5 id="步骤1-声明属性并提供setter方法"   >
          <a href="#步骤1-声明属性并提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookServiceImpl中声明userDao属性，并提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置"   >
          <a href="#步骤2-配置文件中进行注入配置" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-2"   >
          <a href="#步骤3-运行程序-2" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629799873386.png"></p>

        <h4 id="5-1-3-注入简单数据类型"   >
          <a href="#5-1-3-注入简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 注入简单数据类型</h4>
      <blockquote>
<p>需求：给BookDaoImpl注入一些简单数据类型的数据</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p>
<p>2.为这些属性提供对应的setter方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>
<p><strong>思考:</strong></p>
<p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p>
<p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p>

        <h5 id="步骤1-声明属性并提供setter方法-1"   >
          <a href="#步骤1-声明属性并提供setter方法-1" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置-1"   >
          <a href="#步骤2-配置文件中进行注入配置-1" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p>

        <h5 id="步骤3-运行程序-3"   >
          <a href="#步骤3-运行程序-3" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629800324721.png"></p>
<p>**注意:**两个property注入标签的顺序可以任意。</p>
<p>对于setter注入方式的基本使用就已经介绍完了，</p>
<ul>
<li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li>
<li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>

        <h3 id="5-2-构造器注入"   >
          <a href="#5-2-构造器注入" class="heading-link"><i class="fas fa-link"></i></a>5.2 构造器注入</h3>
      
        <h4 id="5-2-1-环境准备"   >
          <a href="#5-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.2.1 环境准备</h4>
      <p>构造器注入也就是构造方法注入，学习之前，还是先准备下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629800748639.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDIConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-2-2-构造器注入引用数据类型"   >
          <a href="#5-2-2-构造器注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.2 构造器注入引用数据类型</h4>
      <p>接下来，在上面这个环境中来完成构造器注入的学习:</p>
<blockquote>
<p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p>
<p>1.将bookDao的setter方法删除掉</p>
<p>2.添加带有bookDao参数的构造方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>

        <h5 id="步骤1-删除setter方法并提供构造方法"   >
          <a href="#步骤1-删除setter方法并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:删除setter方法并提供构造方法</h5>
      <p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行配置构造方式注入"   >
          <a href="#步骤2-配置文件中进行配置构造方式注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行配置构造方式注入</h5>
      <p>在applicationContext.xml中配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>标签<constructor-arg>中</p>
<ul>
<li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p>
</li>
<li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p>
</li>
</ul>

        <h5 id="步骤3：运行程序"   >
          <a href="#步骤3：运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3：运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p>
<p><img src="/images/1629802656916.png"></p>

        <h4 id="5-2-3-构造器注入多个引用数据类型"   >
          <a href="#5-2-3-构造器注入多个引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.3 构造器注入多个引用数据类型</h4>
      <blockquote>
<p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p>
<p>1.声明userDao属性</p>
<p>2.生成一个带有bookDao和userDao参数的构造函数</p>
<p>3.在applicationContext.xml中配置注入</p>
</blockquote>

        <h5 id="步骤1-提供多个属性的构造函数"   >
          <a href="#步骤1-提供多个属性的构造函数" class="heading-link"><i class="fas fa-link"></i></a>步骤1:提供多个属性的构造函数</h5>
      <p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>步骤2:配置文件中配置多参数注入</p>
<p>在applicationContext.xml中配置注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-4"   >
          <a href="#步骤3-运行程序-4" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629802697318.png"></p>

        <h4 id="5-2-4-构造器注入多个简单数据类型"   >
          <a href="#5-2-4-构造器注入多个简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.4 构造器注入多个简单数据类型</h4>
      <blockquote>
<p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.提供一个包含这两个参数的构造方法</p>
<p>2.在applicationContext.xml中进行注入配置</p>
</blockquote>

        <h5 id="步骤1-添加多个简单属性并提供构造方法"   >
          <a href="#步骤1-添加多个简单属性并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加多个简单属性并提供构造方法</h5>
      <p>修改BookDaoImpl类，添加构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置完成多个属性构造器注入"   >
          <a href="#步骤2-配置完成多个属性构造器注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置完成多个属性构造器注入</h5>
      <p>在applicationContext.xml中进行注入配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-5"   >
          <a href="#步骤3-运行程序-5" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果</p>
<p><img src="/images/1629803111769.png"></p>
<p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p>
<p><img src="/images/1629803529598.png"></p>
<ul>
<li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li>
<li>这两块存在紧耦合，具体该如何解决?</li>
</ul>
<p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p>
<p>方式一:删除name属性，添加type属性，按照类型注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li>
<li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li>
</ul>
<p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决参数类型重复问题</li>
<li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li>
</ul>
<p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p>
<ol>
<li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul>
<li>强制依赖指对象在创建的过程中必须要注入指定的参数</li>
</ul>
</li>
<li>可选依赖使用setter注入进行，灵活性强<ul>
<li>可选依赖指对象在创建过程中注入的参数可有可无</li>
</ul>
</li>
<li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><strong>&#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D;</strong></li>
</ol>
<p>这节中主要讲解的是Spring的依赖注入的实现方式:</p>
<ul>
<li><p>setter注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>构造器注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>依赖注入的方式选择上</p>
<ul>
<li>建议使用setter注入</li>
<li>第三方技术根据情况选择</li>
</ul>
</li>
</ul>

        <h3 id="5-3-自动配置"   >
          <a href="#5-3-自动配置" class="heading-link"><i class="fas fa-link"></i></a>5.3 自动配置</h3>
      <p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。</p>
<p>问:麻烦在哪?</p>
<p>答:配置文件的编写配置上。</p>
<p>问:有更简单方式么?</p>
<p>答:有，自动配置</p>
<p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p>

        <h4 id="5-3-1-什么是依赖自动装配"   >
          <a href="#5-3-1-什么是依赖自动装配" class="heading-link"><i class="fas fa-link"></i></a>5.3.1 什么是依赖自动装配?</h4>
      <ul>
<li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li>
</ul>

        <h4 id="5-3-2-自动装配方式有哪些"   >
          <a href="#5-3-2-自动装配方式有哪些" class="heading-link"><i class="fas fa-link"></i></a>5.3.2 自动装配方式有哪些?</h4>
      <ul>
<li>&#x3D;&#x3D;按类型（常用）&#x3D;&#x3D;</li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>

        <h4 id="5-3-3-准备下案例环境"   >
          <a href="#5-3-3-准备下案例环境" class="heading-link"><i class="fas fa-link"></i></a>5.3.3 准备下案例环境</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629805387647.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-3-4-完成自动装配的配置"   >
          <a href="#5-3-4-完成自动装配的配置" class="heading-link"><i class="fas fa-link"></i></a>5.3.4 完成自动装配的配置</h4>
      <p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p>
<p>自动装配只需要修改applicationContext.xml配置文件即可:</p>
<p>(1)将<code>&lt;property&gt;</code>标签删除</p>
<p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p>
<p>首先来实现按照类型注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li>需要注入属性的类中对应属性的setter方法不能省略</li>
<li>被注入的对象必须要被Spring的IOC容器管理</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li>
</ul>
<p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>按照名称注入中的名称指的是什么?</p>
<p><img src="/images/1629806856156.png"></p>
<ul>
<li>bookDao是private修饰的，外部类无法直接方法</li>
<li>外部类只能通过属性的set方法进行访问</li>
<li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul>
<li>为什么是去掉set首字母小写?</li>
<li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li>
</ul>
</li>
<li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li>
</ul>
</li>
<li><p>如果按照名称去找对应的bean对象，找不到则注入Null</p>
</li>
<li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p>
</li>
</ul>
<p>两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。</p>
<p>最后对于依赖注入，需要注意一些其他的配置特征:</p>
<ol>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>
<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>
</ol>

        <h3 id="5-4-集合注入"   >
          <a href="#5-4-集合注入" class="heading-link"><i class="fas fa-link"></i></a>5.4 集合注入</h3>
      <p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p>
<p>先来回顾下，常见的集合类型有哪些?</p>
<ul>
<li>数组</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>Properties</li>
</ul>
<p>针对不同的集合类型，该如何实现注入呢?</p>

        <h4 id="5-4-1-环境准备"   >
          <a href="#5-4-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.4.1 环境准备</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629807579330.png"></p>
<p>(1)项目中添加添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件，applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDICollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成<code>集合注入</code>的学习:</p>
<p>下面的所以配置方式，都是在bookDao的bean标签中使用<property>进行注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-2-注入数组类型数据"   >
          <a href="#5-4-2-注入数组类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.2 注入数组类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-3-注入List类型数据"   >
          <a href="#5-4-3-注入List类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.3 注入List类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-4-注入Set类型数据"   >
          <a href="#5-4-4-注入Set类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.4 注入Set类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-5-注入Map类型数据"   >
          <a href="#5-4-5-注入Map类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.5 注入Map类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-6-注入Properties类型数据"   >
          <a href="#5-4-6-注入Properties类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.6 注入Properties类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>配置完成后，运行下看结果:</p>
<p><img src="/images/1629808046783.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>内存</title>
    <url>/post/10970/</url>
    <content><![CDATA[
        <h1 id="缓存池的作用"   >
          <a href="#缓存池的作用" class="heading-link"><i class="fas fa-link"></i></a>缓存池的作用</h1>
      <p>缓存池主要是为了加快数据的查询效率。如果每个查询语句都到磁盘中的数据库进行查询的话，那么进行io执行效率不高。所以在内存中开辟了一块空间，用来存储高频的查询语句，目的是为了提高查询效率。</p>
<ul>
<li>当执行一条查询语句时，执行器会先到缓存池中寻找，如果命中，就直接返回。如果未命中，就到磁盘里读取数据，在将这条数据加入到缓存池中。</li>
<li>当执行一条更新语句时，会先进行查询定位要原始语句，流程同上，更新完会同时更新缓存池中的数据，同时将缓存池中的数据标记为脏页。等到合适的时候将内存刷盘，更新到磁盘中。</li>
</ul>

        <h1 id="缓存池的容量"   >
          <a href="#缓存池的容量" class="heading-link"><i class="fas fa-link"></i></a>缓存池的容量</h1>
      <p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code> 。</p>
<p>可以通过调整 <code>innodb_buffer_pool_size</code> 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 <code>60%~80%</code>。</p>

        <h1 id="缓存池的存储结构"   >
          <a href="#缓存池的存储结构" class="heading-link"><i class="fas fa-link"></i></a>缓存池的存储结构</h1>
      <p>在Inno db中，数据的存储以页为单位。一个页中有保存了多条数据。根据缓存一致性原理，查询的时候会将其附近的语句一起加载。那么在缓存池中，也会同样以页为单位进行存储，一个页的大小默认为<code>16kb</code>。每个页中的结构有数据页，索引页，插入缓存页，undo log页，自适应哈希索引页，锁信息页。为了能够更好的管理页，每个页开头都有一个控制块进行管理，控制块中的信息包括缓存页的表空间、页号、缓存页地址、链表节点等。</p>

        <h1 id="缓存池的功能"   >
          <a href="#缓存池的功能" class="heading-link"><i class="fas fa-link"></i></a>缓存池的功能</h1>
      
        <h2 id="管理空闲页"   >
          <a href="#管理空闲页" class="heading-link"><i class="fas fa-link"></i></a>管理空闲页</h2>
      <p><img src="/%E5%86%85%E5%AD%98.assets/1686539614795-25436072-b95c-4ca7-a736-1341f420b054.png" alt="img"></p>
<p>采用链表结构，将控制块作为链表节点。通过设置一个free链表来快速定位到空闲页的位置。减少了查询的数据量。</p>

        <h2 id="管理脏页"   >
          <a href="#管理脏页" class="heading-link"><i class="fas fa-link"></i></a>管理脏页</h2>
      <p><img src="/%E5%86%85%E5%AD%98.assets/1686539696705-baa031ff-6e1c-4a03-ac8c-e12af23e756f.png" alt="img"></p>
<p>基本上相当于空闲页的结构。</p>

        <h2 id="提高缓存命中率"   >
          <a href="#提高缓存命中率" class="heading-link"><i class="fas fa-link"></i></a>提高缓存命中率</h2>
      
        <h3 id="原始LRU结构"   >
          <a href="#原始LRU结构" class="heading-link"><i class="fas fa-link"></i></a>原始LRU结构</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/lru-cache/" >LRU数据结构</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>LRU主要是为了提高数据读取效率而设计的。他的主要功能是最近访问的信息会出现在链表的头部，所以他被叫做：last receive user（最近使用）</p>
<p>最朴素的LRU结构的特点就是，</p>
<ul>
<li>查询数据的时候，如果数据在LRU链表中，就将其提前到链表的头部。</li>
<li>如果数据不在链表中，就在内存中将数据插入LRU链表的头部，同时将LRU的最后一个元素退出队列。</li>
</ul>
<p>但是这种结构很少被使用，因为他会导致一些问题：</p>
<ul>
<li>预读失效</li>
<li>缓存池污染</li>
</ul>

        <h3 id="解决预读失效"   >
          <a href="#解决预读失效" class="heading-link"><i class="fas fa-link"></i></a>解决预读失效</h3>
      <p>预读指的是因为内存的空间局部性原理，当查询到一个数据的时候也会将其临近内存地址的数据一起添加。为了减少磁盘io。针对于程序的空间局部性原理，是大部分情况下成立的，但是在一部分情况下预读的页完全没有被访问到。但是他会存储在链表头部，挤占后面链表的空间。大大降低了缓存的命中率。</p>
<p>解决预读失效的方法是将其划分为新生代和老年代，预读的页加入old区域的头部，等到真正读取到的时候，才进入young区域的头部。这样既兼顾了缓存一致性的原理，有防止因为预读失效而让热点数据过期的风险。等到新数据插入的时候，优先淘汰old区域的节点。young区域的最后一个节点进入old区域。</p>

        <h3 id="解决缓存池污染"   >
          <a href="#解决缓存池污染" class="heading-link"><i class="fas fa-link"></i></a>解决缓存池污染</h3>
      <p>当一条sql语句查询出大量数据的时候，他们可能只被查询了一次，但是却一起被加载到缓存区中。把原有的高频缓存数据挤占出去。</p>
<p>mysql在进入到 young 区域条件增加了一个停留在 old 区域的时间判断。</p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；</li>
<li>如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；</li>
</ul>
<p>这个间隔时间是由 innodb_old_blocks_time 控制的，默认是 1000 ms。</p>
<p>也就说，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，这样就解决了 Buffer Pool 污染的问题 。</p>

        <h2 id="脏页刷入磁盘的时机"   >
          <a href="#脏页刷入磁盘的时机" class="heading-link"><i class="fas fa-link"></i></a>脏页刷入磁盘的时机</h2>
      <p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>日志</title>
    <url>/post/32353/</url>
    <content><![CDATA[
        <h1 id="undo-log"   >
          <a href="#undo-log" class="heading-link"><i class="fas fa-link"></i></a>undo log</h1>
      
        <h2 id="undo-log的作用"   >
          <a href="#undo-log的作用" class="heading-link"><i class="fas fa-link"></i></a>undo log的作用</h2>
      <p><img src="/%E6%97%A5%E5%BF%97.assets/1686403146475-2f741c8f-70bf-4370-b050-dabfa1bf7063.png" alt="img"></p>
<ul>
<li><p>实现事务的回滚，保证事务的原子性</p>
</li>
<li><ul>
<li>其主要实现就是将当前数据库操作取反，写入undo log中，比如新增一条语句，就记录其主键，回滚时删除；删除语句则将对应数据存入日志中；修改则存入原语句。</li>
</ul>
</li>
</ul>
<p>很多人疑问 undo log 是如何刷盘（持久化到磁盘）的？</p>
<p>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。</p>
<p>buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p>
<ul>
<li><p>通过与Read View的配合实现MVCC多版本并发控制。一次事务操作产生的undo log中有<code>trx_id</code> 和<code>roll_pointer</code>两个参数。<code>trx_id</code>指的是事务的id，<code>roll_pointer</code>指的是一个指针，用来将事务联系起来。主要用来记录<strong>事务产生的先后顺序</strong>。这样结合read view可以实现可重复读和和一定程度上预防幻读。</p>
</li>
<li><ul>
<li>undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li>
</ul>
</li>
</ul>
<p><img src="/%E6%97%A5%E5%BF%97.assets/1686403178895-140051c5-9ab5-4ecc-9907-b5fc3a33dc51.png" alt="img"></p>

        <h2 id="Buffer-pool缓存池的作用"   >
          <a href="#Buffer-pool缓存池的作用" class="heading-link"><i class="fas fa-link"></i></a>Buffer pool缓存池的作用</h2>
      <p>其作用和内存的作用大差不差：</p>
<ul>
<li>当读取数据的时候，执行器会先有限在缓存池中找是否存在数据，如果命中缓存，则直接返回；如果没有命中，再到磁盘中进行寻找。</li>
<li>当修改数据的时候，会先在缓存池中寻找要修改的数据是否存在，如果存在的话，会先修改缓存中的数据，同时将其标记为脏页。由参数指定将脏页由缓存更新到磁盘的时间。</li>
</ul>
<p>在mysql启动的时候，Inno DB会在缓存池中建立一个一个的页，每页的大小为<code>16kb</code>，开始的时候页是空的，会随着一条条查询操作而填充页。</p>
<p><img src="/%E6%97%A5%E5%BF%97.assets/1686402938998-9bfb712c-18df-4dab-aa2f-f93834288ff7.png" alt="img"></p>
<p>我们的undo log就记录在这当中的undo页中。</p>
<p>读取数据的时候，是一页一页的缓存，需要满足数据一致性原则。</p>

        <h1 id="redo-log"   >
          <a href="#redo-log" class="heading-link"><i class="fas fa-link"></i></a>redo log</h1>
      
        <h2 id="redo-log的作用"   >
          <a href="#redo-log的作用" class="heading-link"><i class="fas fa-link"></i></a>redo log的作用</h2>
      <p>redo log是用于记录数据库事务的每一条修改，删除，新增操作。目的是为了防止数据库因为外部原因崩溃宕机而导致的数据丢失。redo log记录了一次事务完成后的数据状态，记录的是数据更新之后的值。</p>
<p>因为redo log是对于<code>buffer pool</code>中进行标记脏页（修改）的操作进行记录，所以undo log也会被记录到redo log中进行持久化。</p>
<p>在sql执行中redo log的功能：</p>
<p><img src="/%E6%97%A5%E5%BF%97.assets/1686404019090-66759e64-894f-4fde-9a66-ef7afbdb2f18.png" alt="img"></p>
<p>undo log 和redo log在一个事务中的作用：</p>
<p><img src="/%E6%97%A5%E5%BF%97.assets/1686403982838-d58027bf-961b-4574-b9f6-15f15897ac85.png" alt="img"></p>
<ul>
<li>有了 redo log，再通过 WAL 技术，InnoDB 就可以保证即使数据库发生异常重启，之前已提交的记录都不会丢失，这个能力称为<code>crash-safe</code>（崩溃恢复）。可以看出来， redo log 保证了事务四大特性中的持久性。</li>
<li>将写入磁盘的方式由随机写改为顺序写，提高了io效率。</li>
</ul>
<p>WAL技术：MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上。采用了追加操作进行写入，所以WAL写入数据的方式是顺序写。</p>

        <h2 id="redo-log刷盘时机分析"   >
          <a href="#redo-log刷盘时机分析" class="heading-link"><i class="fas fa-link"></i></a>redo log刷盘时机分析</h2>
      <ul>
<li><p>MySQL 正常关闭时；</p>
</li>
<li><p>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</p>
</li>
<li><p>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</p>
</li>
<li><p>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘（这个策略可由 <code>innodb_flush_log_at_trx_commit</code> 参数控制，下面会说）。</p>
</li>
<li><ul>
<li>当设置该参数为 0 时，表示每次事务提交时 ，还是将 redo log 留在 redo log buffer 中 ，该模式下在事务提交时不会主动触发写入磁盘的操作。</li>
<li>当设置该参数为 1 时，表示每次事务提交时，都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘，这样可以保证 MySQL 异常重启之后数据不会丢失。</li>
<li>当设置该参数为 2 时，表示每次事务提交时，都只是缓存在 redo log buffer 里的 redo log 写到 redo log 文件，注意写入到「 redo log 文件」并不意味着写入到了磁盘，因为操作系统的文件系统中有个 Page Cache专门用来缓存文件数据的，所以写入「 redo log文件」意味着写入到了操作系统的文件缓存。</li>
</ul>
</li>
</ul>
<p>InnoDB 的后台线程每隔 1 秒：</p>
<ul>
<li>针对参数 0 ：会把缓存在 redo log buffer 中的 redo log ，通过调用 write() 写到操作系统的 Page Cache，然后调用 fsync() 持久化到磁盘。所以参数为 0 的策略，MySQL 进程的崩溃会导致上一秒钟所有事务数据的丢失;</li>
<li>针对参数 2 ：调用 fsync，将缓存在操作系统中 Page Cache 里的 redo log 持久化到磁盘。所以参数为 2 的策略，较取值为 0 情况下更安全，因为 MySQL 进程的崩溃并不会丢失数据，只有在操作系统崩溃或者系统断电的情况下，上一秒钟所有事务数据才可能丢失。</li>
<li>数据安全性：参数 1 &gt; 参数 2 &gt; 参数 0</li>
<li>写入性能：参数 0 &gt; 参数 2&gt; 参数 1</li>
</ul>

        <h1 id="binlog"   >
          <a href="#binlog" class="heading-link"><i class="fas fa-link"></i></a>binlog</h1>
      
        <h2 id="redo-log和binlog有什么区别"   >
          <a href="#redo-log和binlog有什么区别" class="heading-link"><i class="fas fa-link"></i></a>redo log和binlog有什么区别</h2>
      <ul>
<li><p>适用对象的不同</p>
</li>
<li><ul>
<li>redo log是inno db独有的日志格式</li>
<li>binlog是所有存储引擎都适用的，他服务于service层</li>
</ul>
</li>
<li><p>写入的方式不同</p>
</li>
<li><ul>
<li>redo log采用的是循环写，会对前面的内容产生覆盖</li>
<li>binlog采用的是追加写，写满一个文件，会创建一个新的文件继续写，不会覆盖前面的内容</li>
</ul>
</li>
<li><p>作用不同</p>
</li>
<li><ul>
<li>redo log主要为了防止突发的系统宕机导致数据不同步的问题</li>
<li>binlog主要是为了实现备份的恢复以及主从复制</li>
</ul>
</li>
</ul>

        <h2 id="如何实现主从复制"   >
          <a href="#如何实现主从复制" class="heading-link"><i class="fas fa-link"></i></a>如何实现主从复制</h2>
      <ul>
<li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li>
<li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li>
<li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li>
</ul>
<p>关键点：写数据从主库操作，读数据从从库操作。异步执行，读写分离。但缺点是可能会信息无法立刻同步导致读取的字段是旧数据。</p>

        <h2 id="binlog的刷盘的时机"   >
          <a href="#binlog的刷盘的时机" class="heading-link"><i class="fas fa-link"></i></a>binlog的刷盘的时机</h2>
      <p>MySQL提供一个 sync_binlog 参数来控制数据库的 binlog 刷到磁盘上的频率：</p>
<ul>
<li>sync_binlog &#x3D; 0 的时候，表示每次提交事务都只 write，不 fsync，后续交由操作系统决定何时将数据持久化到磁盘；</li>
<li>sync_binlog &#x3D; 1 的时候，表示每次提交事务都会 write，然后马上执行 fsync；</li>
<li>sync_binlog &#x3D;N(N&gt;1) 的时候，表示每次提交事务都 write，但累积 N 个事务后才 fsync。</li>
</ul>
<p>sql语句更新的执行流程：</p>
<ol>
<li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：</li>
</ol>
<ul>
<li><ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
</ul>
<ol>
<li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：</li>
</ol>
<ul>
<li><ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
</ul>
<ol>
<li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li>
<li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li>
<li>至此，一条记录更新完了。</li>
<li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li>
</ol>

        <h1 id="两阶段提交"   >
          <a href="#两阶段提交" class="heading-link"><i class="fas fa-link"></i></a>两阶段提交</h1>
      <ul>
<li>如果在将 redo log 刷入到磁盘之后， MySQL 突然宕机了，而 binlog 还没有来得及写入。MySQL 重启后，通过 redo log 能将 Buffer Pool 中 id &#x3D; 1 这行数据的 name 字段恢复到新值 xiaolin，但是 binlog 里面没有记录这条更新语句，在主从架构中，binlog 会被复制到从库，由于 binlog 丢失了这条更新语句，从库的这一行 name 字段是旧值 jay，与主库的值不一致性；</li>
<li>如果在将 binlog 刷入到磁盘之后， MySQL 突然宕机了，而 redo log 还没有来得及写入。由于 redo log 还没写，崩溃恢复以后这个事务无效，所以 id &#x3D; 1 这行数据的 name 字段还是旧值 jay，而 binlog 里面记录了这条更新语句，在主从架构中，binlog 会被复制到从库，从库执行了这条更新语句，那么这一行 name 字段是新值 xiaolin，与主库的值不一致性；</li>
</ul>
<p>事务的提交过程有两个阶段，就是将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，具体如下：</p>
<ul>
<li>prepare 阶段：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li>
<li>commit 阶段：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>索引</title>
    <url>/post/11557/</url>
    <content><![CDATA[
        <h1 id="索引在建表时候的形成"   >
          <a href="#索引在建表时候的形成" class="heading-link"><i class="fas fa-link"></i></a>索引在建表时候的形成</h1>
      <ul>
<li>有规定主键索引的时候，采用主键索引。</li>
<li>没有规定主键索引时，采用第一列唯一非空列作为索引。</li>
<li>如果上述情况不存在，sql会自动生成一列隐性主键索引。</li>
</ul>

        <h1 id="索引的分类"   >
          <a href="#索引的分类" class="heading-link"><i class="fas fa-link"></i></a>索引的分类</h1>
      
        <h2 id="索引在数据结构中"   >
          <a href="#索引在数据结构中" class="heading-link"><i class="fas fa-link"></i></a>索引在数据结构中</h2>
      <p><img src="/%E7%B4%A2%E5%BC%95.assets/1685290946707-a4c4952d-6842-4061-87cb-2904489efbcc.png" alt="img"></p>
<p><img src="/%E7%B4%A2%E5%BC%95.assets/1685290894134-b995139a-ec93-469b-9255-0952288a0af6.png" alt="img"></p>

        <h3 id="主键索引的查找过程"   >
          <a href="#主键索引的查找过程" class="heading-link"><i class="fas fa-link"></i></a>主键索引的查找过程</h3>
      <ul>
<li>首先从B+ Tree的根节点开始，找到属于其索引数据范围内的数据段对应的子节点，进入到下一个子节点。最后判断递归到叶子节点。</li>
<li>在叶子节点中，通过二分查找去寻找到对应的索引值相等的位置，或者大于小于的话可以通过B+ Tree独特的双向链表结构找到大于小于索引的值。</li>
<li>最后在主键索引中，B+ Tree的叶子节点存储的就是其对应的数据结构体的值。找到之后返回即可。</li>
</ul>

        <h3 id="辅助索引的查找过程"   >
          <a href="#辅助索引的查找过程" class="heading-link"><i class="fas fa-link"></i></a>辅助索引的查找过程</h3>
      <ul>
<li>基本等同与主键索引的查找过程，但是有一点要注意的是，在没有联合索引的情况下，辅助索引的叶子节点存储的是主键索引的索引值。所以，设置辅助索引的目的就是为了更方便的确定主键索引。这之后会有一次徽标的操作，也就是在遍历完一次辅助索引的B+ Tree之后再次遍历一次主键索引的B+ Tree。</li>
<li>那么在联合索引的情况下，辅助索引的叶子节点存储的就是联合索引的值了。之后再根据最左匹配原则来进行数据的查询。</li>
<li>优化辅助索引回表的关键在于：如果当需要的数据直接出现在叶子节点中（无论是主键索引还是辅助索引），那么sql语句解释器都会直接输出结果。那么我们就可以通过查询联合索引的方式来查询我们所需要查询的列。</li>
</ul>
<p>例如：我们需要查询某个姓名的学生的姓名，语文成绩，数学成绩；那么我们就可以将（姓名，语文成绩，数学成绩作为联合索引）,<code> select name, chinese, math from student where name = &#39;zhangsan&#39;；</code>那么这样就可以节约一次回表的操作了。</p>

        <h3 id="B-Tree的优点"   >
          <a href="#B-Tree的优点" class="heading-link"><i class="fas fa-link"></i></a>B+ Tree的优点</h3>
      <ul>
<li><p>在查询效率和占用空间上来讲，其更加扁平化的结构相较于二叉搜索树来讲，在查询上结构更加高效，因为二叉搜索树只能最多有两个分支，而B+ Tree能有好多个分支。</p>
</li>
<li><p>相较于B Tree 来讲，其结构做的优化主要有两个点：</p>
</li>
<li><ul>
<li>将所有具体的数据放在叶子节点，索引放在非叶子节点： 这样相较于B Tree 中数据也放在非叶子节点可以提高查询的效率，因为我们只需要定位一个索引。</li>
<li>叶子节点以双向链表的形式进行连接，有效的方便了比较运算的查询。B Tree 中 where 条件有大于小于的需要一个个遍历，而在 B+ Tree 中只需要通过链表就可以了。</li>
</ul>
</li>
</ul>

        <h2 id="索引在物理结构中"   >
          <a href="#索引在物理结构中" class="heading-link"><i class="fas fa-link"></i></a>索引在物理结构中</h2>
      
        <h3 id="主键索引（聚簇索引）"   >
          <a href="#主键索引（聚簇索引）" class="heading-link"><i class="fas fa-link"></i></a>主键索引（聚簇索引）</h3>
      <ul>
<li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li>
<li>一般主键索引都是采用递增的数字进行存储，因为这样的话对于索引的增删改查的操作的效率都能够有所提升。</li>
</ul>

        <h3 id="普通索引（二级索引）"   >
          <a href="#普通索引（二级索引）" class="heading-link"><i class="fas fa-link"></i></a>普通索引（二级索引）</h3>
      <ul>
<li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li>
<li>可以通过查询联合索引的方式来查询我们所需要查询的列，以提高查询效率。</li>
</ul>

        <h2 id="索引在字段特性中"   >
          <a href="#索引在字段特性中" class="heading-link"><i class="fas fa-link"></i></a>索引在字段特性中</h2>
      <p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p>

        <h2 id="索引在字段个数中"   >
          <a href="#索引在字段个数中" class="heading-link"><i class="fas fa-link"></i></a>索引在字段个数中</h2>
      <p>按照字段个数分的话，可以分为单列索引和联合索引。单列索引包括主键索引，普通索引，前面都有讲过。主要这个部分梳理联合索引的知识点。</p>

        <h3 id="联合索引的最左匹配原则"   >
          <a href="#联合索引的最左匹配原则" class="heading-link"><i class="fas fa-link"></i></a>联合索引的最左匹配原则</h3>
      <ul>
<li>定义：在建立联合索引的时候，由于最左匹配原则的约束，字段的顺序不同是会产生不一样的结果的。主要体现在以最左边的字段作为第一个的排序。如果 where 条件构建的时候，没有以最左边第一个排序作为条件出现的话，那么联合索引就会失效。我们可以认为联合索引中的个体字段（除了最左字段）是全局无序，局部有序的。</li>
</ul>
<p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p>
<ul>
<li>where a&#x3D;1；</li>
<li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li>
<li>where a&#x3D;1 and b&#x3D;2；</li>
</ul>
<p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p>
<ul>
<li>where b&#x3D;2；</li>
<li>where c&#x3D;3；</li>
<li>where b&#x3D;2 and c&#x3D;3；</li>
</ul>

        <h3 id="联合索引对于普通字段查询的优化"   >
          <a href="#联合索引对于普通字段查询的优化" class="heading-link"><i class="fas fa-link"></i></a>联合索引对于普通字段查询的优化</h3>
      <ul>
<li>优化辅助索引回表的关键在于：如果当需要的数据直接出现在叶子节点中（无论是主键索引还是辅助索引），那么sql语句解释器都会直接输出结果。那么我们就可以通过查询联合索引的方式来查询我们所需要查询的列。</li>
</ul>

        <h3 id="联合索引失效的情况"   >
          <a href="#联合索引失效的情况" class="heading-link"><i class="fas fa-link"></i></a>联合索引失效的情况</h3>
      <p><img src="/%E7%B4%A2%E5%BC%95.assets/1685291368500-476524d5-165b-4c4e-93b8-f22c80ef9a0d.png" alt="img"></p>
<p>这里我们可以看到，对于a来讲，是有序的，但是对于b来讲，是无序的。而一个索引要使用的条件必须是有序的。</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">select * from t_table where a &gt; 1 and b = 2</span><br></pre></td></tr></table></div></figure>

<ul>
<li>a字段可以通过索引进行查询，但是在a &gt; 1 的条件下，b是无序的，所以无法通过索引进行查询。所以在这个where条件中，只有a的查询能够运用得上索引。</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">select * from t_table where a &gt;= 1 and b = 2</span><br></pre></td></tr></table></div></figure>

<ul>
<li>a和b都运用到了联合索引进行排序，原因是 a 存在等于1的情况，那么在这个情况下，a固定下来，那么所有 a &#x3D; 1的行中就会执行到以 b 为索引的查询， 所以此时 b 能用得上索引。但是也是仅限于 a &#x3D; 1 的情况下。a &gt; 1仍然用不上索引。</li>
</ul>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2</span><br></pre></td></tr></table></div></figure>

<ul>
<li>在mysql中，<code>between and</code>是大于等于，小于等于的关系，所以其实和上一个的道理是一样的。只要最左的联合索引元素有等于号出现，那么第二个元素就一定能够用得上索引。</li>
</ul>
<p><code>SELECT * FROM t_user WHERE name like &#39;j%&#39; and age = 22</code>，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p>
<ul>
<li>都用到了联合索引进行排序。</li>
</ul>

        <h1 id="索引的缺点"   >
          <a href="#索引的缺点" class="heading-link"><i class="fas fa-link"></i></a>索引的缺点</h1>
      <ul>
<li>会占用一定的数据内存空间，索引过多可能带来数据库内存负担的加重。</li>
<li>创建和维护索引需要时间，这个时间会随着数据量的增大而增大。</li>
<li>会降低修改删除索引的效率，因为每一次对于索引进行修改时，B+ Tree 都会对于索引进行动态维护</li>
</ul>

        <h1 id="索引的适用范围"   >
          <a href="#索引的适用范围" class="heading-link"><i class="fas fa-link"></i></a>索引的适用范围</h1>
      <ul>
<li>唯一的不重复的非空字段，最好还能够是新增的时候有序排列的字段。当索引唯一的时候查询效率是比不唯一的索引效率要高的。非空是因为查询的时候还需要加上空字段会导致查询效率的降低。</li>
<li>经常用于查询语句 <code>where</code> 的字段，对于经常用于查询语句的字段建立索引，有利于提升查询效率</li>
<li>经常需要用于排序 <code>order by</code> 的字段，因为索引本身是有序的，所以提前对于排序字段建立好索引有利于执行sql语句的时候效率的提升。</li>
</ul>

        <h1 id="索引的不适用情况"   >
          <a href="#索引的不适用情况" class="heading-link"><i class="fas fa-link"></i></a>索引的不适用情况</h1>
      <ul>
<li>不经常用于查询，排列的字段。因为索引主要就是用于能够更好的排列顺序，如果不用那也就意味着没有必要建立索引。</li>
<li>重复度高的情况下不建议使用索引，最好是唯一字段才使用索引。内部优化器有一个规则，当索引重复度高于一个标准的时候，那么将会替换成为全局搜索。比如只有男和女的性别，各占50%，所以没有必要建立索引。</li>
<li>要经常修改的字段，因为字段的更新意味着索引的重新排序，对于数据库性能上会有一定的消耗。</li>
<li>数据量太少，没有必要建立索引。</li>
</ul>

        <h1 id="优化索引的方式"   >
          <a href="#优化索引的方式" class="heading-link"><i class="fas fa-link"></i></a>优化索引的方式</h1>
      
        <h3 id="前缀索引优化"   >
          <a href="#前缀索引优化" class="heading-link"><i class="fas fa-link"></i></a>前缀索引优化</h3>
      <p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p>
<p>不过，前缀索引有一定的局限性，例如：</p>
<ul>
<li>order by 就无法使用前缀索引；</li>
<li>无法把前缀索引用作覆盖索引；</li>
</ul>

        <h3 id="覆盖索引优化"   >
          <a href="#覆盖索引优化" class="heading-link"><i class="fas fa-link"></i></a>覆盖索引优化</h3>
      <p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>

        <h3 id="主键索引最好是自增的"   >
          <a href="#主键索引最好是自增的" class="heading-link"><i class="fas fa-link"></i></a>主键索引最好是自增的</h3>
      <p>如果我们使用了自增的主键，那么我们要插入一条数据的时候，做的事情是只需要在链表的末尾加入一个元素即可，时间复杂度不高。</p>
<p>但是如果我们使用了非自增的主键，那么我们首先要查询这个主键的大小相较于其他大小的位置，在进行插入，那么相比于尾插法明显效率是得到了提升的。而且非自增主键还会造成内存碎片的危害，浪费存储空间。</p>

        <h3 id="索引列最好设置为NOT-NULL"   >
          <a href="#索引列最好设置为NOT-NULL" class="heading-link"><i class="fas fa-link"></i></a>索引列最好设置为NOT NULL</h3>
      <p>索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂.</p>
<p>NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中至少会用 1 字节空间存储 NULL 值列表。</p>

        <h1 id="索引失效的情况"   >
          <a href="#索引失效的情况" class="heading-link"><i class="fas fa-link"></i></a>索引失效的情况</h1>
      <ul>
<li>当我们使用了左模糊匹配或者左右模糊匹配的时候，比如 <code>select * from db where name like %ming</code> 或者 <code>select * from db where name like %ming%</code> 索引会失效。原因是其是按最左前缀原则进行匹配的，即使对于字段内部也是一样，从左到右进行匹配。</li>
<li>当对索引值进行计算或者函数运算的时候，索引会失效。因为索引是根据他本身存入的值进行排序，运算后就不是原有的值了。那么解决这个问题可以将该函数设为索引。</li>
<li>设置联合索引的时候没有遵循最左匹配原则。</li>
<li>查询条件中设置or条件语句只要有一部分没有遵循索引，那么其将会进行全表查询。道理也很简单，or是求两部分的交集，即使前面用了索引后面也要进行全表查询，所以直接全部使用全表查询。</li>
</ul>

        <h1 id="count-1-count-和count-字段-哪个查询效率更高？"   >
          <a href="#count-1-count-和count-字段-哪个查询效率更高？" class="heading-link"><i class="fas fa-link"></i></a>count(1), count(*)和count(字段)哪个查询效率更高？</h1>
      <p>结论：<code>count(1) = count(*) &gt; count(主键字段) &gt; count(其他字段)</code></p>

        <h2 id="count-1-如何查询"   >
          <a href="#count-1-如何查询" class="heading-link"><i class="fas fa-link"></i></a>count(1)如何查询</h2>
      <p>当只有主键索引没有二级索引的时候：</p>
<p>InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，但是不会读取记录中的任何字段的值，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p>
<p>当存在二级索引的时候，循环遍历找值的对象就变成了二级索引了。</p>

        <h2 id="count-如何查询"   >
          <a href="#count-如何查询" class="heading-link"><i class="fas fa-link"></i></a>count(*)如何查询</h2>
      <p>count(*)在编译的时候会转换为count(0)。</p>
<p><img src="/%E7%B4%A2%E5%BC%95.assets/1685369818273-7f8047b4-9fb9-42b8-9b04-fb1664a8dbfb.png" alt="img"></p>

        <h2 id="count-字段-如何查询"   >
          <a href="#count-字段-如何查询" class="heading-link"><i class="fas fa-link"></i></a>count(字段)如何查询</h2>
      <p>对于这个查询来说，会采用全表扫描的方式来计数，所以它的执行效率是比较差的。因为他统计的是在表中该字段不为空的值的字段有几个。而count（常量）统计的是该表中有几条数据。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>锁</title>
    <url>/post/21631/</url>
    <content><![CDATA[
        <h1 id="全局锁"   >
          <a href="#全局锁" class="heading-link"><i class="fas fa-link"></i></a>全局锁</h1>
      <p>执行全局锁的命令：</p>
<figure class="highlight sql"><div class="table-container"><table><tr><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock</span><br></pre></td></tr></table></div></figure>

<p>执行命令以后，整个表都会处于只读阶段。只读阶段阻塞了如下操作：</p>
<ul>
<li>对于数据的增删改（insert， update， delete）</li>
<li>对于表结构的更改（drop，alter）</li>
</ul>
<p>主要应用场景为<strong>全局逻辑备份</strong>。</p>
<p>但是因为<code>inno DB</code>中有运用<code>read view</code>实现可重复读，修改后由于事务，数据库数据的一致性可以得到保证，所以造成无法改动的全局锁由于细粒度过大基本上被废弃。 </p>
<p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p>

        <h1 id="表级锁"   >
          <a href="#表级锁" class="heading-link"><i class="fas fa-link"></i></a>表级锁</h1>
      
        <h2 id="表锁"   >
          <a href="#表锁" class="heading-link"><i class="fas fa-link"></i></a>表锁</h2>
      <figure class="highlight sql"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>释放当前会话的所有表锁</span><br><span class="line">unlock tables</span><br></pre></td></tr></table></div></figure>


        <h2 id="元数据锁（MDL）"   >
          <a href="#元数据锁（MDL）" class="heading-link"><i class="fas fa-link"></i></a>元数据锁（MDL）</h2>
      <p>元数据锁的目的是为了防止线程对表数据进行修改的时候，对于表格式进行变更，这个锁的对象是表的数据结构。</p>
<p>它分为读锁和写锁两种锁:</p>
<ul>
<li>当对于一张表做<strong>CRUD操作</strong>的时候，他新增的是<strong>MDL读锁</strong>；</li>
<li>当对于一张表做出<strong>表结构</strong>修改的时候，他新增的是<strong>MDL写锁</strong>。</li>
</ul>
<p>MDL锁的机制是读读共享，读写互斥，写写互斥。</p>
<p>申请MDL锁的事务会生成一个队列，写锁的优先级比读锁的要高。也就是说，当一张表加上了MDL读锁，之后有一个事务想要对表结构做出修改，加上MDL写锁，那么他之后的对于想要加入CRUD操作的读锁都是位于阻塞的状态。</p>

        <h2 id="意向锁"   >
          <a href="#意向锁" class="heading-link"><i class="fas fa-link"></i></a>意向锁</h2>
      <p><strong>意向锁的目的是为了快速判断表中是否有记录被加上了行级锁。</strong></p>
<p>原因是如果没有表的锁，需要一行一行判断有无加上行级锁，效率低下，加上意向锁可以达到剪枝的效果，排除完全没有被加上行级锁的表。</p>
<ul>
<li>当用InnoDB存储引擎的时候，当对于一条记录加上了共享锁，那么会对于其表加上意向共享锁。</li>
<li>当用InnoDB存储引擎的时候，当对于一条记录加上了独占锁，那么会对于其表加上意向独占锁。</li>
</ul>
<p>共享锁和独占锁是行级锁，意向独占锁和意向共享锁是表级锁。两者互不冲突。</p>

        <h2 id="AUTO-INC锁"   >
          <a href="#AUTO-INC锁" class="heading-link"><i class="fas fa-link"></i></a>AUTO-INC锁</h2>
      <p>在插入一条数据的时候，可以不输入主键就实现主键的自增，主要通过的就是<code>auto-inc</code>锁。</p>
<p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
<p>但是这种情况在大量插入的情况下，插入语句就变成了并行操作，容易导致执行效率的低下。</p>
<p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
<p>一样也是在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
<p>这个时候减少了锁存在的时间，由新增语句完成后才释放锁提前到主键赋值完成就释放锁，减少了锁存在的时间，提高了锁的性能。</p>

        <h1 id="行级锁"   >
          <a href="#行级锁" class="heading-link"><i class="fas fa-link"></i></a>行级锁</h1>
      <figure class="highlight sql"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加共享锁</span><br><span class="line"><span class="keyword">select</span> ... lock <span class="keyword">in</span> share mode;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>对读取的记录加独占锁</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></div></figure>

<p>共享锁（S）满足读读共享，读写互斥，也就是可以被多个线程所持有。</p>
<p>独占锁（X）满足读写互斥，写写互斥，只能被一个线程所持有。</p>

        <h2 id="Record-Lock"   >
          <a href="#Record-Lock" class="heading-link"><i class="fas fa-link"></i></a>Record Lock</h2>
      <p>记录锁加锁的对象是一条数据。当对于一个事务加上了记录锁的时候，其他事务就不能对其进行修改。但是记录锁也有共享锁和独占锁的区别：</p>
<ul>
<li>当一个事务对一条记录加上了S（共享锁）的时候，其他事务仍然可以对其加上S锁，但不能对其加上X锁；</li>
<li>当一个事务对一条记录加上了X（独占锁）的时候，其他事务不能对加上S锁，也不能加上X锁。</li>
</ul>
<p>当提交时，所有的锁都会被释放。</p>

        <h2 id="Gap-Lock"   >
          <a href="#Gap-Lock" class="heading-link"><i class="fas fa-link"></i></a>Gap Lock</h2>
      <p>Gap Lock被称为间隙锁，只存在于可重复度级别，主要用于解决可重复度中的幻读问题。</p>
<p>比如表中有一个（2，5）的间隙锁，那么id &#x3D; 4的这条记录就无法再次被插入了。</p>
<p><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系。</strong></p>

        <h2 id="Next-Key-Lock"   >
          <a href="#Next-Key-Lock" class="heading-link"><i class="fas fa-link"></i></a>Next-Key Lock</h2>
      <p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>

        <h1 id="行级锁不同情况下是如何加锁的"   >
          <a href="#行级锁不同情况下是如何加锁的" class="heading-link"><i class="fas fa-link"></i></a>行级锁不同情况下是如何加锁的</h1>
      
        <h2 id="唯一索引等值查询"   >
          <a href="#唯一索引等值查询" class="heading-link"><i class="fas fa-link"></i></a>唯一索引等值查询</h2>
      <ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
</ul>
<p><img src="/%E9%94%81.assets/1685843643371-435561f7-f6e5-4db3-8ac4-7e243aa54b82.png" alt="img"></p>
<ul>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>

        <h2 id="唯一索引非等值查询"   >
          <a href="#唯一索引非等值查询" class="heading-link"><i class="fas fa-link"></i></a>唯一索引非等值查询</h2>
      <p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p>
<ul>
<li><p>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</p>
</li>
<li><p>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：</p>
</li>
<li><ul>
<li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
<li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
</ul>
</li>
</ul>

        <h2 id="非唯一索引等值查询"   >
          <a href="#非唯一索引等值查询" class="heading-link"><i class="fas fa-link"></i></a>非唯一索引等值查询</h2>
      <ul>
<li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li>
<li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li>
</ul>

        <h2 id="非唯一索引非等值查询"   >
          <a href="#非唯一索引非等值查询" class="heading-link"><i class="fas fa-link"></i></a>非唯一索引非等值查询</h2>
      <p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。</p>

        <h2 id="非索引查询"   >
          <a href="#非索引查询" class="heading-link"><i class="fas fa-link"></i></a>非索引查询</h2>
      <p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。</p>
<p>将<code>sql_safe_updates</code> 设置为1，开启安全更新模式。</p>
<p>update 语句必须满足如下条件之一才能执行成功：</p>
<ul>
<li>使用 where，并且 where 条件中必须有索引列；</li>
<li>使用 limit；</li>
<li>同时使用 where 和 limit，此时 where 条件中可以没有索引列；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/post/46132/</url>
    <content><![CDATA[
        <h1 id="1-单例模式的基本概念"   >
          <a href="#1-单例模式的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.单例模式的基本概念</h1>
      <p>整个程序全局中<strong>只能有一个属于该对象的类</strong>，并且<strong>只提供单一入口</strong>供使用者调用该类。也就是说，使用了单例模式的对象不允许在程序中出现两个相同的对象。</p>
<p>特点：</p>
<ul>
<li>单例模式全局只能有唯一实例</li>
<li>单例模式全局的唯一实例必须由其自己创建</li>
<li>单例模式必须提供其他调用方获取该实例的方法</li>
</ul>

        <h1 id="2-单例模式的适用场景"   >
          <a href="#2-单例模式的适用场景" class="heading-link"><i class="fas fa-link"></i></a>2.单例模式的适用场景</h1>
      <p>生命周期短的对象</p>
<p>频繁访问io资源的对象，如数据库连接池，redis配置等</p>
<p>只需要调用该对象方法，<strong>对该对象没有任何修改动作</strong>且频繁使用的对象</p>

        <h1 id="3-单例模式示例"   >
          <a href="#3-单例模式示例" class="heading-link"><i class="fas fa-link"></i></a>3.单例模式示例</h1>
      <p>构建单例模式，一般需要三个语句</p>
<ul>
<li>初始化<strong>静态私有</strong>成员变量</li>
<li><strong>无参</strong>构造器</li>
<li><strong>对外暴露</strong>能够得到这个对象的方法</li>
</ul>

        <h2 id="3-1-饿汉模式"   >
          <a href="#3-1-饿汉模式" class="heading-link"><i class="fas fa-link"></i></a>3.1 饿汉模式</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 初始化静态私有成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungrySingleton</span> <span class="variable">hungrySingleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 无参构造器</span></span><br><span class="line">    HungrySingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 对外暴露能够得到这个对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getHungrySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>优点：程序执行的时候就立刻初始化成员变量，在类被加载的时候就将初始化好的成员变量存放入内存中，在调用对象时运行速度会变快。</p>
<p>缺点：大量使用饿汉模式会<strong>占据一定的系统内存</strong>，导致系统运行速度变慢。</p>

        <h2 id="3-2-懒汉模式"   >
          <a href="#3-2-懒汉模式" class="heading-link"><i class="fas fa-link"></i></a>3.2 懒汉模式</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 静态私有唯一对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 空参构造器</span></span><br><span class="line">LazySingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 静态方法获取该类对象暴露(需要加锁，防止多个对象在单例模式中的创建)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getLazySingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazySingleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lazySingleton == <span class="literal">null</span>) &#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>优点：等到需要调用该类对象的时候才初始化对象，一定程度上节约了内存</p>
<p>缺点：因为防止重复创建对象加上的<strong>锁导致多人调用的时候可能运行时间会较长</strong>，接近于串行运行。</p>

        <h2 id="3-3-双检锁模式"   >
          <a href="#3-3-双检锁模式" class="heading-link"><i class="fas fa-link"></i></a>3.3 双检锁模式</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 静态私有唯一对象</span></span><br><span class="line"><span class="comment">// 这里加volatile的原因是为了防止指令重排序而引发的返回一个没有初始化完全的单例对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleton doubleCheckSingleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 空参构造器</span></span><br><span class="line">DoubleCheckSingleton() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 静态方法获取该类对象暴露(需要加锁，防止多个对象在单例模式中的创建)</span></span><br><span class="line"><span class="comment">// 再加一层判断，需要创建新对象的时候才用到锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleton <span class="title function_">getDoubleCheckSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (doubleCheckSingleton == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DoubleCheckSingleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (doubleCheckSingleton == <span class="literal">null</span>) &#123;</span><br><span class="line">                doubleCheckSingleton = <span class="keyword">new</span> <span class="title class_">DoubleCheckSingleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> doubleCheckSingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ol>
<li><p><code>volatile</code>关键字：可以保证可见性和防止指令重排序，预防极端情况下因为指令重排序而引发的返回一个没有初始化完全的单例对象。</p>
</li>
<li><p>双检锁两层判断的意义：</p>
</li>
<li><ol>
<li>第一层，判断是否已经获得了单例对象，如果获得了，没必要增强，直接使用，为了提高<strong>效率</strong></li>
<li>第二层，锁内判断，防止获取两个单例对象，为了保证<strong>单例对象的唯一性</strong></li>
</ol>
</li>
</ol>

        <h2 id="3-4-静态内部类模式"   >
          <a href="#3-4-静态内部类模式" class="heading-link"><i class="fas fa-link"></i></a>3.4 静态内部类模式</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticClassSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">innerStaticClassHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">StaticClassSingleton</span> <span class="variable">STATIC_CLASS_SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticClassSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    StaticClassSingleton()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StaticClassSingleton <span class="title function_">getStaticClassSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> innerStaticClassHolder.STATIC_CLASS_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>静态内部类单例模式：基本和双检锁差不多，都是调用后才创建对象，也能保证对象的唯一性</p>
<p>但是只能运用在静态方法类中 可保证线程安全(没有任何new的操作)，也能保证单例的唯一性，同时也延迟了单例的实例化。</p>

        <h2 id="3-5-枚举模式"   >
          <a href="#3-5-枚举模式" class="heading-link"><i class="fas fa-link"></i></a>3.5 枚举模式</h2>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例模式：防止反序列化造成的单例破坏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    ENUM_SINGLETON;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title function_">getEnumSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ENUM_SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>防止反序列化造成的单例破坏</p>
<p>推荐使用静态内部类模式，因为他不用new对象，不会产生多个对象的问题；</p>
<p>推荐使用枚举模式，因为他可以防止反序列化造成的单例破坏</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/post/6013/</url>
    <content><![CDATA[
        <h1 id="1-定义"   >
          <a href="#1-定义" class="heading-link"><i class="fas fa-link"></i></a>1.定义</h1>
      <p>该模式用来<strong>封装和管理类的创建</strong>，终极目的是为了<strong>解耦</strong>，实现<strong>创建者和调用者的分离</strong>。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，而是通过使用一个共同的接口来指向新创建的对象。这个接口可以留给子类自行选择用这个工厂生产什么类型的产品。</p>
<p><strong>工厂模式的本质就是对获取对象过程的抽象。</strong></p>

        <h1 id="2-适用范围"   >
          <a href="#2-适用范围" class="heading-link"><i class="fas fa-link"></i></a>2.适用范围</h1>
      <p>很多场景中都能够适用，比如spring中的beanFactory工厂。能生产多个具有一定相似度对象的都可以由工厂模式来进行处理。</p>

        <h1 id="3-实例"   >
          <a href="#3-实例" class="heading-link"><i class="fas fa-link"></i></a>3.实例</h1>
      
        <h2 id="3-1-简单工厂模式"   >
          <a href="#3-1-简单工厂模式" class="heading-link"><i class="fas fa-link"></i></a>3.1 简单工厂模式</h2>
      
        <h3 id="结构图"   >
          <a href="#结构图" class="heading-link"><i class="fas fa-link"></i></a>结构图</h3>
      <p><img src="/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.assets/1684038427084-b8249039-1a52-4c17-bc40-03e69f9444bd.png" alt="img"></p>
<p>这是一个学生选课的系统，很符合工厂模式的供给。老师不可能自己凭空创造课程，而应该是学校教务创建好课程之后让老师去选择自己想要传授的课程。而工厂模式能给我们提供这样的选择，他通过<code>ClassFactory</code>类<strong>对外暴露了创建课程的接口</strong>， 但具体的创建流程是完全封装起来的。能够保证安全性和实现解耦合。</p>
<p>其中在这个简单工厂模式中，我们需要实现三个内容：</p>
<ul>
<li>工厂类（需要对外暴露生产产品的方法以及需要提供的参数，以及原材料提供，但是无需暴露生产逻辑）</li>
<li>抽象产品类</li>
<li>具体产品类</li>
</ul>

        <h3 id="工厂类"   >
          <a href="#工厂类" class="heading-link"><i class="fas fa-link"></i></a>工厂类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Class <span class="title function_">createClass</span><span class="params">(String className)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (className) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;computerNet&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ComputerNet</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;DataStruct&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataStruct</span>();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;OperatorSystem&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OperatorSystem</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们会发现，这里还有很多的条件分支语句，这就是简单工厂模式的一个缺点，扩展性不强。后续需要工厂生产新产品的时候需要对源代码的逻辑产生修改，不符合开闭原则。我们可以用<strong>策略模式</strong>对其进行优化。</p>

        <h3 id="抽象课程类"   >
          <a href="#抽象课程类" class="heading-link"><i class="fas fa-link"></i></a>抽象课程类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Class</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getTeacher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="具体课程类"   >
          <a href="#具体课程类" class="heading-link"><i class="fas fa-link"></i></a>具体课程类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OperatorSystem</span> <span class="keyword">extends</span> <span class="title class_">Class</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;操作系统&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTeacher</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;我嫩爹&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-2-工厂方法模式"   >
          <a href="#3-2-工厂方法模式" class="heading-link"><i class="fas fa-link"></i></a>3.2 工厂方法模式</h2>
      <p>定义一个抽象的接口，让子类决定实例化哪个类。</p>

        <h3 id="结构图-1"   >
          <a href="#结构图-1" class="heading-link"><i class="fas fa-link"></i></a>结构图</h3>
      <p><img src="/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.assets/1684045138655-a8e5ffed-17b9-4a04-bdf1-00ffc0db74bf.png" alt="img"></p>
<p>定义一个抽象方法工厂类，每一个具体的课程对象都有具体的工厂类进行创建，<strong>具体的实现交由子类进行处理，****工厂方法将对象的实例化推迟到了子类</strong>，便于后期的维护和扩展，之后如果需要新增课程的话，只需要再建立一个新的工厂对象去继承抽象工厂即可，对原来的代码没有影响。</p>

        <h2 id="3-3-抽象工厂模式"   >
          <a href="#3-3-抽象工厂模式" class="heading-link"><i class="fas fa-link"></i></a>3.3 抽象工厂模式</h2>
      <p>在抽象工厂类中新增创建该产品的抽象方法，然后在具体工厂子类中实现它即可。相当于工厂模式的一种拓展。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/post/58639/</url>
    <content><![CDATA[
        <h1 id="1-定义"   >
          <a href="#1-定义" class="heading-link"><i class="fas fa-link"></i></a>1.定义</h1>
      <p>其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。<br>其主要目的是通过定义相似的算法，替换if else 语句写法，并且可以随时相互替换。</p>

        <h1 id="2-结构图"   >
          <a href="#2-结构图" class="heading-link"><i class="fas fa-link"></i></a>2.结构图</h1>
      <p><img src="/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.assets/1684052516266-83d31e2f-2ecc-4a43-9f45-1fbdc92a7517.png" alt="img"></p>
<ul>
<li>环境角色(Context)：持有一个策略类的引用，提供给客户端使用。</li>
<li>抽象策略角色(Strategy)：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略角色(ConcreteStrategy)：包装了相关的算法或行为。</li>
</ul>

        <h1 id="3-实例"   >
          <a href="#3-实例" class="heading-link"><i class="fas fa-link"></i></a>3.实例</h1>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyUseService</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;UpgradeWay, Upgrade&gt; upgradeMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">deResolve</span><span class="params">(UpgradeWay upgradeWay, Long experience)</span> &#123;</span><br><span class="line">        upgradeWay = Optional.ofNullable(upgradeWay).orElse(UpgradeWay.SLEEP);</span><br><span class="line">        <span class="type">Upgrade</span> <span class="variable">upgrade</span> <span class="operator">=</span> upgradeMap.get(upgradeWay);</span><br><span class="line">        <span class="keyword">if</span>(upgrade == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> upgrade.resolve(experience);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring初始化初始化时候即初始化各种策略</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Map&lt;String, Upgrade&gt; beansOfType = applicationContext.getBeansOfType(Upgrade.class);</span><br><span class="line">        beansOfType.values().forEach(strategyService  -&gt; upgradeMap.put(strategyService.gainUpgradeWay(), strategyService));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Upgrade</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取策略类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 策略类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UpgradeWay <span class="title function_">gainUpgradeWay</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体实现逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> experience 原有经验值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">resolve</span><span class="params">(Long experience)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>



<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepUpgrade</span> <span class="keyword">implements</span> <span class="title class_">Upgrade</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UpgradeWay <span class="title function_">gainUpgradeWay</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UpgradeWay.SLEEP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">resolve</span><span class="params">(Long experience)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.gainUpgradeWay().getValue() + experience;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/post/7738/</url>
    <content><![CDATA[
        <h1 id="1-定义"   >
          <a href="#1-定义" class="heading-link"><i class="fas fa-link"></i></a>1.定义</h1>
      <p>观察者模式定义了一种一堆多的依赖关系，当一个对象的状态发生改变时，所有依赖于它对象都会得到通知。观察者模式也被成为发布-订阅模式。实现了解耦，在需要新增一个观察者的时候只需要new一个出来，然后注册到主题对象就可以了，在观察者不需要观察该主题对象，只需要在主题对象的观察者列表中去除该观察者对象即可。</p>

        <h1 id="2-结构图"   >
          <a href="#2-结构图" class="heading-link"><i class="fas fa-link"></i></a>2.结构图</h1>
      <p><img src="/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.assets/1684047286505-98076c31-46e4-4ebe-b0ec-7080c0d6d71f.png" alt="img"></p>
<ul>
<li><code>Subject</code>: 被观察者的对象抽象类。其中包含了观察者的集合，添加和删除观察者的方法。还有通知观察者观察对象已改变的方法</li>
<li><code>Observer</code>：抽象观察者类。只有一个响应接口，响应接口中定义了被观察者。响应接口除了需要做出需要做的事情之外，还需要将自己注册到被观察者中去。</li>
</ul>

        <h1 id="3-实例"   >
          <a href="#3-实例" class="heading-link"><i class="fas fa-link"></i></a>3.实例</h1>
      
        <h3 id="被观察者的对象抽象类"   >
          <a href="#被观察者的对象抽象类" class="heading-link"><i class="fas fa-link"></i></a>被观察者的对象抽象类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察的对象父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个集合存储被观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Observer&gt; observerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加监听者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除监听者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteObserver</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做出什么事情后，监听者会有所反应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">signature</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">report</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer : observerList) &#123;</span><br><span class="line">            observer.response(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="观察者抽象类"   >
          <a href="#观察者抽象类" class="heading-link"><i class="fas fa-link"></i></a>观察者抽象类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 监听者的反应</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Subject subject)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="具体被观察者类"   >
          <a href="#具体被观察者类" class="heading-link"><i class="fas fa-link"></i></a>具体被观察者类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">signature</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我要吃饭呜呜呜&quot;</span>);</span><br><span class="line">        report();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>




        <h3 id="具体观察者类"   >
          <a href="#具体观察者类" class="heading-link"><i class="fas fa-link"></i></a>具体观察者类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">response</span><span class="params">(Subject subject)</span> &#123;</span><br><span class="line">        subject.addObserver(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;老师说：好好学习，以后每顿都能吃上两个肉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/post/32766/</url>
    <content><![CDATA[
        <h1 id="1-数组的基础定义"   >
          <a href="#1-数组的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 数组的基础定义</h1>
      <ul>
<li>数组的下标是从0开始的</li>
<li>数组中的地址是连续的</li>
</ul>
<p>要删除数组中的元素只能用替换去实现，无法直接删去</p>
<hr>

        <h1 id="2-二分法"   >
          <a href="#2-二分法" class="heading-link"><i class="fas fa-link"></i></a>2. 二分法</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/binary-search/description/" >Problem 704. 二分查找</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>类似参考题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/search-insert-position/" >Problem 35.搜索插入位置 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" >Problem 34.在排序数组中查找元素的第一个和最后一个位置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="2-1-使用条件"   >
          <a href="#2-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>2.1 使用条件</h2>
      <p>在求解寻找数组中的元素，或者满足条件的值会出现在数组的范围内（如求平方根）等内容时可使用；</p>
<p>使用时数组需满足如下条件（或变化后）：</p>
<ul>
<li>数组升序或者降序排列，即有序数组</li>
<li>数组中无重复项的出现</li>
</ul>

        <h2 id="2-2-时间复杂度"   >
          <a href="#2-2-时间复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.2 时间复杂度</h2>
      <ul>
<li>暴力解法时间复杂度：<code>O(n)</code></li>
<li>二分法时间复杂度：<code>O(logn)</code></li>
</ul>

        <h2 id="2-3-主要思想"   >
          <a href="#2-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.3 主要思想</h2>
      <p>通过在有序数组中<strong>划分中间值</strong>，判断所求值与中间值之间的关系，较暴力解法可以<strong>直接排除掉</strong>一些不在范围之内的比较，提升了运行效率。</p>
<p><mark>有序数组：索引定位数据，索引的大小关系即为数组元素的大小关系。</mark></p>
<p>要定义的几个参数：</p>
<p>开始位置：<code>left = 0;</code>（数组下标索引从0开始）</p>
<p>结束位置：<code>right = nums.size() - 1;</code> </p>
<p>中间值：<code>mid = left + ((right - left) &gt;&gt; 1) </code> (位运算，可以防止数组越界现象出现)</p>

        <h2 id="2-4-注意点"   >
          <a href="#2-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.4 注意点</h2>
      <ul>
<li>区间的划分</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原因是此时mid的值一定不是我们寻找的，否则不会出现在这个循环，那么我们在移动的时候也可以不考虑这个值</span></span><br><span class="line"><span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>循环终止判断条件</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="2-5-完整代码"   >
          <a href="#2-5-完整代码" class="heading-link"><i class="fas fa-link"></i></a>2.5 完整代码</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//定义数组的左节点</span></span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//定义数组的右节点</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//定义中间点，防止索引越界</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target == nums[mid]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h1 id="3-双指针法"   >
          <a href="#3-双指针法" class="heading-link"><i class="fas fa-link"></i></a>3. 双指针法</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/remove-element/" >Problem 27.移除元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/squares-of-a-sorted-array/" >Problem 977.有序数组的平方</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-1-使用条件"   >
          <a href="#3-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>3.1 使用条件</h2>
      <p>需要双重遍历：需要实现先定位元素，再实现元素修改的题目，都可以用双指针法。</p>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针<mark>在一个for循环下完成两个for循环</mark>的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向<mark>更新</mark>新数组下标的位置</li>
</ul>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p><code>fastIndex</code>指针用来寻找要<strong>删除</strong>的值，<code>slowIndex</code>指针用来定位要<strong>修改</strong>的值</p>
<p>在删除元素这道题目中，体现在<code>fastIndex</code>在一直在移动，而通过判断<code>if(nums[fastIndex] != val) </code>来控制是否替换，相当于核心思想是在<mark>原有的数组上替换了一个新的数组，这个数组元素所要满足的条件就是if判断的条件</mark>。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>用双指针移动删除元素可以使得时间复杂度下降，只需要一个循环遍历即可，一个指针用来寻找删除元素，另一个指针用来实现替换操作。 这里用for循环，不用while循环的原因是： for循环一般用于有终止条件，变量只有一个并且判断条件可以简单的用一个boolean表达式表现出来，而while循环主要用于迭代条件较为复杂，例如二分查找法的情况，左右节点都需要根据不同情况进行更新。 而在双指针中，fastIndex指针是无条件一直向前运行的，我们只需在循环体中控制slowIndex指针即可。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针删除元素 fast指针用于搜索，slow指针用于替换值</span></span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束条件，搜索指针搜索完成。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex ++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p><font size=4><strong>双指针Pro（相向双指针）：</strong></font></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">            <span class="comment">// 找左边等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边不等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">                rightIndex-- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line">            <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">                nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;   <span class="comment">// leftIndex一定指向了最终数组末尾的下一个元素，原因是因为有几个val就代表被中断了几次，此时只有单向运动，长度就会缩减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="4-滑动窗口"   >
          <a href="#4-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4. 滑动窗口</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/minimum-size-subarray-sum/" >Problem 209.长度最小的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>

        <h2 id="4-1-使用条件"   >
          <a href="#4-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>4.1 使用条件</h2>
      <p>数组中满足条件的最小子数组。一般求解需要经过两个步骤，首先需要先判断出有哪些满足条件的情况<strong>存在</strong>。之后再去这些满足条件存在中求解<strong>最优</strong>。</p>
<p>一般会出现如下条件需要去定义：</p>
<ul>
<li>滑动窗口的起始点（可以理解为快指针）</li>
<li>滑动窗口的终止点（可以理解为慢指针）</li>
<li>滑动窗口内条件的表示：例如最大值，元素相等之类的</li>
</ul>

        <h2 id="4-2-复杂度"   >
          <a href="#4-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
</ul>
<blockquote>
<p>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
</blockquote>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="4-3-主要思想"   >
          <a href="#4-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.3 主要思想</h2>
      <p>时间复杂度的优化其实可以简略的看成循环的优化，而循环优化的最主要思想之一就是<mark>能否对相关项进行合并</mark>。换而言之就是变量之间能不能够相互解释。</p>
<p>对比暴力解法和滑动窗口能够发现其精妙之处：</p>
<ul>
<li>暴力解法：判断满足条件的子数组存在（一层遍历） &#x3D;&#x3D;&#x3D;&gt; 子数组内判断是否最优（存在遍历中的遍历）&#x3D;&#x3D;&#x3D;&gt; 比较</li>
<li>滑动窗口：移动终止点去判断是否存在 &#x3D;&#x3D;&#x3D;&gt; 移动起始点去求最优</li>
</ul>
<p>这时候我们会发现，其实滑动窗口用了条件这个东西同时判断了两个值， 而暴力解法则是在数组内部又进行了一个数组的判断，所以我们其实可以用两个点窗口大小去表示条件的时候，这样做就相当于实现了循环次数的减少。</p>

        <h2 id="4-4-注意点"   >
          <a href="#4-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.4 注意点</h2>
      <ol>
<li><p>求和的操作很巧妙，融合在一起表现在头指针移动会影响到数组和值，尾指针移动也能够影响到数组的和值。</p>
</li>
<li><p>数组最小长度的迭代更新，首先直接替换肯定不行，因为无法确定最后一个就是最小的。然后自己比自己求最小也不行，因为你需要一个0的初始值。所以在这里需要引入一个新的变量，result &#x3D; INT32_MAX。</p>
</li>
</ol>
<blockquote>
<p>INT32_MAX是一个常量，表示极大值，主要作用是有值时第一次比较时一定会被替换成result, 如果没有被比较到，那么最后返回结果用三元运算符返回0即可。</p>
</blockquote>

        <h2 id="4-5-代码实现"   >
          <a href="#4-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为其要变化两个量：最小数组的开始值，数组的长度，所以可能需要两次for循环来找到答案</span></span><br><span class="line">        <span class="comment">//滑动窗口法:将结果看成是变化，找到大于target的数组，之后不断缩小，贪心算法？</span></span><br><span class="line">        <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="comment">//小于等于是考虑末值的条件</span></span><br><span class="line">        <span class="keyword">for</span>(;fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="comment">//求和放在和</span></span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                length = (fastIndex - slowIndex + <span class="number">1</span>) ;</span><br><span class="line">                result = result &gt; length ? length : result;</span><br><span class="line">                sum -= nums[slowIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="5-螺旋矩阵"   >
          <a href="#5-螺旋矩阵" class="heading-link"><i class="fas fa-link"></i></a>5. 螺旋矩阵</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/spiral-matrix-ii/" >Problem 59.螺旋矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-使用条件"   >
          <a href="#5-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>5.1 使用条件</h2>
      <p>题目告诉你要用螺旋矩阵，没有什么特别算法的意思，更多的是体现了一种对语言的运用和流程的表述</p>

        <h2 id="5-2-复杂度"   >
          <a href="#5-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.2 复杂度</h2>
      
        <h2 id="5-3-主要思想"   >
          <a href="#5-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.3 主要思想</h2>
      <p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>

        <h2 id="5-4-注意点"   >
          <a href="#5-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.4 注意点</h2>
      <p>开闭区间的判断</p>

        <h2 id="5-5-代码实现"   >
          <a href="#5-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.5 代码实现</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/post/60015/</url>
    <content><![CDATA[
        <h1 id="1-基本概念"   >
          <a href="#1-基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.基本概念</h1>
      <p>这是一个可以说是过关斩将的设计模式，责任链就像是一道道关卡，你只有闯过了上一关，才能到达下一关继续闯荡。在责任链模式里，很多对象由<strong>每一个对象对其下家的引用</strong>而连接起来形成一条链。请求在这个链上传递，<strong>直到链上的某一个对象决定处理此请求</strong>。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>

        <h1 id="2-责任链模式的使用场景"   >
          <a href="#2-责任链模式的使用场景" class="heading-link"><i class="fas fa-link"></i></a>2.责任链模式的使用场景</h1>
      <ul>
<li>多条件流程判断：权限控制（此处指的是嵌套的循环判断）</li>
<li>ERP 系统流程审批：总经理、人事经理、项目经理</li>
<li>Java 过滤器的底层实现 Filter</li>
</ul>

        <h1 id="3-结构图"   >
          <a href="#3-结构图" class="heading-link"><i class="fas fa-link"></i></a>3.结构图</h1>
      <p><img src="/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.assets/1684046209393-3b485f3a-2769-482f-9ea2-74b557d1645e.png" alt="img"></p>
<ul>
<li><code>AbstractHandler</code>抽象责任人类：提供一个抽象类模板供下属责任人实现。有两个部分：其一是连接下一个责任人的对象以及其getter，setter方法；以及具体责任人要做的事情</li>
<li><code>Son</code>具体责任人类：实现抽象责任人类，并后续会连接起来。</li>
</ul>

        <h1 id="4-具体实现"   >
          <a href="#4-具体实现" class="heading-link"><i class="fas fa-link"></i></a>4.具体实现</h1>
      
        <h3 id="抽象责任人类"   >
          <a href="#抽象责任人类" class="heading-link"><i class="fas fa-link"></i></a>抽象责任人类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractHandler nextAbstractHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextAbstractHandler</span><span class="params">(AbstractHandler nextAbstractHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nextAbstractHandler = nextAbstractHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractHandler <span class="title function_">getNextAbstractHandler</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nextAbstractHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="具体责任人类"   >
          <a href="#具体责任人类" class="heading-link"><i class="fas fa-link"></i></a>具体责任人类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(0)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstPass</span> <span class="keyword">extends</span> <span class="title class_">AbstractHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(score &gt; <span class="number">60</span> &amp;&amp; <span class="built_in">this</span>.getNextAbstractHandler() != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.getNextAbstractHandler().checkScore(score);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;很遗憾，没有通过第一关&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>记得加上<code>@Component</code>注解之后才能在spring初始化的时候被注入，<code>@Order(0)</code>表示位于该链条的顺序。</p>

        <h3 id="初始化类"   >
          <a href="#初始化类" class="heading-link"><i class="fas fa-link"></i></a>初始化类</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChainService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractHandler&gt; abstractHandlerList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractHandler abstractHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; SCORE = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initAbstractHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; abstractHandlerList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">                abstractHandler = abstractHandlerList.get(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">AbstractHandler</span> <span class="variable">current</span> <span class="operator">=</span> abstractHandlerList.get(i - <span class="number">1</span>);</span><br><span class="line">                <span class="type">AbstractHandler</span> <span class="variable">next</span> <span class="operator">=</span> abstractHandlerList.get(i);</span><br><span class="line">                current.setNextAbstractHandler(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getScore</span><span class="params">(<span class="type">int</span> score)</span> &#123;</span><br><span class="line">        SCORE.add(abstractHandler.checkScore(score));</span><br><span class="line">        <span class="keyword">return</span> SCORE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>责任链初始化</p>
<p>首先在spring初始化前准备一个存储责任链模板元素的list集合用来存储责任链元素（列表会自动装配其类型的bean元素）</p>
<p>用<code>@PostConstruct</code>注解，将零散的责任链链条组装，成为一个完整的责任链。</p>
<p>还可以用枚举值的方式进行注入</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2.LinkList</title>
    <url>/post/11079/</url>
    <content><![CDATA[
        <h1 id="1-链表的基础定义"   >
          <a href="#1-链表的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 链表的基础定义</h1>
      
        <h2 id="1-1-主要组成"   >
          <a href="#1-1-主要组成" class="heading-link"><i class="fas fa-link"></i></a>1.1 主要组成</h2>
      <ul>
<li><code>data</code>域： 用于存储每一个节点的<strong>数据</strong></li>
<li><code>next</code>域： 用于存储指向下一个节点的<strong>指针</strong></li>
</ul>

        <h2 id="1-2-特点"   >
          <a href="#1-2-特点" class="heading-link"><i class="fas fa-link"></i></a>1.2 特点</h2>
      <ul>
<li>最后指向null，意味着链表的结束。</li>
<li>可以无限扩容，通过指针指向其他元素可以实现空间的扩大。</li>
<li><mark>存储结构特点</mark>：链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</li>
<li>相较于数组而言，插入，删除方便，查找不方便（需要一个一个去找）</li>
</ul>

        <h2 id="1-3-图表写法"   >
          <a href="#1-3-图表写法" class="heading-link"><i class="fas fa-link"></i></a>1.3 图表写法</h2>
      <p><img src="/images/LinkListStructure.png"></p>

        <h2 id="1-4-相关类型"   >
          <a href="#1-4-相关类型" class="heading-link"><i class="fas fa-link"></i></a>1.4 相关类型</h2>
      <p>近似的我们可以分为如下几种类型：</p>
<ul>
<li><font size=4><b>单链表</b></font><br>如上图，是一般的数据模型形式。<br><br></li>
<li><font size=4><b>双链表</b></font><br>在单链表的基础上增加了一个<code>next</code>域，即一个节点有两个<code>next</code>域，一个指向前面的节点，一个指向后面的节点。这样能够一定程度上提高查找的效率。<br><img src="/images/doubleLinkList.png"><br></li>
<li><font size=4><b>循环链表</b></font><br>即最后的<code>next</code>指向的是<code>head</code>，实现了链表的循环。可以解决约瑟夫环问题。<br><img src="/images/circleLinkList.png"></li>
</ul>

        <h2 id="1-5-数据结构相关操作"   >
          <a href="#1-5-数据结构相关操作" class="heading-link"><i class="fas fa-link"></i></a>1.5 数据结构相关操作</h2>
      <p>下面是链表有关的数据结构操作：</p>
<ul>
<li><font size=4><b>初始化链表结构</b></font><figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Struct LinkNode&#123;</span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 定义data域内容</span></span><br><span class="line">    ListNode *next; <span class="comment">//指向ListNode类型元素的指针</span></span><br><span class="line">    <span class="comment">// 构造函数的初始化</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="built_in">data</span>(x);</span><br><span class="line">        <span class="built_in">next</span>(null)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br></li>
<li><font size=4><b>初始化节点</b></font><br><code>ListNode* head = new ListNode(5);</code><br><br><br></li>
<li><font size=4><b>删除节点</b></font></li>
</ul>
<p>链表节点删除的主要思想有两个，第一个是<strong>寻找到要删除的位置</strong>，这个很简单实现，比对要删除的元素和指针指向的元素是否相等，如果不相等就<code>p = p-&gt;next</code>，移动到下个节点即可，难点是理解确定寻址指针指向的位置和删除元素的位置关系。而<mark>寻址指针指向的位置是删除元素的前一格</mark>，这个和后面具体删除的思想有关。</p>
<p>第二个是<strong>删除的过程操作</strong>，其中细化出来有两步，第一步是指向要删除的节点，之后直接<code>delete</code>带走即可，第二步是将原来指向删除节点的<code>next</code>域指针指向删除节点的下一个。综合这两个我们可以发现在删除节点前一个节点要做的事情是可以和其他联系起来的，他的<code>next</code>指向的就是删除的，而他的<code>next</code>我们后续也要进行操作。所以这就回应了第一个寻址思想的难点。<br><br><br><img src="/images/LinkListDel.png"><br><strong>实现代码如下：</strong></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteElem</span><span class="params">(link L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link p=L,q;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p||!p-&gt;next)</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;输出位置不合法&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br>
- <font size=4><b>增加节点</b></font>

<p>很简单也是两步操作，<strong>第一步是定位</strong>，定位和操作和删除的差不多；<strong>第二步是增加</strong>，那么应该怎么增加呢？我们需要新引入一个指针来进行节点赋值和节点位置的操作，<u>节点赋值</u>很简单，就是<code>s-&gt;data = elem</code>，<u>节点的位置</u>也不难，因为插入元素，即要插入位置的原来节点得给你让出来，你要干他的事情，你的<code>next</code>就要指向原来节点的<code>next</code>即，<code>s-&gt;next = p-&gt;next</code>，那么你要成为他的一部分得连起来，那么原来的<code>next</code>就要指向你的元素，即<code>p-&gt;next = s</code>。<mark>注意这两步的顺序不可以搞反</mark>。<br><br><br><img src="/images/addElem.png"><br><br><br>代码如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddElem</span><span class="params">(link &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link p = L, s;</span><br><span class="line"> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> p = p-&gt;next;</span><br><span class="line"> j++;</span><br><span class="line"> &#125; <span class="comment">//搜索插入的位置</span></span><br><span class="line"> <span class="keyword">if</span>(!p)</span><br><span class="line">	 &#123;cout&lt;&lt;<span class="string">&quot;增加位置不合法&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> s = <span class="keyword">new</span> Node; <span class="comment">//为新节点创建位置</span></span><br><span class="line"> s-&gt;Data = e; <span class="comment">//赋值</span></span><br><span class="line"> s-&gt;next = p-&gt;next;</span><br><span class="line"> p-&gt;next = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><font size=4><b>寻找data所对应的节点</b></font><br>删除增加的基础，不再赘述。</li>
</ul>
<hr>

        <h1 id="2-链表设计"   >
          <a href="#2-链表设计" class="heading-link"><i class="fas fa-link"></i></a>2. 链表设计</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/remove-linked-list-elements/" >Problem 203. 移除链表元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/design-linked-list/" >Problem 707. 设计链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>很好的数据结构方式，也是数据结构这门课中第一次学到的关于指针类型的数据结构，有一定的难度，又是我们的启蒙，是一门十分值得敬畏的章节。加油吧。不管前路怎么艰辛，这总是你的第一站，第一站总是会变的比较有难度一些的，那么你就一定要坚持下去，同时照顾好自己的身体，资本要有，但挥霍资本的资本也要有。</p>
</blockquote>

        <h2 id="2-1-复杂度"   >
          <a href="#2-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.1 复杂度</h2>
      <p>大部分是<code>O(n)</code></p>

        <h2 id="2-2-主要思想"   >
          <a href="#2-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.2 主要思想</h2>
      <p>这里学到了一个比较重要的东西叫做虚拟头节点，他存在的意义是为了让处理头结点的时候和处理其他节点一样的自然。因为链表这种数据结构本身具有一定的局限性，其头节点无法用next指向，所以设置一个虚拟头节点，可以让头节点获得和其他节点一样的待遇。</p>

        <h2 id="2-3-注意点"   >
          <a href="#2-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.3 注意点</h2>
      <ul>
<li>注意什么时候需要定位到要操作节点的前一个节点，什么时候要确定的定位到那个要操作的节点。要操作节点的前一个节点主要用于添加和删除这两个操作，因为他们都需要用到前一个节点的next指针，来指向下一个节点方能对他们进行操作。而确定的定位到要操作的节点则是根据index取值的操作。</li>
<li>需要警惕提防节点们，因为节点们在你每次更改next域之后，他们之间的关系就进行了一次大洗牌，所以在新增和删除节点的时候一定要按步骤操作好。</li>
<li>有索引就有越界问题，一定看看要搜索定位的索引是否越界或者不存在。</li>
<li>用好<code>while(index--)</code>的写法，他其实和<code>for(int i = 0; i++; i &lt; index)</code>是一样的，但是他的优点就是能加上一些<code>&amp;&amp;</code>，从而可以做出一些防止越界的举动。</li>
<li>记得在操作的时候时刻不要拿着最原始的head变量去操作，因为要返回head的时候能够帮你直接定位，而用一些替代值去进行操作就好了。</li>
</ul>

        <h2 id="2-4-代码实现"   >
          <a href="#2-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>2.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode* next;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">//长度</span></span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(<span class="number">0</span>); <span class="comment">//虚拟头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有下标需要考虑越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(index --) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        cur -&gt; next = dummyHead -&gt; next;</span><br><span class="line">        dummyHead -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        <span class="comment">//把尾节点给找出来</span></span><br><span class="line">        <span class="keyword">while</span>(p -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小于零则在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界则无效</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//虚拟头节点的建立</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">		<span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">    			ListNode* tmp = cur-&gt;next;</span><br><span class="line">        		cur-&gt;next = cur -&gt;next-&gt;next;</span><br><span class="line">        		<span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">        		cur = cur -&gt; next;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		head = dummyHead-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> dummyHead;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        LinkNode* dummyHead;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="3-链表翻转"   >
          <a href="#3-链表翻转" class="heading-link"><i class="fas fa-link"></i></a>3. 链表翻转</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 206 链表翻转</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p>只要实现链表的转向即可，那么就需要有一前一后两个节点，来实现转向的操作，于是链表的转向就可以实现了。 其实这里又是双指针的另一个应用场景，双指针只要涉及到需要对两个东西同时进行操作，他都能够派上用场。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>我感觉这道题没有什么要注意的东西，就算要有吧，也就是要注意转移到下一个节点进行翻转的时候，定位要不能定next了，因为操作过后已经转移了，所以要在翻转前就给<code>cur-&gt;next</code>给标记上temp。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//临时节点，用来存储要操作的下一个节点的</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>; <span class="comment">//指向头节点的前一个节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">//指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next; <span class="comment">//标记</span></span><br><span class="line">            cur-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = cur; <span class="comment">//下一组</span></span><br><span class="line">            cur = temp; <span class="comment">//下一组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="4-两两交换链表中的节点"   >
          <a href="#4-两两交换链表中的节点" class="heading-link"><i class="fas fa-link"></i></a>4. 两两交换链表中的节点</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 24 两两交换链表中的节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="4-1-复杂度"   >
          <a href="#4-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="4-2-主要思想"   >
          <a href="#4-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.2 主要思想</h2>
      <p>要关注好移动的顺序，这道题是很好的让人们能够关注流程顺序的一道题目。<br><img src="/images/LinkListturn.png"></p>

        <h2 id="4-3-注意点"   >
          <a href="#4-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.3 注意点</h2>
      <p>关注好移动的顺序</p>

        <h2 id="4-4-代码实现"   >
          <a href="#4-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode* cur = p;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* temp = cur-&gt;next; <span class="comment">//临时节点1</span></span><br><span class="line">        ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//临时节点2</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//第一步操作，头节点-&gt;第二个</span></span><br><span class="line">        cur-&gt;next-&gt;next = temp; <span class="comment">//第二步操作，第二个-&gt;第一个</span></span><br><span class="line">        cur-&gt;next-&gt;next-&gt;next = temp1; <span class="comment">//第三步操作，第一个-&gt;第三个</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="5-删除列表的倒数第n个节点"   >
          <a href="#5-删除列表的倒数第n个节点" class="heading-link"><i class="fas fa-link"></i></a>5. 删除列表的倒数第n个节点</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" >Problem 19. 删除列表的倒数第n个节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-复杂度"   >
          <a href="#5-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="5-2-主要思想"   >
          <a href="#5-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.2 主要思想</h2>
      <p>还是双指针，删除这种东西好像最好双指针了，一个用来指代他的条件，另一个指针来指向要删除的值，具体而言在这道题上就是慢指针是用来指代值的，快指针的条件判断在于，倒数第几个就移动几次，终止条件本来从虚拟头节点出发到nullptr就遍历完了，那么我们删除倒数第几个就派出另一个往前先走几步就行了，那么先出发的那个到达nullptr的时候就是真正删除的那一个到达要删除的时候。 </p>

        <h2 id="5-3-注意点"   >
          <a href="#5-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.3 注意点</h2>
      <p>就是我们的前进的时候用while循环，其实<code>for(int i=0; i++; i&lt;n)</code>和<code>while(n--)</code>是等价的，但是要考虑他是否越界，所以要添加上<code>fast != null</code>就用while好像更好一点了。</p>

        <h2 id="5-4-代码实现"   >
          <a href="#5-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyList = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyList-&gt;next = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummyList;</span><br><span class="line">		<span class="comment">//很好的判断条件，防止倒数第n个本来就是不存在的情况</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 一起前进</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> dummyList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="6-链表相交"   >
          <a href="#6-链表相交" class="heading-link"><i class="fas fa-link"></i></a>6. 链表相交</h1>
      
        <h2 id="相关题目-4"   >
          <a href="#相关题目-4" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" >Problem 链表相交</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="6-1-复杂度"   >
          <a href="#6-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>6.1 复杂度</h2>
      <p>时间复杂度：<code>O(n + m)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="6-2-主要思想"   >
          <a href="#6-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>6.2 主要思想</h2>
      <p>这道题告诉你之后难度不大，就是看看两个链表的部分是否相等就行了，怎么看呢，一个个移动，直到空为止，很容易知道应该是以最短的那个链表作为基准，因为最短的链表遍历完之后所有有可能的结果也就尘埃落定了。所以我们要做的第一步就是比对两个数组找出长度差值，之后才能够精准的进行定位。</p>

        <h2 id="6-3-注意点"   >
          <a href="#6-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>6.3 注意点</h2>
      <p>计算完长度之后，临时指针要重定向归于原来的头节点，不然他们计算完长度之后的状态是指向nullptr的</p>

        <h2 id="6-4-代码实现"   >
          <a href="#6-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>6.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = headA;</span><br><span class="line">        ListNode* cur2 = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//计算长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span>(cur1, cur2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">			<span class="comment">//移动到同一起跑线</span></span><br><span class="line">        <span class="keyword">while</span>(gap--)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="7-环形链表"   >
          <a href="#7-环形链表" class="heading-link"><i class="fas fa-link"></i></a>7. 环形链表</h1>
      
        <h2 id="相关题目-5"   >
          <a href="#相关题目-5" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/linked-list-cycle-ii/" >Problem 142. 环形链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="7-1-复杂度"   >
          <a href="#7-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>7.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="7-2-主要思想"   >
          <a href="#7-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>7.2 主要思想</h2>
      <p>这道题由两个部分组成，第一个部分是有没有环，第二个部分是环的入口到底在哪？ 首先有没有环的判断就是依据两个指针一快一慢的走，如果相遇了就能证明有环，但是这是一个必要证明，还得加上一个条件就是快指针走两步慢指针走一步，本质上就是一个追赶问题，<strong>快指针每次相对于慢指针多走了一步，那么就是链表中每一个格子都有能够遇上的机会。</strong>所以此时遇上和有环形成了一个充分必要的对应证明条件。 那么入口在哪呢，假设入口离起始点的距离为x，第一次相遇两指针在距离入口y处，环的长度为y+z，那么我们可以推断出，慢指针走了x+y距离，快指针走了x+n(y+z)。那么他们相遇的话，即x+y &#x3D; x+n(y+z)，我们要探究x是多少，即可以把等式变化为：x &#x3D; (n-1)(y+z)+z，那么因为 y+z表示一直在绕圈可以忽略掉 ，所以我们可以得出一个结论叫做，起点到入环点的位置和相遇点到入环点的位置是相等的。</p>
<blockquote>
<p>这里x一定没有绕环的论证在慢指针走一圈的时间快指针能走两圈，而快指针相对于慢指针每次走一步，也就是说快指针速度为2v，慢指针速度为v，快指针追上慢指针需要走的路程为y+z-a(不足一圈)，追上的时间为(y+z-a)&#x2F;(2v-v),慢指针走一圈的时间为(y+z)&#x2F;v，追上的时间小于慢指针走一圈的时间，所以一定能够追得上。</p>
</blockquote>

        <h2 id="7-4-代码实现"   >
          <a href="#7-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>7.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>3-hashtable</title>
    <url>/post/57281/</url>
    <content><![CDATA[
        <h1 id="1-哈希表基本概念的入门"   >
          <a href="#1-哈希表基本概念的入门" class="heading-link"><i class="fas fa-link"></i></a>1. 哈希表基本概念的入门</h1>
      <p>哈希表也叫散列表，是通过<code>key &amp; value</code>来进行定位的数据结构，他把关键码值映射到表中一个位置来进行定位，这个映射函数叫做哈希函数；<br>元素在数组位置position可以表示为<code>hash(key)</code>， 表面上只存放key，找到key就可以找到value。<br>主要思想是空间换时间，可以节约遍历的时间成本，但是代价是需要建立字典库存储映射结果。</p>
<ul>
<li>数组+链表结构<br>数组查询方便，可以通过下标直接获得所对应的值，但是插入删除不方便，需要整体移动元素还需要扩容；<br>链表查询不方便，没有下标只能通过遍历的方式进行查询，增加插入方便，只需要找到需要插入的节点之后进行插入删除即可；<br>哈希表是两者的结合，获得了两者的优点。<br>哈希碰撞指经过哈希函数两个key都映射到了同一个数组位置上，那么这时候有两种解决方法。</li>
<li>拉链法：在同一个位置进行链表结构的扩充；</li>
<li>线性探索法： 往数组的下一个位置进行扩充；<br>需要考虑到的是<strong>查询效率</strong>，当链表长度过长，那么使用线性探索法；当链表长度足够，使用拉链法。<br>哈希攻击指的是黑客运用一些会转换为相同存储位置的数据注入，最后使得<strong>哈希表退化成一个单链表</strong>，降低了查询效率，DOS(Denial of Service, 拒绝服务供给)攻击.</li>
</ul>

        <h2 id="1-1-hashMap"   >
          <a href="#1-1-hashMap" class="heading-link"><i class="fas fa-link"></i></a>1.1 hashMap</h2>
      
        <h3 id="1-1-1-map基本操作"   >
          <a href="#1-1-1-map基本操作" class="heading-link"><i class="fas fa-link"></i></a>1.1.1 map基本操作</h3>
      <ul>
<li>hashMap的主要Api：<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">map.clear();</span><br><span class="line">map.size();</span><br><span class="line">map.isEmpty</span><br><span class="line">map.containsKey(); <span class="comment">//判断</span></span><br><span class="line">map.containsValue();</span><br><span class="line">map.get(key);</span><br><span class="line">map.put(key,value);</span><br><span class="line">map.putAll(otherMap);</span><br><span class="line">map.remove(key);</span><br><span class="line">map.getOrDefault(key,defaultValue);查找key的值,不存在则返回默认值。</span><br><span class="line">map.entrySet();用来遍历每一对KV</span><br><span class="line"><span class="title function_">for</span><span class="params">(Map.Entry&lt;Integer，Integer&gt; etntey : map.entrySet()</span>)</span><br></pre></td></tr></table></div></figure></li>
<li>map遍历三种方式<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式： keySet 取出map中所有键，封装为map集合</span></span><br><span class="line">		Set&lt;String&gt; s1=buy.keySet();</span><br><span class="line">		<span class="comment">//开始根据键找值</span></span><br><span class="line">		<span class="keyword">for</span> (String key : s1) &#123;</span><br><span class="line">			Integer value=buy.get(key);</span><br><span class="line">			System.out.println(key+<span class="string">&quot;-&gt;&gt;&gt;&gt;&quot;</span>+value);	</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式： 将所有键值对取出封装为entrySet集合</span></span><br><span class="line">		Set&lt;Map.Entry&lt;String,Integer&gt;&gt; en=buy.entrySet();</span><br><span class="line">		<span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : en) &#123;</span><br><span class="line">			String key=entry.getKey();</span><br><span class="line">			Integer value=entry.getValue();</span><br><span class="line">			System.out.println(key+<span class="string">&quot;-&gt;&gt;&gt;&quot;</span>+value);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式： Lambda表达式遍历</span></span><br><span class="line">		buy.forEach(<span class="keyword">new</span> <span class="title class_">BiConsumer</span>&lt;String, Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String t, Integer u)</span> &#123;</span><br><span class="line">				System.out.println(t+<span class="string">&quot;-&gt;&gt;&gt;&quot;</span>+u);</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="1-1-2-HashMap两个重要参数"   >
          <a href="#1-1-2-HashMap两个重要参数" class="heading-link"><i class="fas fa-link"></i></a>1.1.2 HashMap两个重要参数</h3>
      <ul>
<li>初始容量大小：确定了哈希表底层数组的长度，必须是2的幂，默认初始值为16；</li>
<li>加载因子： 决定什么时候进行扩容，默认为0.75f，当数组存储元素个数超过<code>初始容量大小*加载因子</code>，数组就会用<code>refresh()</code>方法进行扩容，将数组扩大到原来的两倍。<br>扩容十分耗费性能，因为会生成一个新的数组，而且原来元素都要重新计算hashcode存入新的数组。</li>
</ul>

        <h3 id="1-1-3-put方法原理"   >
          <a href="#1-1-3-put方法原理" class="heading-link"><i class="fas fa-link"></i></a>1.1.3 put方法原理</h3>
      <p>将key通过本地方法<code>public native int hashcode()</code>， 获取对应key的哈希码， 这个哈希码和key的存储位置有关，一般计算规则是取模存入，假如数组的长度是16个字节，key的hashcode是3214968，那么<code>3214968 mod 16 = 8</code>, 那么key就会被存储在数组的第8个位置，如果该位置为空则直接存入，如果该位置有值，就将插入的key与已经存在的key逐一进行equals判断，如果true就替换values，否则就以链表或红黑树(当链表长度大于8时)形式接入。此时<code>(key, value)</code>被封装为Node节点一同进行put操作</p>
<blockquote>
<p>红黑树是平衡二叉树，在查找的效率方面比链表高。</p>
</blockquote>
<ul>
<li>equals()和hashcode()关系<br>equals()方法对于基本数据类型，比较两个数的内容是否相等，而对于引用数据类型，则比较两个数的存储位置是否相等。<br>两个对象equals()了，那么他们的hashcode()一定相等；两个对象不equals()，他们的hashcode不一定不相等(经过算法可能计算出来相同的值，哈希碰撞的原理)<br>equals()重写了，hashcode()就一定要重写，否则可能两个对象equals，他们的hashcode仍然不相等，可能为后世使用埋下隐患;</li>
</ul>

        <h3 id="1-1-4-get-key-方法原理"   >
          <a href="#1-1-4-get-key-方法原理" class="heading-link"><i class="fas fa-link"></i></a>1.1.4 get(key)方法原理</h3>
      <p>首先调用hashcode()方法获取key的hashcode；<br>之后取模定位到数组的索引位置，如果位置为空，返回null；<br>如果有值，逐一遍历将key进行equal判断，成功则放回对应Node中的values；匹配不到返回null。</p>

        <h3 id="1-1-5-hashMap-在Java1-7和1-8中的区别"   >
          <a href="#1-1-5-hashMap-在Java1-7和1-8中的区别" class="heading-link"><i class="fas fa-link"></i></a>1.1.5 hashMap 在Java1.7和1.8中的区别</h3>
      
        <h4 id="1-结构不同"   >
          <a href="#1-结构不同" class="heading-link"><i class="fas fa-link"></i></a>1. 结构不同</h4>
      <p>1.7采用的是数组+链表的数据结构<br>1.8采用的是数组+链表+红黑树的数据结构(当链表长度大于8时，扩展为红黑树)</p>

        <h4 id="2-节点不同"   >
          <a href="#2-节点不同" class="heading-link"><i class="fas fa-link"></i></a>2. 节点不同</h4>
      <p>区别：<br>1.8中的hash作为一个常量，可以减少扩容时候再次计算哈希值造成的性能消耗。<br>1.8多了红黑树的节点。</p>

        <h4 id="3-hash函数区别"   >
          <a href="#3-hash函数区别" class="heading-link"><i class="fas fa-link"></i></a>3. hash函数区别</h4>
      <p>1.8相较于1.7只采用了一次位运算和一次与运算，而这次的目的是为了能够减少哈希碰撞，将高位和地位融合在一起，因为发现进行取模操作的时候对高位的影响是相对较小的。因为计算公式为<code>(n-1) &amp; hash</code>，对高位基本上是没有什么影响的。</p>
<blockquote>
<p>取模，hash%length，计算机中直接求余效率不如位移运算，源码中做了优化hash&amp;(length-1)，<code>hash % length == hash &amp; (length - 1)</code>的前提是length是2的n次方, 位运算特征，length是2的n次方，那么他减去1之后就是n个1，异或运算同0异1，这时候就能准确得出他在长度内的值是多少了。 </p>
</blockquote>

        <h4 id="4-初始化方式"   >
          <a href="#4-初始化方式" class="heading-link"><i class="fas fa-link"></i></a>4. 初始化方式</h4>
      <p>1.7：</p>
<ul>
<li>table是直接赋值给了一个空数组，在第一次put元素时初始化和计算容量。</li>
<li>table是单独定义的inflateTable（）初始化方法创建的。<br>1.8：</li>
<li>table没有赋值，属于懒加载，构造方式时已经计算好了新的容量位置（大于等于给定容量的最小2的次幂）。</li>
<li>table是resize（）方法创建的。</li>
</ul>

        <h4 id="5-扩容方式"   >
          <a href="#5-扩容方式" class="heading-link"><i class="fas fa-link"></i></a>5. 扩容方式</h4>
      <p>1.7： 运用异或对哈希值进行重新计算，运用resize()方法负责扩容，inflateTable()负责创建表；<br>1.8： 运用原来的哈希值加上扩容数组长度得到新的数组索引位置，节约了性能利用；表为空时候resize()创建表，表中有数值resize()扩容</p>

        <h4 id="6-数据插入方式"   >
          <a href="#6-数据插入方式" class="heading-link"><i class="fas fa-link"></i></a>6. 数据插入方式</h4>
      <p>1.7： 头插法<br>1.8： 尾插法，避免了在并发时出现逆序和循环链表的情况</p>

        <h3 id="1-1-6-线程问题"   >
          <a href="#1-1-6-线程问题" class="heading-link"><i class="fas fa-link"></i></a>1.1.6 线程问题</h3>
      <p>1.7 死循环，数据丢失，并发执行扩容阶段<br>1.8 解决死循环，数据丢失仍然没有解决，并发put的时候</p>
<p>整体储存流程如下：<br><img src="/images/20190122151905332.png"></p>
<hr>

        <h2 id="1-2-Set"   >
          <a href="#1-2-Set" class="heading-link"><i class="fas fa-link"></i></a>1.2 Set</h2>
      
        <h3 id="1-2-1-Set集合基本操作"   >
          <a href="#1-2-1-Set集合基本操作" class="heading-link"><i class="fas fa-link"></i></a>1.2.1 Set集合基本操作</h3>
      <p>list是有序的，元素可以重复的；set是无序的，不能重复的</p>
<ul>
<li>主要Api：<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E object)</span> <span class="comment">//添加一个元素，添加成功返回true</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> <span class="comment">//从Set集合中移除所有元素，该方法是从Collection集合继承过来的。</span></span><br><span class="line">Object <span class="title function_">clone</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object object)</span> <span class="comment">//判断集合内是否包含元素</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> <span class="comment">//判断是否为空集合</span></span><br><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> <span class="comment">//迭代器，遍历set集合用</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object object)</span> <span class="comment">//移除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> <span class="comment">//数组长度</span></span><br></pre></td></tr></table></div></figure></li>
<li>遍历方式</li>
</ul>
<ol>
<li>iterator遍历<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();  </span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();  </span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;  </span><br><span class="line">  <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> it.next();  </span><br><span class="line">  System.out.println(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>增强for遍历<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : set) &#123;  </span><br><span class="line">      System.out.println(str);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h1 id="2-数组相关题目"   >
          <a href="#2-数组相关题目" class="heading-link"><i class="fas fa-link"></i></a>2. 数组相关题目</h1>
      
        <h2 id="2-1-字母异位词"   >
          <a href="#2-1-字母异位词" class="heading-link"><i class="fas fa-link"></i></a>2.1 字母异位词</h2>
      
        <h3 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/valid-anagram/" >Problem 242 有效的字母异位词</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度"   >
          <a href="#复杂度" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h3 id="主要思想"   >
          <a href="#主要思想" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这道题目要我们比较的是每个字符出现的次数，那么我们就有两个需要比较的量，<mark>一个是出现的字符是否相等，另一个是字符出现的次数是否相等，</mark>那么我们就可以想到，本题中的字符串由26个字母构成，是一个<strong>有限且可以连续的集合</strong>(将字符转换位ASCII码)，所以我们考虑用可存储连续集合的存储工具数组来进行存储，每个索引对应的值就是他出现的次数。那么每在s字符串出现一次，加上1； 每在t字符串出现一次，减去1； 因为异位词要求字母个数都相等，到最后只需要判断<strong>数组内的元素是否均为0</strong>即可。</p>

        <h3 id="注意点"   >
          <a href="#注意点" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>本题可能有的会考虑用Map进行存储，key为字母字符，values为次数；是可以的，但是Map中key的特点是可以连续可以不连续，需要用一个哈希映射来存储相对应Map的值，而且也会新增很多空间，影响性能。而连续的集合用数组可以和Map达到一样的效果，但是空间成本小了。</p>

        <h3 id="代码实现"   >
          <a href="#代码实现" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 新建26位数组存储26个字母</span></span><br><span class="line">        <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 加入记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            temp[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移除记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            temp[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 匹配是否还有记录</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-2-赎金信"   >
          <a href="#2-2-赎金信" class="heading-link"><i class="fas fa-link"></i></a>2.2 赎金信</h2>
      
        <h3 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/ransom-note/" >Problem 383 赎金信</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-1"   >
          <a href="#复杂度-1" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h3 id="主要思想-1"   >
          <a href="#主要思想-1" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>和上道题的思路是一样的，找要求的重复字符以及其出现的次数。这个升级版主要体现在他不是完全匹配的了，那我们就要从中想出加上的是哪个，减去的是哪个。那么这里用大的数组加入，小的数组减去，如果都大于0，说明大的完全能包含小的；如果小于0，说明大的里面由小的没有的元素。</p>

        <h3 id="注意点-1"   >
          <a href="#注意点-1" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>学一下字符串的两种遍历方法吧，for增强遍历<code>for(char ch : str.toCharArray)</code>和直接遍历<code>for()... str.charAt(i)</code></p>

        <h3 id="代码实现-1"   >
          <a href="#代码实现-1" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;</span><br><span class="line">        <span class="comment">// 定义一个哈希映射数组</span></span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : magazine.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : ransomNote.toCharArray())&#123;</span><br><span class="line">            record[c - <span class="string">&#x27;a&#x27;</span>] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果数组中存在负数，说明ransomNote字符串总存在magazine中没有的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : record)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="3-Set相关题目"   >
          <a href="#3-Set相关题目" class="heading-link"><i class="fas fa-link"></i></a>3. Set相关题目</h1>
      
        <h2 id="3-1-两个数组的交集"   >
          <a href="#3-1-两个数组的交集" class="heading-link"><i class="fas fa-link"></i></a>3.1 两个数组的交集</h2>
      
        <h3 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/intersection-of-two-arrays/" >Problem 349 两个数组的交集</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-2"   >
          <a href="#复杂度-2" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-2"   >
          <a href="#主要思想-2" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>题目中说到<code>输出结果中的每个元素一定是唯一的</code>，那么就无需去考虑每个元素出现的次数了。所以我们<strong>只需判断的是有没有出现过</strong>即可，那么这种单一元素的判断，而且数组内元素是离散的，用<mark>数组会造成很多空间的浪费</mark>，所以我们想到了<strong>无连续的离散的</strong>集合Set。创建两个集合，其中一个作为比对集，负责比较有没有重复，另一个作为结果集，记录符合条件元素。</p>

        <h3 id="注意点-2"   >
          <a href="#注意点-2" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>集合转数组的写法：<code>resset.stream().mapToInt(x -&gt; x).toArray()</code></p>

        <h3 id="代码实现-2"   >
          <a href="#代码实现-2" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 计算的集合</span></span><br><span class="line">        Set&lt;Integer&gt; tempset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 结果输出的集合</span></span><br><span class="line">        Set&lt;Integer&gt; resset = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            tempset.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tempset.contains(i)) &#123;</span><br><span class="line">                <span class="comment">// 比对成功，加入结果集</span></span><br><span class="line">                resset.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resset.stream().mapToInt(x -&gt; x).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-2-快乐数"   >
          <a href="#3-2-快乐数" class="heading-link"><i class="fas fa-link"></i></a>3.2 快乐数</h2>
      
        <h3 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/happy-number/" >Problem 202 快乐数</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-3"   >
          <a href="#复杂度-3" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-3"   >
          <a href="#主要思想-3" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这道题明确声明了会有无限循环的情况出现，那么这道题得到的就两个结果，一个是我们确定是快乐数的条件：最后结果是1；另一个是无限循环，不是快乐数。所以我们可以直接在循环中设置退出条件一个是为1， 另一个是无限循环。那么要判断是否无限循环就是判断字符是否出现过，重复出现的问题想到哈希表，又因为我们只需要记录内容，次数我们不关心，一个维度我们就用Set就可以了。</p>

        <h3 id="注意点-3"   >
          <a href="#注意点-3" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>获取每位数字的方法：第一步是取10模，得到个位的数字；第二步是除以10，将十位的数字移到下一位个位，然后不断循环，中止的条件是没有可以移动的位了，说明这个数已经被我们操作完了，也就是<code>n &gt; 0</code>。</p>

        <h3 id="代码实现-3"   >
          <a href="#代码实现-3" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; code = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 因为会无限循环，所以到了重复的时候就说明无需再进行下去了</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">1</span> &amp;&amp; !code.contains(n))&#123;</span><br><span class="line">            code.add(n);</span><br><span class="line">            n = getNextCount(n);</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">return</span> n == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取每位数字的平方和</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNextCount</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;</span><br><span class="line">                res += temp * temp;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h1 id="4-Map相关题目"   >
          <a href="#4-Map相关题目" class="heading-link"><i class="fas fa-link"></i></a>4. Map相关题目</h1>
      
        <h2 id="4-1-两数之和"   >
          <a href="#4-1-两数之和" class="heading-link"><i class="fas fa-link"></i></a>4.1 两数之和</h2>
      
        <h3 id="相关题目-4"   >
          <a href="#相关题目-4" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/two-sum/" >Problem 1 两数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-4"   >
          <a href="#复杂度-4" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-4"   >
          <a href="#主要思想-4" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>我们需要通过数组的每个元素值对其进行计算，然后输出的是他的下标，那么这时候我们会发现，其实我们需要操作的是两个值，又需要对元素进行比对匹配，所以选择用Map集合或者数组存储会比较好一些，那我们就看到底是不是连续的。因为最后要输出的是索引，所以我们会选择把索引存在Values中，而元素就只能存在key中了，因为元素的离散的，所以我们只能用Map集合了。</p>

        <h3 id="注意点-4"   >
          <a href="#注意点-4" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>每次一定都要好好想想空值和特殊值有没有办法包含在你的逻辑中，没有的话要提前排除掉。数组的空值具体实现为：<code>nums == null || nums.length == 0</code></p>

        <h3 id="代码实现-4"   >
          <a href="#代码实现-4" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 结果集存储结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 排除空数组</span></span><br><span class="line">            <span class="keyword">if</span>(nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// key为数组元素值，values为对应元素索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i])) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = map.get(nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(temp, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-2-四数之和Ⅱ"   >
          <a href="#4-2-四数之和Ⅱ" class="heading-link"><i class="fas fa-link"></i></a>4.2 四数之和Ⅱ</h2>
      
        <h3 id="相关题目-5"   >
          <a href="#相关题目-5" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/4sum-ii/" >Problem 454 两数相加Ⅱ</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-5"   >
          <a href="#复杂度-5" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-5"   >
          <a href="#主要思想-5" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>这里要求我们输出的是元组的个数，也就是我们不需要具体的去确认他的下标，只需要知道有这个东西存在就可以了。所以我们要关心的就是元素的值。那其实我们可以两两拆分，遍历数组集合求出两个数组的和，然后再与另外两个数组匹配，时间复杂度虽然是n^2^，但是相较于暴力算法直接缩短了一半。但是我们发现，可能一个数的和可以由多种表现形式，所以我们还需要关心的一个点就是组成该和的个数。所以其实我们要考虑到的是两个变量，所以我们会使用Map集合，key用来存储两个数组和的值，values用来存储这个和的组成出现的次数。之后在进行配对的时候也要把所有符合的次数加上，也就计数的时候不是+1，而是+values了。</p>

        <h3 id="注意点-5"   >
          <a href="#注意点-5" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>存储更新个数的操作：包含：<code>map.put(sum, map.get(sum) + 1);</code>不包含：<code>map.put(nums1[i] + nums2[j], 1);</code></p>

        <h3 id="代码实现-5"   >
          <a href="#代码实现-5" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;</span><br><span class="line">        <span class="comment">// 计数器记录满足条件元组个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 两两配对生成集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums2.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums1[i] + nums2[j];</span><br><span class="line">                <span class="keyword">if</span>(map.containsKey(sum)) &#123;</span><br><span class="line">                    <span class="comment">// 存储个数更新的操作</span></span><br><span class="line">                    map.put(sum, map.get(sum) + <span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(nums1[i] + nums2[j], <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums3.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums4.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span> - (nums3[i] + nums4[j]);</span><br><span class="line">                    <span class="keyword">if</span>(map.containsKey(temp)) &#123;</span><br><span class="line">                        <span class="comment">// 需要进行所有的配对</span></span><br><span class="line">                        count += map.get(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-3-三数之和"   >
          <a href="#4-3-三数之和" class="heading-link"><i class="fas fa-link"></i></a>4.3 三数之和</h2>
      
        <h3 id="相关题目-6"   >
          <a href="#相关题目-6" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/3sum/" >Problem 15 三数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-6"   >
          <a href="#复杂度-6" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^2)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-6"   >
          <a href="#主要思想-6" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>等于一个指定的值，那么就有<code>大于小于等于</code>三种情况，只有三者不断的中立，那么最后才能实现，那么我们就想到了其实可以用<strong>排序对他进行划分</strong>，那么排序就想到了<strong>双指针</strong>，但是这里有三个数怎么办呢，那么我们就固定一个，然后去走另外两个，等于是有两个变量的双指针就是O(a)级别的时间复杂度，有三个变量的双指针就是O(n)的时间复杂度，<mark>有n个变量的双指针就是O(n^n-2)的时间复杂度</mark>。</p>

        <h3 id="注意点-6"   >
          <a href="#注意点-6" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>去重复的动作，因为题目明确告诉我们了一样的不算，那么我们怎么去重复呢，就对于固定指针而言，他前后不能一样，对于移动的双指针模型而言，他们两个不能同时一样即可。因为他们两组指针是相对运动的。 而有个细节的点就是判断固定指针去重的时候如果这么写nums[i] &#x3D;&#x3D; nums[i + 1]，就会引发一个只是重复元素但是被我们排除的情况，因为我们未曾比较过，而后移了，这个本来应该操作的可操作范围就变小了，应该写成和i-1进行比较，这样才能确保所有都是匹配过的，操作范围上一个一样的比你大，那肯定你能匹配到的范围也是他能够匹配到的。<br>去重不能只去除一次，而要去到满足这个条件为止，所以不能用if，而要用while<br>将集合装进集合：<code>list.add(Arrays.asList(nums[index], nums[left], nums[right]));</code></p>

        <h3 id="代码实现-6"   >
          <a href="#代码实现-6" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// 对于第一项就大于0的有序数组，那么势必无法加起来等于0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; nums.length; index++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[index] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于index的去重</span></span><br><span class="line">        <span class="keyword">if</span>(index != <span class="number">0</span> &amp;&amp; nums[index] == nums[index - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> index + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[index] + nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 太大了，应该小一点，那么右边就缩小</span></span><br><span class="line">                right --;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 太小了，应该大一点，左边过来点</span></span><br><span class="line">                left ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 是我们的目标，装进集合里去！</span></span><br><span class="line">            list.add(Arrays.asList(nums[index], nums[left], nums[right]));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 去重left</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 去重right</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="4-4-四数之和"   >
          <a href="#4-4-四数之和" class="heading-link"><i class="fas fa-link"></i></a>4.4 四数之和</h2>
      
        <h3 id="相关题目-7"   >
          <a href="#相关题目-7" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h3>
      <p><span class="exturl"><a class="exturl__link"   href="https://leetcode.cn/problems/4sum/" >Problem 18 四数之和</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="复杂度-7"   >
          <a href="#复杂度-7" class="heading-link"><i class="fas fa-link"></i></a>复杂度</h3>
      <p>时间复杂度：<code>O(n^3)</code><br>空间复杂度：<code>O(n)</code></p>

        <h3 id="主要思想-7"   >
          <a href="#主要思想-7" class="heading-link"><i class="fas fa-link"></i></a>主要思想</h3>
      <p>比三数之和多了一层循环。</p>

        <h3 id="注意点-7"   >
          <a href="#注意点-7" class="heading-link"><i class="fas fa-link"></i></a>注意点</h3>
      <p>不要判断<code>nums[k] &gt; target</code> 就返回了，三数之和 可以通过 <code>nums[i] &gt; 0 </code>就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。比如：数组是<code>[-4, -3, -2, -1]</code>，target是-10，不能因为<code>-4 &gt; -10</code>而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[i] &gt; target &amp;&amp; (nums[i] &gt;=0 || target &gt;= 0)</code>就可以了。</p>

        <h3 id="代码实现-7"   >
          <a href="#代码实现-7" class="heading-link"><i class="fas fa-link"></i></a>代码实现</h3>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="title function_">fourSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; nums.size(); k++) &#123;</span><br><span class="line">            <span class="comment">// 剪枝处理</span></span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            	<span class="keyword">break</span>; <span class="comment">// 这里使用break，统一通过最后的return返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对nums[k]去重</span></span><br><span class="line">            <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k + <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">                <span class="comment">// 2级剪枝处理</span></span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对nums[i]去重</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.size() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (right &gt; left) &#123;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &gt; target 会溢出</span></span><br><span class="line">                    <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right] &gt; target) &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    <span class="comment">// nums[k] + nums[i] + nums[left] + nums[right] &lt; target 会溢出</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>) nums[k] + nums[i] + nums[left] + nums[right]  &lt; target) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.push_back(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">// 对nums[left]和nums[right]去重</span></span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 找到答案时，双指针同时收缩</span></span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>String</title>
    <url>/post/34330/</url>
    <content><![CDATA[
        <h1 id="1-字符串基础知识"   >
          <a href="#1-字符串基础知识" class="heading-link"><i class="fas fa-link"></i></a>1. 字符串基础知识</h1>
      
        <h2 id="1-1-字符串对象的创建"   >
          <a href="#1-1-字符串对象的创建" class="heading-link"><i class="fas fa-link"></i></a>1.1 字符串对象的创建</h2>
      <p><code>new String()</code> 方法会在堆中创建一个对象，之后会在方法区中的字符串常量池中判断，如果没有值相等的字符串，那么创建一个常量； 如果有，那么直接调用。</p>

        <h2 id="1-2-方法"   >
          <a href="#1-2-方法" class="heading-link"><i class="fas fa-link"></i></a>1.2 方法</h2>
      <div class="table-container"><table><thead><tr><th>方法名</th><th>作用</th></tr></thead><tbody><tr><td>char <font color="red">charAt</font>(int index)</td><td>返回指定位置的字符</td></tr><tr><td>int <font color="red">compareTo</font>(String anotherString)</td><td>比较两个字符串。相等返回0&#xff1b;前大后小返回1&#xff1b;前小后大返回-1</td></tr><tr><td>boolean <font color="red">contains</font>(CharSequence s)</td><td>判断字符串是否包含s</td></tr><tr><td>boolean <font color="red">endsWith</font>(String suffix)</td><td>判断字符串是否以suffix结尾</td></tr><tr><td>boolean <font color="red">equals</font>(Object anObject)</td><td>判断两个串是否相等</td></tr><tr><td>boolean <font color="red">equalsIgnoreCase</font>(String anotherString)</td><td>忽略大小写判断两个串是否相等</td></tr><tr><td>byte[] <font color="red">getBytes</font>()</td><td>将字符串串变成字节数组返回</td></tr><tr><td>int <font color="red">indexOf</font>(String str)</td><td>返回str在字符串第一次出现的位置</td></tr><tr><td>boolean <font color="red">isEmpty</font>()</td><td>字符串是否为空</td></tr><tr><td>int <font color="red">length</font>()</td><td>字符串长度</td></tr><tr><td>int <font color="red">lastIndexOf</font>(String str)</td><td>返回str最后一次出现的位置</td></tr><tr><td>String <font color="red">replace</font>(CharSequence target, CharSequence replacement)</td><td>用replacement替换字符串target的字符</td></tr><tr><td>String[] <font color="red">split</font>(String regex)</td><td>将字符串以regex分割</td></tr><tr><td>boolean <font color="red">startsWith</font>(String prefix)</td><td>判断字符串是否以prefix开始</td></tr><tr><td>String <font color="red">substring</font>(int beginIndex)</td><td>从beginIndex开始截取字串</td></tr><tr><td>String <font color="red">substring</font>(int beginIndex, int endIndex)</td><td>截取beginIndex到endIndex - 1的字符串</td></tr><tr><td>char[] <font color="red">toCharArray</font>()</td><td>将字符串转换乘char数组</td></tr><tr><td>String <font color="red">toLowerCase</font>()</td><td>字符串转小写</td></tr><tr><td>String <font color="red">toUpperCase</font>()</td><td>字符串转大写</td></tr><tr><td>String <font color="red">trim</font>()</td><td>去除字符串两边空格</td></tr><tr><td>静态方法</td><td></td></tr><tr><td>static String <font color="red">valueOf</font>(int i)</td><td>将 i 转换成字符串</td></tr></tbody></table></div>





<p>class Solution {<br>    public int numDifferentIntegers(String word) {<br>        Set<String> set &#x3D; new HashSet<String>();<br>        int p1 &#x3D; 0;<br>        int n &#x3D; word.length();<br>        int p2;<br>        while (true) {<br>        while (p1 &lt; n &amp;&amp; !Character.isDigit(word.charAt(p1))) {<br>            p1++;<br>        }<br>                    if (p1 &#x3D;&#x3D; n) {<br>                break;<br>            }<br>        p2 &#x3D; p1;<br>        while(p2 &lt; n &amp;&amp; Character.isDigit(word.charAt(p1))) {<br>            p2++;<br>        }<br>        while(p2-p1 &gt; 1 &amp;&amp; word.charAt(p1) &#x3D;&#x3D; ‘0’) {<br>            p1++;<br>        }<br>        res.add(word.substring(p1,p2));<br>        p1 &#x3D; p2;<br>        }</p>
<pre><code>    return res.size();
&#125;
</code></pre>
<p>}</p>
<p>Class Solution {<br>    public int numDifferentIntegers(String word) {<br>        Set<String> set &#x3D; new HashSet<String>();<br>        int n &#x3D; word.length(), p1 &#x3D; 0, p2;<br>        while (true) {<br>            while (p1 &lt; n &amp;&amp; !Character.isDigit(word.charAt(p1))) {<br>                p1++;<br>            }<br>            if (p1 &#x3D;&#x3D; n) {<br>                break;<br>            }<br>            p2 &#x3D; p1;<br>            while (p2 &lt; n &amp;&amp; Character.isDigit(word.charAt(p2))) {<br>                p2++;<br>            }<br>            while (p2 - p1 &gt; 1 &amp;&amp; word.charAt(p1) &#x3D;&#x3D; ‘0’) { &#x2F;&#x2F; 去除前导 0<br>                p1++;<br>            }<br>            set.add(word.substring(p1, p2));<br>            p1 &#x3D; p2;<br>        }<br>        return set.size();<br>    }</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/post/35944/</url>
    <content><![CDATA[
        <h1 id="1-HTTP的基本概念"   >
          <a href="#1-HTTP的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1. HTTP的基本概念</h1>
      
        <h2 id="1-1-HTTP基本定义"   >
          <a href="#1-1-HTTP基本定义" class="heading-link"><i class="fas fa-link"></i></a>1.1 HTTP基本定义</h2>
      <p>全称： 超文本传输协议</p>
<ul>
<li>超文本： 针对于<strong>传输的内容</strong>，不只是文字文件，将内容扩展到了字节流（视频，音频，图片等）内容，只要能用字节传输的内容都可以叫做超文本。</li>
<li>传输：指的是客户端和服务端的<strong>关系</strong>，是双向的。请求内容的同时也能够成为接受响应的主体。</li>
</ul>
<p>http的传输是无状态的不安全的，无需身份的认证就可以向对方发送和接受消息。</p>
<ul>
<li>协议：<strong>约定</strong>的内容，约定了传输时候的行为和规范。</li>
</ul>

        <h2 id="1-2-HTTP常见状态码"   >
          <a href="#1-2-HTTP常见状态码" class="heading-link"><i class="fas fa-link"></i></a>1.2 HTTP常见状态码</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>状态码分类</th>
<th>表示含义</th>
<th>常见状态码</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>中间状态，正在等待恢复响应</td>
<td></td>
</tr>
<tr>
<td>2xx</td>
<td>成功</td>
<td><strong>200 OK</strong> - 完全成功 <strong>204 Content</strong> - 成功但没有响应头body <strong>206 Partial Content</strong> - 断点续传或分片中传输一部分成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
<td><strong>301 Moved Permanently</strong> - 永久重定向，表示资源不存在了 <strong>302 Found</strong> - 临时重定向，暂时需要用别的URL访问 <strong>304 Not Modified</strong> - 重定向到缓存，用于缓存服务</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端问题</td>
<td><strong>400 Bad Request</strong> - 请求问题（笼统） <strong>403 Forbidden</strong> - 权限问题 <strong>404 Not Found</strong> - 路径问题（和3xx对比，这个完全找不到）</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端问题</td>
<td><strong>500 Internal Server Error</strong> - 服务器错误（笼统） <strong>502 Bad Gateway</strong> - 服务器本身没问题，网关问题 <strong>503 Service Unavailable</strong> - 资源正在加载中</td>
</tr>
</tbody></table></div>

        <h2 id="1-3-GET和POST的区别"   >
          <a href="#1-3-GET和POST的区别" class="heading-link"><i class="fas fa-link"></i></a>1.3 GET和POST的区别</h2>
      <ul>
<li>get一般用于<strong>资源的读取</strong>，也就是<strong>只读</strong>操作。一般不会有请求体，通过路径参数或者json表单传递即可实现。所以说他的操作是<strong>幂等</strong>的。对数据安全不会产生影响。所以对于一些不重复修改的数据，我们可以使用缓存技术降低访问数据库的频率，提高系统的性能。</li>
</ul>
<p>幂等：两次操作后，获取的结果一定是相同的。</p>
<ul>
<li>post一般用于<strong>资源的修改或者新增</strong>，涉及到数据的<strong>写入</strong>操作，所以有可能会出现多线程情况下的<strong>脏读，重复读，幻读</strong>等问题，在高并发的场景下需要通过<strong>锁的机制</strong>来实现对数据库资源的保护。因为每次都会产生一次修改，所以说post操作<strong>不是幂等</strong>的，也是<strong>不安全</strong>的。</li>
</ul>

        <h1 id="2-HTTP缓存技术"   >
          <a href="#2-HTTP缓存技术" class="heading-link"><i class="fas fa-link"></i></a>2. HTTP缓存技术</h1>
      <p>缓存技术是为了解决<strong>静态资源</strong>反复从服务器中加载，但是并没有得到改变，从而<strong>消耗服务器性能</strong>而提出来的一种解决方案。它可以将读取的静态资源放在内存中，下次可以直接从自己的内存中读取资源。无需耗费服务器性能。常用于<strong>静态标签页</strong>。、</p>

        <h2 id="2-1-强制缓存"   >
          <a href="#2-1-强制缓存" class="heading-link"><i class="fas fa-link"></i></a>2.1 强制缓存</h2>
      <p>当你从服务器上加载了一个网页的时候，他就将该网页加载到你的缓存中，并且设置了过期时间<code>Cache-Control</code>，在过期时间之前，如果没有对浏览器进行强刷新(<code>shirt + F5</code>)的话，是无法看到更新的内容的。</p>
<p><img src="/HTTP.assets/1681389010269-d00e8729-3cda-43a2-a207-fd333edd0dfa.png" alt="img"></p>

        <h2 id="2-2-协商缓存"   >
          <a href="#2-2-协商缓存" class="heading-link"><i class="fas fa-link"></i></a>2.2 协商缓存</h2>
      <p>协商缓存时强制缓存失效后的方式。也就是说，只要强制缓存没有过期，协商缓存就不会出现。</p>
<p>有两个变量控制协商缓存的行为<code>Etag</code> 和 <code>Last-Modified</code>。</p>
<p>第一个变量<code>Etag</code> 是资源全局唯一标识，可以判断该资源有没有被修改，第二个变量<code>Last-Modified</code>可以判断该资源最后修改的时间。一般<em>先判断第一个变量，在判断第二个变量。</em>如果响应头部中有一个变量，那么就会交给服务器进行决策，判断是200还是304。304表示无需修改，可重定向到缓存，这时继续使用缓存。200表示有更新，则更新界面和缓存。</p>
<p><img src="/HTTP.assets/1681389028465-d868956c-de33-45f1-8f3d-e49f39790c15.png" alt="img"></p>
<p>先<code>Etag</code>原因是有些服务器判断最后修改时间细粒度不够高，同步性不强。以及有些非资源内部修改操作也会导致资源修改时间被重置。</p>

        <h1 id="3-HTTP如何优化"   >
          <a href="#3-HTTP如何优化" class="heading-link"><i class="fas fa-link"></i></a>3. HTTP如何优化</h1>
      <p>这里的优化指的是通过一些手段来传输时间的减少，从而提升用户使用时候的体验</p>
<p><img src="/HTTP.assets/1681389064792-928bbd85-2f79-44d3-89e4-b841a69ad8c2.png" alt="img"></p>

        <h2 id="3-1-尽可能避免HTTP请求发送"   >
          <a href="#3-1-尽可能避免HTTP请求发送" class="heading-link"><i class="fas fa-link"></i></a>3.1 尽可能避免HTTP请求发送</h2>
      <p>利用<strong>HTTP缓存技术</strong>，将热点数据存储在本地，要发送请求的时候先判断该数据是否已经先加载过，如果在本地缓存中查找到对应内容，那么直接读取本地缓存。所以这种方式主要是通过缓存的方式来尽可能避免数据的传输来优化时间上的体验。但是会占用一定的内存存储空间。</p>

        <h2 id="3-2-减少HTTP每次请求交互次数"   >
          <a href="#3-2-减少HTTP每次请求交互次数" class="heading-link"><i class="fas fa-link"></i></a>3.2 减少HTTP每次请求交互次数</h2>
      <ul>
<li><strong>减少重定向次数</strong></li>
</ul>
<p>当客户端访问的地址迁移的时候，访问的原地址只会给客户端返回302状态码，告诉他下一步要去访问的url，如果多次访问失效的话就会浪费极多次不必要的重定向。那么这时候我们可以采用代理服务器来记录每个服务端口之间的信息，将重定向的工作交由代理服务器完成，降低了一次信息的交换，提高了信息传输的效率。</p>
<ul>
<li><strong>将碎片数据集中成大文件统一进行传输</strong></li>
</ul>
<p>主要应用于<code>**.gif**</code><strong>头像小文件的传输</strong>，将多张小图片<strong>合并</strong>为一张大图片进行传输，可以减少客户端和服务端之间交互的次数。同时我们也可以将<strong>图片转换为</strong><code>**base64**</code><strong>编码文件</strong>附送到url路径中，这样服务端收到请求的时候会自动解析该文件，也减少了一次图片请求的传输。</p>
<ul>
<li><strong>非紧急文件可延迟发送</strong></li>
</ul>
<p>常用于<strong>分页查询</strong>，每次只需要加载一个页面的数据即可，翻页的时候再加载其他资源，可以提高响应的速度</p>
<p>查询100w条数据，如何快速定位到较为后面的页数 –子查询</p>

        <h2 id="3-3-减少HTTP请求发送大小"   >
          <a href="#3-3-减少HTTP请求发送大小" class="heading-link"><i class="fas fa-link"></i></a>3.3 减少HTTP请求发送大小</h2>
      <ul>
<li>有损压缩</li>
<li>无损压缩</li>
</ul>

        <h1 id="4-RSA四次握手"   >
          <a href="#4-RSA四次握手" class="heading-link"><i class="fas fa-link"></i></a>4. RSA四次握手</h1>
      <p>RSA是HTTP请求前的安全传输技术，因为HTTP主要通过明文传输，会有一定的<strong>窃取篡改以及冒充</strong>的风险。所以在HTTP层和TCP层之间新增了一层TSL层，而RSA的TSL的主要实现方式之一，主要通过传输前的四次握手实现<strong>数据加密，校验机制，身份鉴权</strong>来避免以上的风险。</p>
<p><img src="/HTTP.assets/1681389044456-17071ad8-d1cb-48fe-8709-5a6323c284fd.png" alt="img"></p>

        <h2 id="4-1-第一次握手"   >
          <a href="#4-1-第一次握手" class="heading-link"><i class="fas fa-link"></i></a>4.1 第一次握手</h2>
      <p>客户端发送<code>client Hello</code>, 发起RSA加密请求, 传输数据有三个</p>
<ul>
<li><code>TSL Version</code> : TSL加密的版本, 用于和服务端校验统一, 相同TSL版本才可以进行握手</li>
<li><code>Client Random</code>: 客户端随机数, 用于后续加密</li>
<li><code>Cipher Suiter</code>: 支持的密码套件, 用于确认其他加密的方式</li>
</ul>

        <h2 id="4-2-第二次握手"   >
          <a href="#4-2-第二次握手" class="heading-link"><i class="fas fa-link"></i></a>4.2 第二次握手</h2>
      <p>服务端发送<code>server Hello</code>, 发起RSA加密请求, 传输数据有三个</p>
<ul>
<li><code>TSL Version</code> : TSL加密的版本, 校验</li>
<li><code>Server Random</code>: 服务端随机数,  用于后续加密</li>
<li><code>Cipher Suiter</code>: 从接收到的客户端的密码套件中选择一个</li>
</ul>
<p>密码套件基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」</p>
<p>如<code>Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256</code></p>
<ul>
<li>CA数字证书 : 用于身份校验</li>
</ul>

        <h2 id="4-3-CA数字证书校验流程"   >
          <a href="#4-3-CA数字证书校验流程" class="heading-link"><i class="fas fa-link"></i></a>4.3 CA数字证书校验流程</h2>
      <p>数字证书包含的内容:</p>
<ul>
<li>公钥</li>
<li>持有者信息</li>
<li>信息认证机构(CA)的信息</li>
<li>CA采用的签名和算法</li>
<li>证书有效期</li>
<li>额外信息</li>
</ul>
<p><img src="/HTTP.assets/1681389100091-6add38bd-6760-41be-afda-3941b1bf124b.png" alt="img"></p>
<p>客户端已知: 能通过的CA证书加密之后的<code>hash value1</code>, 服务端发送过来的经过CA机构颁发的私钥加密的数字证书。</p>
<p>客户端通过公钥对于服务端发送过来的加密后的数字证书进行解密,得到<code>hash value2</code>, 将可通过的<code>hash value1</code>列表和<code>hash value2</code>进行对比, 如果相同, 就说明证书是可靠的</p>
<p>证书信任链：根证书信任中间证书，中间证书信任服务端证书，那么客户端信任了根证书，也就相当于信任了服务端证书。</p>
<p>主要目的是将根证书进行隔离，保证信任的安全性。</p>

        <h2 id="4-4-第三次握手"   >
          <a href="#4-4-第三次握手" class="heading-link"><i class="fas fa-link"></i></a>4.4 第三次握手</h2>
      <p>客户端首先需要校验发送过来的数字证书是否合法，如果合法，得到公钥<code>pubkey</code>，进行下列操作：</p>
<p>生成随机数<code>pre-master</code>，用<code>pubkey</code>加密传输给服务端；</p>
<p><strong>此时，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong></p>
<p>双方利用这三个随机数生成<strong>会话密钥</strong>，用于后续信息的加密和解密。</p>
<p>之后客户端给服务端发送<code>change cipher spec</code>， 用于通知服务端后续的会话将由通过会话密钥加密的方式传递信息。</p>
<p>最后，<code>finish</code>是最后一步的校验，将前面信息做<strong>摘要</strong>， 来判断是否前面信息又被篡改。</p>

        <h2 id="4-5-第四次握手"   >
          <a href="#4-5-第四次握手" class="heading-link"><i class="fas fa-link"></i></a>4.5 第四次握手</h2>
      <p>服务器也是同样的操作，发 [ <strong>Change Cipher Spec</strong> ] 和 [ <strong>finish</strong> ] 消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后客户端和服务端就会通过加密的方式进行会话。</p>

        <h2 id="4-6-RSA算法的缺点"   >
          <a href="#4-6-RSA算法的缺点" class="heading-link"><i class="fas fa-link"></i></a>4.6 RSA算法的缺点</h2>
      <p>无法保证【<strong>前向加密</strong>】，针对于第三次握手，因为是用公钥进行加密的<code>pre-master</code>，如果服务端的私钥被破解，那么全部数据就会被截取和破解，会产生冒充的风险。</p>
<p>前向加密：一个密钥只能访问由它所保护的数据；用来产生密钥的元素一次一换，不能再产生其他的密钥；一个密钥被破解，并不影响其他密钥的安全性。</p>

        <h2 id="4-7-ECDHE-密钥协商算法"   >
          <a href="#4-7-ECDHE-密钥协商算法" class="heading-link"><i class="fas fa-link"></i></a>4.7 ECDHE 密钥协商算法</h2>
      <ul>
<li>运用了离散对数, 圆锥曲线等算法，保证了数据在加密前的安全性,这是相较于RSA算法的一大突破．</li>
<li>RSA算法不支持<strong>前向保密</strong>机制，而ECDHE密钥协商算法支持<strong>前向保密</strong>机制。</li>
<li>ECDHE算法的客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间</li>
</ul>

        <h1 id="5-HTTP2的优化点"   >
          <a href="#5-HTTP2的优化点" class="heading-link"><i class="fas fa-link"></i></a>5. HTTP2的优化点</h1>
      
        <h2 id="5-1-HTTP1-1的缺陷"   >
          <a href="#5-1-HTTP1-1的缺陷" class="heading-link"><i class="fas fa-link"></i></a>5.1 HTTP1. 1的缺陷</h2>
      <p>HTTP&#x2F;2 针对于HTTP1.1的优化主要体现在其<strong>传输效率</strong>上，对于其安全性没有做出过多的改变。安全主要靠的是<strong>HTTPS协议</strong>来进行改善。</p>
<p>那么，HTTP&#x2F;2主要针对以下几个问题进行改良：</p>
<ol>
<li>串行化运行导致传输效率过慢，完成一个HTTP请求之后才能进行下一个</li>
<li>不支持服务器主动推送信息，单向化</li>
<li>头部信息过于庞大且重复，浪费空间大</li>
</ol>
<p>针对以上问题，做出优化点如下：</p>

        <h2 id="5-2-头部压缩"   >
          <a href="#5-2-头部压缩" class="heading-link"><i class="fas fa-link"></i></a>5.2 头部压缩</h2>
      <p>针对于HTTP协议的头部大部分的重复特性，HTTP&#x2F;2编写了编码表，可以类比于我们的哈希结构，以空间换时间，首先是很平常的字段就用静态编码表记录下来，剩下的字段用动态编码表两边各储存一份，到了一定的时间后，就可以只通过发送编码表的序号就可以达到头部的传输功能了。</p>

        <h3 id="5-2-1-静态编码表"   >
          <a href="#5-2-1-静态编码表" class="heading-link"><i class="fas fa-link"></i></a>5.2.1 静态编码表</h3>
      <p>定义：为<strong>高频</strong>出现在HTTP协议头部的字段建立了一张<code>key: set</code>表，总共有61组键值对</p>
<p><img src="/HTTP.assets/1681390216162-c50fc10d-b294-4fab-b68c-a784d89b5ac5.png" alt="img"></p>
<p>其中<code>index</code>为字段的编号，剩下的为键值对信息。</p>
<p><img src="/HTTP.assets/1681390973076-72107641-e4d7-42c6-94b7-222c64e1e128.jpeg" alt="img"></p>
<p>格式如上：首先开头两位为01，表示占位，后面六位<code>index</code>为对应静态编码表中的序号。</p>
<p>第二个字节首位表示<strong>Value 是否经过 Huffman 编码</strong>，后七个字节表示每个值所需要表示的字节长度。</p>
<p>剩下内容为头部的其他信息，以第二个字节为规定的长度为一个单位。</p>

        <h3 id="5-2-2-动态编码表"   >
          <a href="#5-2-2-动态编码表" class="heading-link"><i class="fas fa-link"></i></a>5.2.2 动态编码表</h3>
      <p>边存储边积累，将双方链接过程中的所包含的头部信息共同存储为一张动态表，随着时间的推移，后期双方的链接只需要通过传递序号就可以表达所需要传递的头部信息了。但是这样做会造成<strong>极大的空间内存损耗</strong>。web服务器会提供类似于<code>http2_max_requests</code>这样的字段来限制最大字典表字段数。</p>

        <h2 id="5-3-二进制帧"   >
          <a href="#5-3-二进制帧" class="heading-link"><i class="fas fa-link"></i></a>5.3 二进制帧</h2>
      <p><img src="/HTTP.assets/1681391758634-a381d15e-07c7-4a0e-a5ee-f3af5b6fc6f1.png" alt="img"></p>
<p>帧长度（24bits）：表示的是帧数据（Frame Payload）的长度，不包含帧字节</p>
<p>帧类型（8bits）：分为数据帧和控制帧两类</p>
<p>标志位（8bits）：携带一些控制信息</p>
<p>流标识符（24bits）：表示该帧是属于哪个流的，可以用来组装帧。</p>

        <h2 id="5-4-并发传输"   >
          <a href="#5-4-并发传输" class="heading-link"><i class="fas fa-link"></i></a>5.4 并发传输</h2>
      <p><img src="/HTTP.assets/1681392701396-6abb7739-3882-494b-8d38-5e45a64c305f.png" alt="img"></p>
<ul>
<li>connection：表示HTTP连接，是一次服务端和客户端之间的对话联系</li>
<li>stream：一个connection中包含了多个stream，这是http&#x2F;2的优化之处，他保证了http&#x2F;2的帧可以乱序发送，<strong>因为帧的头部信息携带了流标识符</strong>，最后传到在重新拼装即可，实现了Http链接之间的并行传输。</li>
</ul>
<p>但是同一个流之中的帧不可乱序传输，因为帧头没有确定帧先后顺序的标识位。</p>
<ul>
<li>Response Message：响应信息，表示一个Request或者Reponse，由各个帧组成了一条完整的响应信息。</li>
</ul>
<p>这个模式还突破了原有的全单工模式的传输，服务器和客户端可以同时发送信息了，只要双方各自建立自己的stream，在不同的流上发送即可，极大的提高了传输的效率。</p>
<p>但是这里有一个规定，<strong>客户端仅可建立编号为奇数的stream，服务端仅可以建立编号为偶数的stream</strong>。</p>

        <h2 id="5-5-服务器主动推送资源"   >
          <a href="#5-5-服务器主动推送资源" class="heading-link"><i class="fas fa-link"></i></a>5.5 服务器主动推送资源</h2>
      <p>由于stream的引入，服务器可以自己主动推送资源了。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IP</title>
    <url>/post/44087/</url>
    <content><![CDATA[
        <h1 id="1-IP基本认识"   >
          <a href="#1-IP基本认识" class="heading-link"><i class="fas fa-link"></i></a>1.IP基本认识</h1>
      
        <h2 id="1-1-IP的基础概念"   >
          <a href="#1-1-IP的基础概念" class="heading-link"><i class="fas fa-link"></i></a>1.1 IP的基础概念</h2>
      <p>是位于网络层的一个协议，实现<strong>主机和主机之间的通信</strong>，也叫<strong>点对点通信</strong>。</p>
<p>通过<strong>源IP地址</strong>和<strong>目标IP地址</strong>这两个关键信息，在众多路由器的转发中实现通信。</p>
<p>路由器实现转发机制：当一台主机朝网络中发送数据包时，他会将目标IP地址设置为接收方的IP地址。随后传给<strong>本地网络</strong>，本地网络中的路由器通过检查数据包中的目标IP地址，并与自己的<strong>路由表</strong>进行匹配。如果发现目标ip地址时自己的网络，就会转发回去，否则，转发到路由表上对应的路由器。</p>
<p>具体转发机制：<span class="exturl"><a class="exturl__link"   href="https://zhuanlan.zhihu.com/p/145946764?utm_id=0" >https://zhuanlan.zhihu.com/p/145946764?utm_id=0</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="1-2-IP和MAC的区别"   >
          <a href="#1-2-IP和MAC的区别" class="heading-link"><i class="fas fa-link"></i></a>1.2 IP和MAC的区别</h2>
      <ul>
<li>位置不同：MAC位于数据链路层，IP位于网络层</li>
<li>管理内容不同：IP管理的是网络间两台<strong>没有直连</strong>主机之间的位置，数据链路层强调的是两台设备在物理意义上的<strong>直接连接</strong></li>
<li>也就是说，数据链路层可以是主机和路由器之间的连接，而IP只能是主机和主机之间的连接．而ip主机和主机之间的连接中间还隔了若干路由器。</li>
</ul>

        <h1 id="2-IP地址的基础知识"   >
          <a href="#2-IP地址的基础知识" class="heading-link"><i class="fas fa-link"></i></a>2.IP地址的基础知识</h1>
      
        <h2 id="2-1-IP地址的基础定义"   >
          <a href="#2-1-IP地址的基础定义" class="heading-link"><i class="fas fa-link"></i></a>2.1 IP地址的基础定义</h2>
      <p>在 TCP&#x2F;IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。</p>
<p>针对IPV4协议的IP地址进行分析</p>

        <h3 id="点分十进制"   >
          <a href="#点分十进制" class="heading-link"><i class="fas fa-link"></i></a>点分十进制</h3>
      <p>IPV4协议中的IP地址是32位的，人类为了方便记忆，使用点分十进制的方法对ip地址进行了简化，即将32位IP地址每八位划分为1组，每组之间用点(<code>.</code>)隔开，再将每组都用十进制的方式表示出来。</p>
<p><img src="/IP.assets/1683941331597-512b688a-8b33-485c-aa99-bd6e08ab3fc7.png" alt="img"></p>

        <h2 id="2-2-IP地址的分类"   >
          <a href="#2-2-IP地址的分类" class="heading-link"><i class="fas fa-link"></i></a>2.2 IP地址的分类</h2>
      <p><img src="/IP.assets/1683943728185-7e904a24-9f8d-4265-ab9f-ffec2396660f.png" alt="img"></p>

        <h3 id="ABC类地址"   >
          <a href="#ABC类地址" class="heading-link"><i class="fas fa-link"></i></a>ABC类地址</h3>
      <p>ABC类地址由两个部分组成：<strong>网络号和主机号</strong>，前面的<code>0</code>,<code>10</code>,<code>110</code>是用于区分这三类地址的最快捷的方式。</p>
<p><img src="/IP.assets/1683943855883-a3824a6d-4e65-409d-9e71-288a8aba4383.png" alt="img"></p>
<p>其对应的最大主机数的计算公式为：<code>2n-2</code>, 其中n为主机号的位数。减去2的原因是因为有两个特殊ip地址不能够被使用：</p>
<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于<strong>广播</strong></li>
<li>主机号全为 0 指定某个网络</li>
</ul>

        <h3 id="DE类地址"   >
          <a href="#DE类地址" class="heading-link"><i class="fas fa-link"></i></a>DE类地址</h3>
      <p><img src="/IP.assets/1683944097408-4c2af274-7442-41a9-8887-35b78166b947.png" alt="img"></p>
<p>因为DE类地址中没有主机号，所以其不可以用于主机ip。</p>
<ul>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li>
</ul>
<p>广播和组播(多播)的区别：</p>
<p>广播：在一个局域网内，所有的IP地址都会收到这个信息，同一个链路中相互连接的主机之间发送数据包</p>
<p>组播：将信息发送给特定组内的所有主机，也就是说广播比组播的范围更加广泛，但是考虑到安全性的话，组播是更为优秀的。</p>
<p><strong>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</strong></p>

        <h2 id="2-3-无分类地址-CIDR"   >
          <a href="#2-3-无分类地址-CIDR" class="heading-link"><i class="fas fa-link"></i></a>2.3 无分类地址 CIDR</h2>
      <p>针对于<strong>ABC类IP地址最大主机数分配不均匀</strong>的问题，提出了一种新的地址分类方式。</p>
<p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于<strong>网络号</strong>， x 的范围是 0 ~ 32</p>
<p>子网掩码方式获取主机号：</p>
<p><img src="/IP.assets/1683944728553-c93926e6-a4af-420c-9271-50aec45ffec9.png" alt="img"></p>
<p>子网掩码还可以获取子网网络号，可以对网络层级做到进一步划分。</p>

        <h2 id="2-4-IP地址一些特性"   >
          <a href="#2-4-IP地址一些特性" class="heading-link"><i class="fas fa-link"></i></a>2.4 IP地址一些特性</h2>
      
        <h3 id="路由控制"   >
          <a href="#路由控制" class="heading-link"><i class="fas fa-link"></i></a>路由控制</h3>
      <p>计算机使用一个特殊的 IP 地址 <strong>127.0.0.1 作为环回地址</strong>。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p>
<p>通过路由器和路由表，首先数据会先传到本地的路由器，其根据传输过来数据报文中的目标ip地址，对比自己的路由表，找到这份数据应该去向何方，并将其传向对应的路由器。</p>

        <h3 id="分片与重组"   >
          <a href="#分片与重组" class="heading-link"><i class="fas fa-link"></i></a>分片与重组</h3>
      <p>那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。</p>
<p>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</p>
<p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 <code>TCP</code> 引入了<code>MSS</code>也就是在 TCP 层进行分片不由 IP 层分片，那么对于 <code>UDP</code> 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p>

        <h3 id="2-5-IPV6-amp-IPV4"   >
          <a href="#2-5-IPV6-amp-IPV4" class="heading-link"><i class="fas fa-link"></i></a>2.5 IPV6 &amp; IPV4</h3>
      <p>IPV6出现的原因：IPV4是<code>32</code>位的，其能够承受的IP地址只有232（约42亿）个IP地址，是远远不能够满足人类的需求的。所以，出现了具有<code>128</code>位的IPV6地址</p>

        <h3 id="IPV6的表示方式"   >
          <a href="#IPV6的表示方式" class="heading-link"><i class="fas fa-link"></i></a>IPV6的表示方式</h3>
      <p>每十六位为一个单位，用<code>:</code>分割开，如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<p><img src="/IP.assets/1683945304497-91dcd42c-5f77-4fa1-bd88-da568ac9b76a.png" alt="img"></p>

        <h3 id="IPV6的地址类型"   >
          <a href="#IPV6的地址类型" class="heading-link"><i class="fas fa-link"></i></a>IPV6的地址类型</h3>
      <p><img src="/IP.assets/1683945345679-9ebd314f-7373-4b26-9c12-d90cbff0ae5f.png" alt="img"></p>

        <h3 id="IPV4和IPV6首部的对比差异"   >
          <a href="#IPV4和IPV6首部的对比差异" class="heading-link"><i class="fas fa-link"></i></a>IPV4和IPV6首部的对比差异</h3>
      <p><img src="/IP.assets/1683945391428-3c09b4f0-cb38-4275-ab76-4ff05e647656.png" alt="img"></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。</li>
</ul>

        <h1 id="3-IP相关协议技术"   >
          <a href="#3-IP相关协议技术" class="heading-link"><i class="fas fa-link"></i></a>3.IP相关协议技术</h1>
      
        <h2 id="3-1-DNS域名解析"   >
          <a href="#3-1-DNS域名解析" class="heading-link"><i class="fas fa-link"></i></a>3.1 DNS域名解析</h2>
      
        <h3 id="域名之间的层级关系"   >
          <a href="#域名之间的层级关系" class="heading-link"><i class="fas fa-link"></i></a>域名之间的层级关系</h3>
      <p>DNS中的域名是用<code>.</code>进行分割的，越往右边表示层级越高，如<code>www.baidu.com</code>表示一共有三个层级域名</p>
<p>分别为：<code>com</code>, <code>baidu.com</code>, <code>www.baidu.com</code></p>
<ul>
<li>根 DNS 服务器</li>
<li>顶级域 DNS 服务器（com）</li>
<li>权威 DNS 服务器（baidu.com）</li>
</ul>

        <h3 id="域名解析的全过程"   >
          <a href="#域名解析的全过程" class="heading-link"><i class="fas fa-link"></i></a>域名解析的全过程</h3>
      <p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：</p>
<ol>
<li>客户端向本地DNS服务器发送请求，询问目标域名的IP</li>
<li>本地DNS服务器收到客户端的请求后，在自己的缓存中查找，查找得到则直接返回，查找不到则向<strong>根域名服务器</strong>进行询问。</li>
</ol>
<p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p>
<ol>
<li>根域名服务器收到请求后，根据后缀找到<strong>顶级域名服务器地址</strong>，将其发给本地DNS服务器。</li>
<li>本地DNS服务器根据获得的顶级域名服务器地址，对其发送请求，顶级域名服务器地址将域名查询之后，发给客户端对应的<strong>权威DNS服务器</strong>地址。</li>
<li>本地DNS服务器根据获得的权威 DNS 服务器地址，对其发送请求，权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>总结：本地 DNS与若干DNS服务器的无限问答，以及本地DNS的无数次寻找，最后找到了IP地址。</p>

        <h2 id="3-2-ARP协议和RARP协议"   >
          <a href="#3-2-ARP协议和RARP协议" class="heading-link"><i class="fas fa-link"></i></a>3.2 ARP协议和RARP协议</h2>
      <ul>
<li>ARP：已知IP地址可以求得MAC地址</li>
<li>RARP：已知MAC地址可以求得IP地址</li>
</ul>

        <h3 id="ARP协议如何得知MAC地址"   >
          <a href="#ARP协议如何得知MAC地址" class="heading-link"><i class="fas fa-link"></i></a>ARP协议如何得知MAC地址</h3>
      <ul>
<li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li>
</ul>
<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。</p>

        <h2 id="3-3-DHCP动态获取IP地址"   >
          <a href="#3-3-DHCP动态获取IP地址" class="heading-link"><i class="fas fa-link"></i></a>3.3 DHCP动态获取IP地址</h2>
      <ul>
<li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 <code>255.255.255.255</code>（端口 67） 并且使用<code>0.0.0.0</code>（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 <code>255.255.255.255</code>，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>
<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</p>
<p>简化来讲，就是客户端去求职BOSS海投，然后看上这个客户端的服务端就给他发送offer，这个offer告诉他我能给你提供的条件（没错，不用面试），然后客户端选来选去，最后只回了一家，签约成功。之后服务端在发个合同入职须知什么的，结束。这是多少人梦寐以求的状态。</p>
<p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p>
<ul>
<li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li>
<li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li>
</ul>

        <h2 id="3-4-NAT网络地址转换"   >
          <a href="#3-4-NAT网络地址转换" class="heading-link"><i class="fas fa-link"></i></a>3.4 NAT网络地址转换</h2>
      <p><strong>两个私有 IP 地址都转换 IP 地址为统一的公有地址，但是以不同的端口号作为区分。</strong></p>
<p>生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。</p>
<p>这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。</p>
<p>缺点：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>

        <h2 id="3-5-ICMP互联网控制报文协议"   >
          <a href="#3-5-ICMP互联网控制报文协议" class="heading-link"><i class="fas fa-link"></i></a>3.5 ICMP互联网控制报文协议</h2>
      <p>ICMP 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<p><img src="/IP.assets/1683988940425-bd7992c7-d5fa-4512-b9ca-4f8eea22bb34.png" alt="img"></p>
<p>查询报文：回送请求和回送响应是查询报文的两种，主要的作用是用来确定发送的数据包是否到达对端的一种方式</p>
<p>差错报文：相当于我们平时编程语言中的异常</p>
<ul>
<li><p>目标不可达：类似于404，可能是网络不可达，可能是端口不可达，可能是主机不可达等</p>
</li>
<li><ul>
<li>网络不可达代码为 0</li>
<li>主机不可达代码为 1	</li>
<li>协议不可达代码为 2</li>
<li>端口不可达代码为 3</li>
<li>需要进行分片但设置了不分片位代码为 4</li>
</ul>
</li>
<li><p>原点抑制：使用低网速传输的时候可能会出现网络拥堵情况，这时发送一个原点抑制的报文，可以增大 IP 包的传输间隔，减少网络拥堵的情况。</p>
</li>
</ul>

        <h1 id="4-扩展知识"   >
          <a href="#4-扩展知识" class="heading-link"><i class="fas fa-link"></i></a>4.扩展知识</h1>
      
        <h2 id="4-1-ICMP具体工作原理"   >
          <a href="#4-1-ICMP具体工作原理" class="heading-link"><i class="fas fa-link"></i></a>4.1 ICMP具体工作原理</h2>
      <p><span class="exturl"><a class="exturl__link"   href="https://xiaolincoding.com/network/4_ip/ping.html#ip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%A9%E6%89%8B-icmp-%E5%8D%8F%E8%AE%AE" >https://xiaolincoding.com/network/4_ip&#x2F;ping.html#ip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%A9%E6%89%8B-icmp-%E5%8D%8F%E8%AE%AE</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>不想写了。。。认认真真的看过了！</p>

        <h2 id="4-2-ping-127-0-0-1"   >
          <a href="#4-2-ping-127-0-0-1" class="heading-link"><i class="fas fa-link"></i></a>4.2 ping 127.0.0.1</h2>
      
        <h3 id="断网了还能ping的通127-0-0-1吗"   >
          <a href="#断网了还能ping的通127-0-0-1吗" class="heading-link"><i class="fas fa-link"></i></a>断网了还能ping的通127.0.0.1吗</h3>
      <p>可以，因为还没走出到网络，客户端发出网络请求会第一步先走到本地路由器，本地路由器如果判断是自己的本地地址就会直接返回，如果不是再去对比自己的路由表。本地路由器是不需要网络的，所以我们发现ping 127.0.0.1不需要联网</p>

        <h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"   >
          <a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="heading-link"><i class="fas fa-link"></i></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2>
      <ul>
<li><code>localhost</code>是一个域名，相当于<code>baidu.com</code>, 其ip地址为127.0.0.1，所以意义上有区别但是实际使用是没什么区别的</li>
<li>0.0.0.0 , 表示本机上的<strong>所有IPV4地址</strong>。是ping不通的</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP</title>
    <url>/post/56432/</url>
    <content><![CDATA[
        <h1 id="1-TCP的基本认识"   >
          <a href="#1-TCP的基本认识" class="heading-link"><i class="fas fa-link"></i></a>1. TCP的基本认识</h1>
      
        <h2 id="1-1-头部格式"   >
          <a href="#1-1-头部格式" class="heading-link"><i class="fas fa-link"></i></a>1.1 头部格式</h2>
      <p><img src="/TCP.assets/1681538502204-6f61e70a-3a10-427e-8f2f-45b7d3612fca.png" alt="img"></p>
<ul>
<li><p>源端口号&#x2F;目标端口号：分别表示发送方和接收方</p>
</li>
<li><p>序列号：用来保证<strong>传输的可靠性</strong>，原数据是随机生成的随机数，之后服务端和客户端每交互一次就叠加一次。用来<strong>解决网络收发包的乱序问题</strong>。</p>
</li>
<li><p>确认应答号：下一次收到数据期望的序列号，可以认为此前的序列号都传输成功，用来<strong>解决网络丢包问题</strong>。</p>
</li>
<li><p>首部：表示TCP报文头部长度，按比例缩小进行存储。</p>
</li>
<li><p>控制位：</p>
</li>
<li><ul>
<li>URG(Urgent，紧急标志)：表示包中有需要紧急处理的数据，优先处理。</li>
<li>ACK(Acknowledgment，确认标志)：表示确认数据包已经收到。</li>
<li>PSH(Push，推送标志)：PSH为1，立即发送数据。PSH为0，先进行缓存。</li>
<li>RST(Reset，重置标志)：RST标志用于中止连接，用于解决网络连接问题。</li>
<li>SYN(Synchronization，同步标志)：这个位标志用于发起一个连接，建立连接并设置初始序列号。</li>
<li>FIN(Finish，完成标志)：表示终止TCP连接，用于数据传输完毕，此段连接不会再有数据往来。</li>
</ul>
</li>
<li><p>窗口大小：用于<strong>流量控制</strong>，分别表表明自己能够接受的流量大小。</p>
</li>
<li><p>校验和：确保数据传输没有被篡改，重新通过某种算法计算后得到的数。</p>
</li>
<li><p>紧急指针：当URG标志位为1的时候才存在该字段，表示该部分数据为紧急数据。</p>
</li>
<li><p>选项：用于优化TCP传输性能，对TCP功能做出解释，也是TCP总长度可变的原因。</p>
</li>
</ul>
<p>有的文章保留字段为4比特，标志位为8比特，有的文章保留字段为6比特，标志位为6比特。</p>

        <h2 id="1-2-TCP的意义和作用"   >
          <a href="#1-2-TCP的意义和作用" class="heading-link"><i class="fas fa-link"></i></a>1.2 TCP的意义和作用</h2>
      <p>TCP的<strong>面向连接</strong>的，<strong>可靠</strong>的，<strong>基于字节流</strong>的传输。</p>
<p>ip层是不可靠的，其只负责将数据传输到对应的主机，保证数据在网络传输之间不丢失，但是能够<strong>按序到达</strong>，<strong>数据内容的完整</strong>无法保证。所以tcp层的出现正是为了保证数据的安全性。</p>
<ol>
<li>面向连接：只有建立起来连接，才能进行数据的传输。即只有一对一的连接。保证了数据之间传输的<strong>安全</strong>。</li>
<li>可靠性：更加偏向于一个目的的描述，保证数据包发送之后能<strong>可靠的</strong>到达目的地。</li>
<li>基于字节流：应用程序对数据的发送和接收是<strong>没有边界限制</strong>的，为了保证其<strong>有序性</strong>，同时也可以针对其特性建立<strong>缓存区</strong>，将传输的若干数量包拼装完成后再接收。</li>
</ol>
<p>RFC 793定义的连接：</p>
<p><em>Connections: The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including</em> <em>sockets</em><em>,</em> <em>sequence numbers</em><em>, and</em> <em>window sizes</em><em>, is called a connection.</em></p>
<p>从中我们可以看出一个TCP连接中主要包含着三个关键信息：</p>
<ul>
<li>sockets：由ip地址和端口号组成，用于确认地址信息</li>
<li>sequence numbers：随机序列号，用来确保传输的有序和安全</li>
<li>window sizes：窗口大小，用来进行流量控制</li>
</ul>

        <h2 id="1-3-如何确定一个TCP连接"   >
          <a href="#1-3-如何确定一个TCP连接" class="heading-link"><i class="fas fa-link"></i></a>1.3 如何确定一个TCP连接</h2>
      <p><strong>TCP四元组</strong>可以确定一个唯一的TCP连接：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p>求一个端口能够监听的最大TCP连接数</p>
<p>最大TCP连接数 &#x3D; 客户端IP地址数量 * 客户端端口数量</p>

        <h2 id="1-4-TCP和UDP的区别"   >
          <a href="#1-4-TCP和UDP的区别" class="heading-link"><i class="fas fa-link"></i></a>1.4 TCP和UDP的区别</h2>
      <p><img src="/TCP.assets/1681540761397-b5876402-e4f2-48d1-9544-454d31f61eab.png" alt="img"></p>
<p>这里要注意包长度指的是整个UDP的长度，包含数据。校验和为了防止收到损坏的数据包。</p>
<ol>
<li><strong>连接</strong></li>
</ol>
<ul>
<li>TCP是面向连接的协议，他需要经过确定连接之后才可以进行数据的传输。</li>
<li>UDP是无连接协议，数据即刻传输</li>
</ul>
<ol>
<li><strong>服务对象</strong></li>
</ol>
<ul>
<li>TCP只支持一对一的服务，这是他面向连接的特点决定的</li>
<li>UDP支持一对一，一对多，多对多的数据传输</li>
</ul>
<ol>
<li><strong>可靠性</strong></li>
</ol>
<ul>
<li>TCP的可靠性较高，数据丢包和被篡改的风险较低下</li>
<li>UDP的可靠性较低，但其也有其改进版本增强其可靠性，如QUIC协议。</li>
</ul>
<ol>
<li><strong>拥塞控制</strong></li>
</ol>
<ul>
<li>TCP通过头部的窗口大小字段告诉传输方自己最大承受数据的能力，是有限制的。</li>
<li>UDP则因为其无连接特性，数据包可以在网络连接中停留拥塞，故可无后顾之忧的发送</li>
</ul>
<ol>
<li><strong>头部开销</strong></li>
</ol>
<ul>
<li>TCP的头部长度为20个字节加上选项</li>
<li>UDP的头部长度为8个字节，且固定</li>
</ul>
<ol>
<li><strong>传输方式</strong></li>
</ol>
<ul>
<li>TCP采用流式传输方式，保证有序及可靠</li>
<li>UDP采用数据包传输方式，是有边界的，可能会导致传输的乱序问题。</li>
</ul>
<ol>
<li><strong>分片方式</strong></li>
</ol>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<ol>
<li><strong>应用场景</strong></li>
</ol>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li>FTP 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、SNMP 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>

        <h2 id="1-5-TCP和UDP可共用一个端口号吗"   >
          <a href="#1-5-TCP和UDP可共用一个端口号吗" class="heading-link"><i class="fas fa-link"></i></a>1.5 TCP和UDP可共用一个端口号吗</h2>
      <p><strong>可以的。</strong></p>
<p>传输层端口号的作用是：用于区分同一台主机上不同应用程序的数据包</p>
<p>UDP和TCP是传输层的两个完全不一样的传输协议。</p>
<p>主机接收到数据包之后，首先会根据头部的格式判断出到底是UDP协议还是TCP协议，再交由相应的软件板块进行传输。</p>

        <h1 id="2-TCP的连接确立"   >
          <a href="#2-TCP的连接确立" class="heading-link"><i class="fas fa-link"></i></a>2. TCP的连接确立</h1>
      <p>三次握手是TCP连接最最最重要，也是最最最基础的点。但是也要记住，这个过程是数据传输的<strong>准备</strong>工作，其目的只是为客户端和服务端<strong>建立起连接</strong>，确保其能无误收发数据。</p>

        <h2 id="2-1-三次握手总流程图"   >
          <a href="#2-1-三次握手总流程图" class="heading-link"><i class="fas fa-link"></i></a>2.1 三次握手总流程图</h2>
      <p><img src="/TCP.assets/1681572757056-f103cb9c-7088-416a-9d9e-b141b084b6c2.png" alt="img"></p>
<ul>
<li><strong>第一次握手：</strong></li>
</ul>
<p>服务端没有收到请求的时候，处于<code>listen</code>状态，同时的，<strong>客户端发起请求</strong>，发送标志位为1的<code>syn</code>和<code>client_isn</code>，表示请求连接，客户端自身进入<code>syn_send</code>状态。</p>
<ul>
<li><strong>第二次握手：</strong></li>
</ul>
<p>本次由<strong>服务端首先发起请求</strong>，其发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。至此，<strong>服务端告诉客户端自己能够收到他的信息</strong>。之后，发送标志位为1的<code>syn</code>和<code>service_isn</code>，<strong>用于确认客户端能否收到自己的信息</strong>，同时自身进入<code>syn_revd</code>状态。</p>
<ul>
<li><strong>第三次握手：</strong></li>
</ul>
<p>本次握手由客户端发送，表示自己收到了服务端的请求并告知，发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。其后，进入<code>Established</code>状态，表示准备就绪，可以进行数据传输，服务端收到客户端发送的Ack，也同时进入<code>Established</code>状态，至此，三次握手完成。</p>

        <h2 id="2-2-握手的数量为3的原因"   >
          <a href="#2-2-握手的数量为3的原因" class="heading-link"><i class="fas fa-link"></i></a>2.2 握手的数量为3的原因</h2>
      <p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>可以看到，三次握手的主要原因是为了<strong>防止旧的连接重复初始化导致连接混乱。</strong></p>
<p>通过头部中的序列号和确认应答号可以校验连接双方是否昔日故人，如果是再进行数据传输。少掉任意一次连接，都会造成客户端或者服务端无法对对方身份的确认。这三次连接实质上是不可或缺的<strong>两问两答</strong>。</p>
<p>而连接混乱造成的后果则是<strong>资源的浪费</strong>。用旧的无意义的连接传输资源，最后得到的也是无法使用的资源。</p>

        <h2 id="2-3-初始序列号ISN意义及如何生成"   >
          <a href="#2-3-初始序列号ISN意义及如何生成" class="heading-link"><i class="fas fa-link"></i></a>2.3 初始序列号ISN意义及如何生成</h2>
      <p>起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：<code>ISN = M + F(localhost, localport, remotehost, remoteport)</code>。</p>
<ul>
<li>M 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li>F 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口</strong>生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<ul>
<li>意义：防止旧的报文被新的连接接收</li>
</ul>

        <h2 id="2-4-握手报文丢失，双方怎么办"   >
          <a href="#2-4-握手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>2.4 握手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h2 id="2-5-SYN攻击是什么，如何防范"   >
          <a href="#2-5-SYN攻击是什么，如何防范" class="heading-link"><i class="fas fa-link"></i></a>2.5 SYN攻击是什么，如何防范</h2>
      <p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列，对应着三次握手中的<code>syn_revd</code>状态；</li>
<li>全连接队列，也称 accept 队列，对应着三次握手中的<code>Established</code>状态；</li>
</ul>
<p>SYN攻击指的是对于服务器的SYN队列进行<code>ddos</code>攻击，<strong>发送大量的请求</strong>，这时候服务端会产生大量的<code>ACK+SYN</code>加以应答，但是因为客户端是不存在的，所以服务器始终等不到客户端发送过来的<code>ACK</code>，<strong>该批请求也就无法由SYN队列进入到accept队列</strong>，随着SYN队列被占满，服务器再也无法接受请求。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>

        <h1 id="3-TCP断开连接"   >
          <a href="#3-TCP断开连接" class="heading-link"><i class="fas fa-link"></i></a>3. TCP断开连接</h1>
      
        <h2 id="3-1-四次挥手总流程图"   >
          <a href="#3-1-四次挥手总流程图" class="heading-link"><i class="fas fa-link"></i></a>3.1 四次挥手总流程图</h2>
      <p><img src="/TCP.assets/1681634375484-9d1277eb-3ab7-48fe-aa30-9ae16305b331.png" alt="img"></p>
<ul>
<li>首先，客户端服务端双方起始都是可以传输数据的<code>Established</code>状态，正式进入四次挥手断开连接</li>
<li><em><strong>第一次挥手：</strong></em>客户端发送带有<code>FIN</code>标志位的报文，<strong>表示想终止这次连接</strong>，之后进入<code>FIN_WAIT1</code>阶段。</li>
<li>*<strong>第二次挥手：*<strong>服务端收到客户端发送的<code>FIN</code>报文，发送带有<code>ACK</code>头部的确认报文给客户端，表示自己已经收到。随后进入<code>Closed_Wait</code>阶段，</strong>表示等待连接的关闭</strong>，客户端接收到<code>ACK</code>确认报文后进入<code>FIN_WAIT2</code>阶段</li>
<li><em><strong>第三次挥手：</strong></em>服务端将自己想要发送给客户端的信息处理完之后发送<code>FIN</code>报文，表示<strong>服务端已没有信息需要发送给客户端</strong>。随后进入<code>Last_Ack</code>阶段，表示等待客户端的最后一次回应。</li>
<li>*<strong>第四次挥手：*<strong>客户端接受到服务端的<code>FIN</code>报文后，发送<code>ACK</code>确认报文给服务端。之后</strong>进入为期</strong><code>**2MSL**</code><strong>的</strong><code>**TIME_WAIT**</code><strong>阶段</strong>，之后断开连接。服务端收到应答之后断开连接。</li>
</ul>
<p>只有在主动发起断开连接的一方才会有<code>time_wait</code>阶段</p>

        <h2 id="3-2-服务端的SYN和ACK可否合并"   >
          <a href="#3-2-服务端的SYN和ACK可否合并" class="heading-link"><i class="fas fa-link"></i></a>3.2 服务端的SYN和ACK可否合并</h2>
      <p>在四次挥手的过程中，服务端在两个报文中间有一段<code>closed_wait</code>的阶段，那么该阶段可否跳过省略呢</p>

        <h3 id="为什么会有closed-wait的阶段"   >
          <a href="#为什么会有closed-wait的阶段" class="heading-link"><i class="fas fa-link"></i></a>为什么会有closed_wait的阶段</h3>
      <p>首先我们要知道服务端在<code>closed_wait</code>这段时间内做了什么，他主要的作用就是来处理数据，检查是否还有没发送给客户端的数据，如果有，就发送给客户端。<code>FIN</code>标志位的意思是所有数据发送完毕，想要断开请求，所以必须检查数据是否完毕。</p>
<p>他主要实现的原理是在收到客户端发送的<code>FIN</code>报文之后，将一个结束标识符<code>EOF</code>放在待处理数据的末尾，由于TCP的流传输特性，所以之后当服务端将所有数据处理完，才会读取到<code>EOF</code>，读取到<code>EOF</code>之后，才会向服务端发送<code>FIN</code>报文。</p>

        <h3 id="三次连接是否可以实现？"   >
          <a href="#三次连接是否可以实现？" class="heading-link"><i class="fas fa-link"></i></a>三次连接是否可以实现？</h3>
      <p>可以实现，条件是需要<strong>开启TCP延时确认机制</strong>并且服务端<strong>没有数据要发送</strong>。</p>

        <h3 id="TCP延时确认机制"   >
          <a href="#TCP延时确认机制" class="heading-link"><i class="fas fa-link"></i></a>TCP延时确认机制</h3>
      <p>服务端当收到客户端发送过来的<code>FIN</code>信息之后，需要回复<code>ACK</code>报文，如果只单单传输一个20字节的报文头部不携带任何报文信息，而后续需要发送的报文又独立发送，就会造成网络资源的浪费（因为内容和头部是始终需要携带的）。那么为了<strong>提高网络资源的利用效率</strong>，TCP延时确认机制产生，它主要做了下面三件事：</p>
<ul>
<li>当有响应数据需要发送时，数据会随着<code>ACK</code>头部一起发送。</li>
<li>当没有响应数据需要发送时候，服务端会等待一段时间，已确定有没有数据需要发送进而一起发送。</li>
<li>当在等待响应数据时，若又有一个请求发送过来，那么<code>ACK</code>头就会立刻发送。</li>
</ul>
<p>延迟等待时间由<code>TCP_DELACK_MIN</code>和<code>TCP_DELACK_MAX</code>决定。linux内核中默认为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="code"><pre><span class="line">TCP_DELACK_MIN = HZ/5</span><br><span class="line">TCP_DELACK_MIN = HZ/25</span><br></pre></td></tr></table></div></figure>

<p>HZ与系统的时钟周期频率相关。</p>
<p><img src="/TCP.assets/1681637532127-2e7b6ac6-f1c3-408d-804b-f4f93b4b1be3.png" alt="img"></p>
<p>TCP延时确认机制是默认开启的</p>

        <h3 id="三次连接实现原理"   >
          <a href="#三次连接实现原理" class="heading-link"><i class="fas fa-link"></i></a>三次连接实现原理</h3>
      <p>当没有数据要发送的时候，那么服务端可以直接读取到<code>EOF</code>，准备发送带有<code>FIN</code>的报文，但是因为延时确认机制，原先的<code>ACK</code>报文还没有发送，那么就将<code>FIN</code>一起写到<code>ACK</code>中，之后，<strong>等待一段时间或者知道客户端再次发送请求</strong>（分别对应了其2，3情况），那么这个没有数据但是含有<code>ACK</code>和<code>FIN</code>头部信息的报文就直接发送了。</p>

        <h2 id="3-3-挥手报文丢失，双方怎么办"   >
          <a href="#3-3-挥手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>3.3 挥手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h3 id="close和shutdown方法的比较"   >
          <a href="#close和shutdown方法的比较" class="heading-link"><i class="fas fa-link"></i></a>close和shutdown方法的比较</h3>
      <p>两者都是用于对进程的关闭，但是shutdown关闭的是该进程的发送信息功能，而接受信息功能仍然存在，close则是两个功能都将其关闭。</p>

        <h3 id="在第二次挥手中，客户端shutdown了"   >
          <a href="#在第二次挥手中，客户端shutdown了" class="heading-link"><i class="fas fa-link"></i></a>在第二次挥手中，客户端shutdown了</h3>
      <p>这是一个十分有趣的情况，第二次挥手是由服务端对于客户端的<code>FIN</code>标志的回应，发送了<code>ACK</code>确认标志，如果服务端始终不发送过来第三次挥手，正常情况下客户端是需要重发<code>FIN</code>请求的，但是因为此时客户端的<code>shutdown</code>，使得其无法发送，那么最后造就的结果便是客户端一直在<code>FIN_WAIT2</code>这个阶段卡住，无法关闭。服务端重发请求到达上限时间次数便会自己断开连接。</p>

        <h2 id="3-4-TIME-WAIT状态"   >
          <a href="#3-4-TIME-WAIT状态" class="heading-link"><i class="fas fa-link"></i></a>3.4 TIME_WAIT状态</h2>
      
        <h3 id="TIME-WAIT状态的时间是多少"   >
          <a href="#TIME-WAIT状态的时间是多少" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态的时间是多少</h3>
      <p>2MSL（Maximum Segment Lifetime，报文最大生存时间）。非常巧合的是，我们发现，这个时间便是一次<strong>客户端和服务端之间交互一来一回</strong>的时间。</p>

        <h3 id="TIME-WAIT状态存在的原因"   >
          <a href="#TIME-WAIT状态存在的原因" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态存在的原因</h3>
      <ul>
<li><em>确保新的相同的四元组TCP连接不要接收到旧的报文信息。</em></li>
</ul>
<p>主要是<strong>为了避免第四次挥手的丢失，</strong>客户端发送完成第四次挥手<code>ACK</code>之后就断开连接，那么万一服务端没有收到<code>ACK</code>确认，又重发了一次<code>FIN</code>，此时客户端无法收到他的请求。此时恰好又有一个相同的四元组TCP连接建立了起来，这时候旧的<code>FIN</code>或者数据就会发送到新的连接。会客户端收到错误的信息或者造成新的连接无法将其信息发送完整就断开连接。</p>
<ul>
<li><em>保证被动关闭的一方能够</em>***正常关闭***<em>。</em></li>
</ul>
<p>还是基于第四次挥手的丢失，服务端重新发送<code>FIN</code>报文之后，因为客户端已经关闭，所以无法收到他的<code>ACK</code>报文，那么最后关闭只能是因为超时被动断开连接了。这样既浪费了服务器资源，又对于服务器是有危害的。</p>

        <h3 id="TIME-WAIT状态过多的危害"   >
          <a href="#TIME-WAIT状态过多的危害" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态过多的危害</h3>
      <p>TIME_WAIT状态其实是一种阻塞的表现，等待至少2MSL的时间，而这个时间对<strong>端口号</strong>来说是占用的。如果网络不通畅，那么端口号资源就被占用的极多，就会无法对于服务端建立连接了。会占用<strong>系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>

        <h3 id="如何优化-TIME-WAIT？"   >
          <a href="#如何优化-TIME-WAIT？" class="heading-link"><i class="fas fa-link"></i></a>如何优化 TIME_WAIT？</h3>
      <ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p>第一二种方法主要是通过控制<code>TIME_WAIT</code>的时间加以控制，第三种方法则是直接跨过了<code>TIME_WAIT</code>。都存在着一定上诉提到的风险。</p>

        <h3 id="long-alive-长连接状态"   >
          <a href="#long-alive-长连接状态" class="heading-link"><i class="fas fa-link"></i></a>long-alive 长连接状态</h3>
      <p>这个状态我们可以在请求报文的头部信息中看到，开启状态表示一次请求交互完成之后<strong>不立刻断开，也就表示着后面还有请求需要进行处理</strong>。那么如果每次请求都进行握手挥手网络资源消耗量极大，于是用长连接状态表示不立刻断开。如果交互确实进行完成，那么<strong>只要有一方</strong>发送断开连接请求，那么就会来到四次挥手的状态。</p>
<p><em>什么场景下服务端会主动断开连接呢？</em></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>

        <h2 id="3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"   >
          <a href="#3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="heading-link"><i class="fas fa-link"></i></a>3.5 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h2>
      <p>说明没有发出<code>FIN</code>报文，无法到达下一步<code>LAST_ACK</code>。那么也就是说无法调用<code>closed</code>方法。</p>
<p>通常是代码的问题，主要排查方向是为何服务端调用不到<code>closed</code>方法。</p>

        <h2 id="3-6-建立连接后一方发生故障会怎么样？"   >
          <a href="#3-6-建立连接后一方发生故障会怎么样？" class="heading-link"><i class="fas fa-link"></i></a>3.6 建立连接后一方发生故障会怎么样？</h2>
      
        <h3 id="保活机制"   >
          <a href="#保活机制" class="heading-link"><i class="fas fa-link"></i></a>保活机制</h3>
      <p>通过开启<code>SO_KEEPALIVE</code> 选项生效。</p>
<p>在一个时间段内，如果<strong>任何连接相关的传输的活动</strong>都没有产生，那么每隔一个时间段就发送一次探测报文，如果均没有得到回应，就断定该TCP连接已经死亡。</p>
<p>linux中默认参数如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">7200</span> <span class="comment">//没有活动的时间长度</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl=<span class="number">75</span>  <span class="comment">//发送探测报文的相隔时间段</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">9</span>	 <span class="comment">// 发送探测报文的次数</span></span><br></pre></td></tr></table></div></figure>

<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>

        <h3 id="进程突然被closed"   >
          <a href="#进程突然被closed" class="heading-link"><i class="fas fa-link"></i></a>进程突然被closed</h3>
      <p>如前文所讲，挥手报文丢失的情况。</p>

        <h3 id="主机突然发生宕机"   >
          <a href="#主机突然发生宕机" class="heading-link"><i class="fas fa-link"></i></a>主机突然发生宕机</h3>
      <p>客户端主机崩溃了，服务端是<strong>无法感知到</strong>的，在保活机制时间激活之前，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，在双方不传输数据的情况下，<strong>一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</strong></p>

        <h3 id="客户端的网络连接突然断开"   >
          <a href="#客户端的网络连接突然断开" class="heading-link"><i class="fas fa-link"></i></a>客户端的网络连接突然断开</h3>
      <p>TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p>换而言之，TCP连接一旦建立，就生成了两个独立的结构存储在<strong>本地</strong>，和传输层的连接关系已然不大。</p>
<p>之后，发送就如同进程被closed的状态，直至重新连上网络，方可恢复正常。</p>

        <h1 id="4-TCP的四个机制"   >
          <a href="#4-TCP的四个机制" class="heading-link"><i class="fas fa-link"></i></a>4. TCP的四个机制</h1>
      
        <h2 id="4-1-重传机制"   >
          <a href="#4-1-重传机制" class="heading-link"><i class="fas fa-link"></i></a>4.1 重传机制</h2>
      
        <h3 id="超时重传"   >
          <a href="#超时重传" class="heading-link"><i class="fas fa-link"></i></a>超时重传</h3>
      <p>顾名思义，<strong>超时重传指的是当发送方超过一定时间没有收到回复的时候，重新发送数据报文。</strong></p>
<ul>
<li><strong>RTT（Routing-trip time）</strong>往返时延，指的是一个数据包从发送到接受到回应所需要经过的时间长度</li>
<li>**RTO (**<strong>Retransmission Timeout</strong> <strong>)</strong> 超时发送时间，指的是超时重传的时间。</li>
</ul>
<p>一般在超时重传机制中，RTO会略大于RTT。</p>
<p>RTO太大或者太小的坏处：</p>
<ul>
<li><strong>太大</strong>：<strong>浪费网络资源，网络收发包效率低下，影响用户体验。</strong>首先发送等待请求的时候，发送方就无法给其他主机发送信息，RTO过长会导致发送方资源的浪费。而且响应的时间变慢，网络传输效率低下，影响了用户的体验。</li>
<li><strong>太小</strong>：<strong>浪费了传输的资源，增加网络阻塞。</strong>也许是回应包还没有发送到，就重新发送，这样会导致发送了两个相同的数据包，对传输资源是一种浪费。</li>
</ul>
<p><strong>超时重传的弊端</strong>：时间过久，影响用户体验。</p>

        <h3 id="快速重传"   >
          <a href="#快速重传" class="heading-link"><i class="fas fa-link"></i></a>快速重传</h3>
      <p>快速重传的工作原理是<strong>收到三个相同的ACK报文时，再发送一次ACK报文下一个的请求报文。</strong></p>
<p>因为TCP连接中基于字节流的特性，报文的传输是有序的，因此响应的ACK所发送过来的序列号就表示该序列号之前的所有报文都已经接收完成。但是后面的响应生死未卜。所以快速重传机制会认为对方没有接收到后续的请求报文，所以重新发送一遍。</p>
<p>但是这种做法存在着问题，你<strong>后面的数据包有多少是没有收到的</strong>，发送方要重新发送多少数据包，这些是快速重传无法得知的，所以我们有了<code>SACK</code>重传机制。</p>

        <h3 id="SACK-amp-amp-D-SACK"   >
          <a href="#SACK-amp-amp-D-SACK" class="heading-link"><i class="fas fa-link"></i></a>SACK &amp;&amp; D-SACK</h3>
      <p>SACK(select-acknowledge) 选择性确认，接收方发送ACK响应的时候，会告诉发送方自己接受到了哪些数据。这能够解决快速重传机制存在的问题。D-SACK（Duplicate SACK），D-SACK告诉发送方那些数据是重复发送的。</p>

        <h2 id="4-2-滑动窗口"   >
          <a href="#4-2-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4.2 滑动窗口</h2>
      <p>TCP头部信息中的窗口大小（16位）指的就是这个窗口的大小。指的是接受数据的能力。<strong>在未接受到接受方的应答（数据还没有被处理）的时候，发送方能发送的数据总容量大小。</strong>通常该属性由接收方的窗口大小决定。</p>

        <h3 id="发送方的窗口大小参数"   >
          <a href="#发送方的窗口大小参数" class="heading-link"><i class="fas fa-link"></i></a>发送方的窗口大小参数</h3>
      <ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA（Send Unacknoleged）</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。<strong>可用窗口大小 &#x3D;</strong> <code>**SND.WND -(SND.NXT - SND.UNA)**</code></li>
</ul>

        <h2 id="4-3-流量控制"   >
          <a href="#4-3-流量控制" class="heading-link"><i class="fas fa-link"></i></a>4.3 流量控制</h2>
      <p>TCP一般会使用<strong>滑动窗口机制</strong>来进行流量控制，简单来讲，就是接收方通过发送窗口的大小来告诉发送方，我还有多少地方可以承受你发的数据，如果太多的话，会造成丢包的情况。</p>

        <h3 id="丢包情况"   >
          <a href="#丢包情况" class="heading-link"><i class="fas fa-link"></i></a>丢包情况</h3>
      <p>但是在业务繁忙的时候，丢包情况也会发生。很简单的一个例子，当接收方窗口大小发生改变的时候，他会立刻发送报文告知发送方，但是发送方在接收到接收方发送的报文之前，就已经将一条数据容量超过窗口大小的数据发送给接收方，那么这时候就会产生丢包的现象。</p>

        <h3 id="死锁情况"   >
          <a href="#死锁情况" class="heading-link"><i class="fas fa-link"></i></a>死锁情况</h3>
      <p>这里指的是双方都无从得知对方的状态，从而进入了相对隔离的，无法更新对方信息的状态。那么造成这种结果的原因是：<strong>接收方更新窗口大小为非0的报文丢失在了网络中</strong>，这种情况下，发送方不知道对方已经处理完成信息了，会一直等待，而接收方也在一直等待发送方发送过来的信息。</p>
<ul>
<li>解决方法：</li>
</ul>
<p><strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>这个计时器会在没有收到窗口信息传递报文的一定时间内，发送窗口探测报文，而接收方一旦收到这个报文，就会将自己目前的窗口大小发送。通过外界的力量打破了两者之间相互隔离的状态。</p>

        <h3 id="糊涂窗口综合症"   >
          <a href="#糊涂窗口综合症" class="heading-link"><i class="fas fa-link"></i></a>糊涂窗口综合症</h3>
      <p>这里指的是发送方太过于急于求成，可以算是一种贪心算法。只要接收方告诉发送方自己目前有多少个字节的窗口，那么发送方就会毫不犹豫的发送这么多字节的包过去。</p>
<p>但是这样有一个缺点，万一接收方剩余的窗口很小，而TCP的头部是需要占掉很大一部分的，所以说有时候是一笔得不偿失的交易。</p>
<p>那么为了避免这种情况，发送方针对发送数据的大小做出了规定：</p>
<p>接收方采用的策略如下：</p>
<p>不发送小窗口给发送方</p>
<p>发送方通常的策略如下:</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; MSS 并且 数据大小 &gt;&#x3D; MSS；</li>
<li>条件二：收到之前发送数据的 ack 回包；</li>
</ul>

        <h2 id="4-4-拥塞控制"   >
          <a href="#4-4-拥塞控制" class="heading-link"><i class="fas fa-link"></i></a>4.4 拥塞控制</h2>
      <p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少；</li>
</ul>
<p>拥塞控制主要有如下四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>

        <h3 id="慢启动"   >
          <a href="#慢启动" class="heading-link"><i class="fas fa-link"></i></a>慢启动</h3>
      <p>慢启动的意思就是一点一点的提高发送数据包的数量，<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong>慢启动的增长为指数型增长。</p>
<p>有一个叫慢启动门限 <code>ssthresh （slow start threshold）</code>状态变量。</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p>一般来说 ssthresh 的大小是 65535 字节。</p>

        <h3 id="拥塞避免"   >
          <a href="#拥塞避免" class="heading-link"><i class="fas fa-link"></i></a>拥塞避免</h3>
      <p><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong>它属于线性增长，增长较慢。</p>

        <h3 id="拥塞发生"   >
          <a href="#拥塞发生" class="heading-link"><i class="fas fa-link"></i></a>拥塞发生</h3>
      <p>就是在拥塞时，将窗口大小紧急下降。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li>
<li>ssthresh &#x3D; cwnd;</li>
<li>进入快速恢复算法</li>
</ul>

        <h3 id="快速恢复"   >
          <a href="#快速恢复" class="heading-link"><i class="fas fa-link"></i></a>快速恢复</h3>
      <p>进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>

        <h1 id="5-TCP优化的连接"   >
          <a href="#5-TCP优化的连接" class="heading-link"><i class="fas fa-link"></i></a>5. TCP优化的连接</h1>
      
        <h2 id="5-1-从三次握手的角度进行优化"   >
          <a href="#5-1-从三次握手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.1 从三次握手的角度进行优化</h2>
      <p>因为<strong>三次握手是服务端和客户端之间建立联系的前提条件</strong>，不涉及到任何具体传输数据的传输，而只是进行了<strong>一些状态和校验的传输</strong>。因为正常情况下的用时基本可以忽略不记。所以我们可以将优化点放在具体传输的<strong>异常状态</strong>中，去通过调节参数来对三次握手进行加速。</p>

        <h3 id="5-1-1-超时重传的参数调节-client"   >
          <a href="#5-1-1-超时重传的参数调节-client" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 超时重传的参数调节(client)</h3>
      <p>在网络状态堵塞的情况下，超时重传是不可避免的。但是超时了时候重传几次，采取什么策略。就会对于网络连接的效率起到一定的影响作用。</p>
<ul>
<li><strong>超时重传的次数过少：</strong>可能会引发重复传输，影响网络的资源利用率。只是因为网络拥堵，数据包没有丢失只是到达的时间较慢。而在发送一次请求只会对于本就拥塞的网络进行加塞。</li>
<li><strong>超时重传的次数过多：</strong>可能没办法及时发现问题，让一个达不到目的地，没有接收到的连接一直占用着网络资源。导致网络资源利用率的下降。</li>
</ul>
<p><strong>如何调节超时重传次数：</strong>通过控制<code>tcp_syn_retries</code>参数来控制重传次数。在linx内核中默认值为<code>5</code>，每次超时重传的时间为上一次的两倍。初始值为<code>1</code></p>

        <h3 id="5-1-2-半连接队列的参数调节-service"   >
          <a href="#5-1-2-半连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 半连接队列的参数调节(service)</h3>
      <p>半连接队列指的是服务端接受到客户端的第一次握手请求发送的时候，会将这个连接的中间态放到半连接队列中，<strong>主要用来存储准备启用但尚未启用的连接</strong>。那么对于三次握手的<code>SYN攻击</code>指的是通过不断发送只发送第一次请求的连接，将半连接队列占满，使得后面与服务端请求的连接无法获得通讯。那么怎么去尽量避免这种情况呢，有如下两种做法：</p>
<ul>
<li>调节syn队列的大小：通过调节<code>somaxconn</code>, <code>backlog</code>, <code>tcp_max_syn_conn</code>三个参数来共同调节syn队列的大小，其中，前两个参数是调整<code>accept</code>队列的大小，但是也能够同时调整到半连接队列的大小。</li>
<li>通过设置<code>synCookie</code>参数来进行调节： 这个cookie的主要作用是存储半连接队列中连接的信息。将这个信息连同第二次握手一起发送，这样就可以替代半连接队列的作用了。但是也不能一直开启，一直开启就表示忽略半连接队列，将之前的信息全部再做一次传输，那么服务器的压力就会增大。</li>
</ul>
<p>syn_cookie有三个值：0表示不开启，1表示当半连接队列满时开启，2表示一直开启。默认为1</p>

        <h3 id="5-1-3-全连接队列的参数调节-service"   >
          <a href="#5-1-3-全连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 全连接队列的参数调节(service)</h3>
      <p><code>tcp_abort_on_overflow</code> 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；</li>
<li>1 ：如果 accept 队列满了，server 发送一个 RST 包给 client，表示废掉这个握手过程和这个连接；</li>
</ul>
<p><code>accept</code>队列的长度取决于 <code>somaxconn</code> 和 <code>backlog</code> 之间的最小值，也就是 <code>min(somaxconn, backlog)</code>，</p>

        <h3 id="5-1-4-如何绕过三次握手"   >
          <a href="#5-1-4-如何绕过三次握手" class="heading-link"><i class="fas fa-link"></i></a>5.1.4 如何绕过三次握手</h3>
      <p>linux3.7 版本后，提供了<code>tcp fast open</code>的方式：</p>
<p>在客户端首次建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</p>
<p>节约了一个TTL的时间。</p>

        <h2 id="5-2-从四次挥手的角度进行优化"   >
          <a href="#5-2-从四次挥手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.2 从四次挥手的角度进行优化</h2>
      <p><img src="/TCP.assets/1683213868660-eb84aef1-f40d-40cb-abff-9c9a4c341f01.png" alt="img"></p>
<p><strong>主动方的优化</strong></p>
<p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</p>
<p>当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：</p>
<ul>
<li>如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 <code>tcp_fin_timeout</code> 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，<code>tcp_max_orphans</code> 定义了最大孤儿连接的数量，超过时连接就会直接释放。</li>
<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li>
</ul>
<p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，<code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p>
<p><strong>被动方的优化</strong></p>
<p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p>
<p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文。</p>

        <h2 id="5-3-传输过程中进行优化"   >
          <a href="#5-3-传输过程中进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.3 传输过程中进行优化</h2>
      <p><img src="/TCP.assets/1683213899231-4a98a853-41fe-47ef-9010-09c2de5e47a4.png" alt="img"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
