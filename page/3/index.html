<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.1.1" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.1.1" type="image/png" sizes="32x32"><meta name="description" content="这是我的个人博客，记录计算机学习之路！">
<meta property="og:type" content="website">
<meta property="og:title" content="阿荣的个人博客">
<meta property="og:url" content="https://www.arong.icu/page/3/index.html">
<meta property="og:site_name" content="阿荣的个人博客">
<meta property="og:description" content="这是我的个人博客，记录计算机学习之路！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Arong">
<meta name="twitter:card" content="summary"><title>阿荣的个人博客</title><link ref="canonical" href="https://www.arong.icu/page/3/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.1.1"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":false,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":true},
  reward: false,
  fancybox: true,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"恭喜您，复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.3.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fa fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fa fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fa fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fa fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fa fa-user"></i></span><span class="header-nav-menu-item__text">博主</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/read/"><span class="header-nav-menu-item__icon"><i class="fa fa-book"></i></span><span class="header-nav-menu-item__text">阅读</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">阿荣的个人博客</div><div class="header-banner-info__subtitle">一起学习学不完的计算机吧</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fa fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/32766/">数组</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">17分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-数组的基础定义"   >
          <a href="#1-数组的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 数组的基础定义</h1>
      <ul>
<li>数组的下标是从0开始的</li>
<li>数组中的地址是连续的</li>
</ul>
<p>要删除数组中的元素只能用替换去实现，无法直接删去</p>
<hr>

        <h1 id="2-二分法"   >
          <a href="#2-二分法" class="heading-link"><i class="fas fa-link"></i></a>2. 二分法</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search/description/" >Problem 704. 二分查找</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>类似参考题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/search-insert-position/" >Problem 35.搜索插入位置 </a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" >Problem 34.在排序数组中查找元素的第一个和最后一个位置</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="2-1-使用条件"   >
          <a href="#2-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>2.1 使用条件</h2>
      <p>在求解寻找数组中的元素，或者满足条件的值会出现在数组的范围内（如求平方根）等内容时可使用；</p>
<p>使用时数组需满足如下条件（或变化后）：</p>
<ul>
<li>数组升序或者降序排列，即有序数组</li>
<li>数组中无重复项的出现</li>
</ul>

        <h2 id="2-2-时间复杂度"   >
          <a href="#2-2-时间复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.2 时间复杂度</h2>
      <ul>
<li>暴力解法时间复杂度：<code>O(n)</code></li>
<li>二分法时间复杂度：<code>O(logn)</code></li>
</ul>

        <h2 id="2-3-主要思想"   >
          <a href="#2-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.3 主要思想</h2>
      <p>通过在有序数组中<strong>划分中间值</strong>，判断所求值与中间值之间的关系，较暴力解法可以<strong>直接排除掉</strong>一些不在范围之内的比较，提升了运行效率。</p>
<p><mark>有序数组：索引定位数据，索引的大小关系即为数组元素的大小关系。</mark></p>
<p>要定义的几个参数：</p>
<p>开始位置：<code>left = 0;</code>（数组下标索引从0开始）</p>
<p>结束位置：<code>right = nums.size() - 1;</code> </p>
<p>中间值：<code>mid = left + ((right - left) &gt;&gt; 1) </code> (位运算，可以防止数组越界现象出现)</p>

        <h2 id="2-4-注意点"   >
          <a href="#2-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.4 注意点</h2>
      <ul>
<li>区间的划分</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原因是此时mid的值一定不是我们寻找的，否则不会出现在这个循环，那么我们在移动的时候也可以不考虑这个值</span></span><br><span class="line"><span class="keyword">if</span> (nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>; <span class="comment">// target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>循环终止判断条件</li>
</ul>
<figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right) <span class="comment">// 当left==right，区间[left, right]依然有效，所以用 &lt;=</span></span><br></pre></td></tr></table></div></figure>




        <h2 id="2-5-完整代码"   >
          <a href="#2-5-完整代码" class="heading-link"><i class="fas fa-link"></i></a>2.5 完整代码</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">//定义数组的左节点</span></span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>()<span class="number">-1</span>; <span class="comment">//定义数组的右节点</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">                <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//定义中间点，防止索引越界</span></span><br><span class="line">                <span class="keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>; <span class="comment">// 目标值在左区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>; <span class="comment">// 目标值在右区间</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target == nums[mid]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

<hr>

        <h1 id="3-双指针法"   >
          <a href="#3-双指针法" class="heading-link"><i class="fas fa-link"></i></a>3. 双指针法</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-element/" >Problem 27.移除元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/squares-of-a-sorted-array/" >Problem 977.有序数组的平方</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-1-使用条件"   >
          <a href="#3-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>3.1 使用条件</h2>
      <p>需要双重遍历：需要实现先定位元素，再实现元素修改的题目，都可以用双指针法。</p>
<p>双指针法（快慢指针法）： <strong>通过一个快指针和慢指针<mark>在一个for循环下完成两个for循环</mark>的工作。</strong></p>
<p>定义快慢指针</p>
<ul>
<li>快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组</li>
<li>慢指针：指向<mark>更新</mark>新数组下标的位置</li>
</ul>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p><code>fastIndex</code>指针用来寻找要<strong>删除</strong>的值，<code>slowIndex</code>指针用来定位要<strong>修改</strong>的值</p>
<p>在删除元素这道题目中，体现在<code>fastIndex</code>在一直在移动，而通过判断<code>if(nums[fastIndex] != val) </code>来控制是否替换，相当于核心思想是在<mark>原有的数组上替换了一个新的数组，这个数组元素所要满足的条件就是if判断的条件</mark>。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>用双指针移动删除元素可以使得时间复杂度下降，只需要一个循环遍历即可，一个指针用来寻找删除元素，另一个指针用来实现替换操作。 这里用for循环，不用while循环的原因是： for循环一般用于有终止条件，变量只有一个并且判断条件可以简单的用一个boolean表达式表现出来，而while循环主要用于迭代条件较为复杂，例如二分查找法的情况，左右节点都需要根据不同情况进行更新。 而在双指针中，fastIndex指针是无条件一直向前运行的，我们只需在循环体中控制slowIndex指针即可。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//双指针删除元素 fast指针用于搜索，slow指针用于替换值</span></span><br><span class="line">        <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束条件，搜索指针搜索完成。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>; fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fastIndex] != val) &#123;</span><br><span class="line">                nums[slowIndex ++] = nums[fastIndex];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowIndex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<p><font size=4><strong>双指针Pro（相向双指针）：</strong></font></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> rightIndex = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftIndex &lt;= rightIndex) &#123;</span><br><span class="line">            <span class="comment">// 找左边等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[leftIndex] != val)&#123;</span><br><span class="line">                leftIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找右边不等于val的元素</span></span><br><span class="line">            <span class="keyword">while</span> (leftIndex &lt;= rightIndex &amp;&amp; nums[rightIndex] == val) &#123;</span><br><span class="line">                rightIndex-- ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将右边不等于val的元素覆盖左边等于val的元素</span></span><br><span class="line">            <span class="keyword">if</span> (leftIndex &lt; rightIndex) &#123;</span><br><span class="line">                nums[leftIndex++] = nums[rightIndex--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftIndex;   <span class="comment">// leftIndex一定指向了最终数组末尾的下一个元素，原因是因为有几个val就代表被中断了几次，此时只有单向运动，长度就会缩减</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="4-滑动窗口"   >
          <a href="#4-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4. 滑动窗口</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <ul>
<li>例题：</li>
</ul>
<p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-size-subarray-sum/" >Problem 209.长度最小的子数组</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<ul>
<li>相关题目：</li>
</ul>

        <h2 id="4-1-使用条件"   >
          <a href="#4-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>4.1 使用条件</h2>
      <p>数组中满足条件的最小子数组。一般求解需要经过两个步骤，首先需要先判断出有哪些满足条件的情况<strong>存在</strong>。之后再去这些满足条件存在中求解<strong>最优</strong>。</p>
<p>一般会出现如下条件需要去定义：</p>
<ul>
<li>滑动窗口的起始点（可以理解为快指针）</li>
<li>滑动窗口的终止点（可以理解为慢指针）</li>
<li>滑动窗口内条件的表示：例如最大值，元素相等之类的</li>
</ul>

        <h2 id="4-2-复杂度"   >
          <a href="#4-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.2 复杂度</h2>
      <ul>
<li>时间复杂度：<code>O(n)</code></li>
</ul>
<blockquote>
<p>主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被操作两次，所以时间复杂度是 2 × n 也就是O(n)。</p>
</blockquote>
<ul>
<li>空间复杂度：<code>O(1)</code></li>
</ul>

        <h2 id="4-3-主要思想"   >
          <a href="#4-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.3 主要思想</h2>
      <p>时间复杂度的优化其实可以简略的看成循环的优化，而循环优化的最主要思想之一就是<mark>能否对相关项进行合并</mark>。换而言之就是变量之间能不能够相互解释。</p>
<p>对比暴力解法和滑动窗口能够发现其精妙之处：</p>
<ul>
<li>暴力解法：判断满足条件的子数组存在（一层遍历） &#x3D;&#x3D;&#x3D;&gt; 子数组内判断是否最优（存在遍历中的遍历）&#x3D;&#x3D;&#x3D;&gt; 比较</li>
<li>滑动窗口：移动终止点去判断是否存在 &#x3D;&#x3D;&#x3D;&gt; 移动起始点去求最优</li>
</ul>
<p>这时候我们会发现，其实滑动窗口用了条件这个东西同时判断了两个值， 而暴力解法则是在数组内部又进行了一个数组的判断，所以我们其实可以用两个点窗口大小去表示条件的时候，这样做就相当于实现了循环次数的减少。</p>

        <h2 id="4-4-注意点"   >
          <a href="#4-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.4 注意点</h2>
      <ol>
<li><p>求和的操作很巧妙，融合在一起表现在头指针移动会影响到数组和值，尾指针移动也能够影响到数组的和值。</p>
</li>
<li><p>数组最小长度的迭代更新，首先直接替换肯定不行，因为无法确定最后一个就是最小的。然后自己比自己求最小也不行，因为你需要一个0的初始值。所以在这里需要引入一个新的变量，result &#x3D; INT32_MAX。</p>
</li>
</ol>
<blockquote>
<p>INT32_MAX是一个常量，表示极大值，主要作用是有值时第一次比较时一定会被替换成result, 如果没有被比较到，那么最后返回结果用三元运算符返回0即可。</p>
</blockquote>

        <h2 id="4-5-代码实现"   >
          <a href="#4-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为其要变化两个量：最小数组的开始值，数组的长度，所以可能需要两次for循环来找到答案</span></span><br><span class="line">        <span class="comment">//滑动窗口法:将结果看成是变化，找到大于target的数组，之后不断缩小，贪心算法？</span></span><br><span class="line">        <span class="type">int</span> fastIndex = <span class="number">0</span>, slowIndex = <span class="number">0</span>, sum = <span class="number">0</span>, length = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="comment">//小于等于是考虑末值的条件</span></span><br><span class="line">        <span class="keyword">for</span>(;fastIndex &lt; nums.<span class="built_in">size</span>(); fastIndex++) &#123;</span><br><span class="line">            <span class="comment">//求和放在和</span></span><br><span class="line">            sum += nums[fastIndex];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                length = (fastIndex - slowIndex + <span class="number">1</span>) ;</span><br><span class="line">                result = result &gt; length ? length : result;</span><br><span class="line">                sum -= nums[slowIndex];</span><br><span class="line">                slowIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result == INT32_MAX ? <span class="number">0</span> : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>



<hr>

        <h1 id="5-螺旋矩阵"   >
          <a href="#5-螺旋矩阵" class="heading-link"><i class="fas fa-link"></i></a>5. 螺旋矩阵</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/spiral-matrix-ii/" >Problem 59.螺旋矩阵</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-使用条件"   >
          <a href="#5-1-使用条件" class="heading-link"><i class="fas fa-link"></i></a>5.1 使用条件</h2>
      <p>题目告诉你要用螺旋矩阵，没有什么特别算法的意思，更多的是体现了一种对语言的运用和流程的表述</p>

        <h2 id="5-2-复杂度"   >
          <a href="#5-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.2 复杂度</h2>
      
        <h2 id="5-3-主要思想"   >
          <a href="#5-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.3 主要思想</h2>
      <p>模拟顺时针画矩阵的过程:</p>
<ul>
<li>填充上行从左到右</li>
<li>填充右列从上到下</li>
<li>填充下行从右到左</li>
<li>填充左列从下到上</li>
</ul>
<p>由外向内一圈一圈这么画下去。</p>

        <h2 id="5-4-注意点"   >
          <a href="#5-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.4 注意点</h2>
      <p>开闭区间的判断</p>

        <h2 id="5-5-代码实现"   >
          <a href="#5-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.5 代码实现</h2>
      <figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>)); <span class="comment">// 使用vector定义一个二维数组</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>; <span class="comment">// 定义每循环一个圈的起始位置</span></span><br><span class="line">        <span class="type">int</span> loop = n / <span class="number">2</span>; <span class="comment">// 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理</span></span><br><span class="line">        <span class="type">int</span> mid = n / <span class="number">2</span>; <span class="comment">// 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">// 用来给矩阵中每一个空格赋值</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>; <span class="comment">// 需要控制每一条边遍历的长度，每次循环右边界收缩一位</span></span><br><span class="line">        <span class="type">int</span> i,j;</span><br><span class="line">        <span class="keyword">while</span> (loop --) &#123;</span><br><span class="line">            i = startx;</span><br><span class="line">            j = starty;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面开始的四个for就是模拟转了一圈</span></span><br><span class="line">            <span class="comment">// 模拟填充上行从左到右(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (j = starty; j &lt; n - offset; j++) &#123;</span><br><span class="line">                res[startx][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充右列从上到下(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (i = startx; i &lt; n - offset; i++) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充下行从右到左(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt; starty; j--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 模拟填充左列从下到上(左闭右开)</span></span><br><span class="line">            <span class="keyword">for</span> (; i &gt; startx; i--) &#123;</span><br><span class="line">                res[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)</span></span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// offset 控制每一圈里每一条边遍历的长度</span></span><br><span class="line">            offset += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果n为奇数的话，需要单独给矩阵最中间的位置赋值</span></span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span>) &#123;</span><br><span class="line">            res[mid][mid] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/44087/">IP</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">20分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-IP基本认识"   >
          <a href="#1-IP基本认识" class="heading-link"><i class="fas fa-link"></i></a>1.IP基本认识</h1>
      
        <h2 id="1-1-IP的基础概念"   >
          <a href="#1-1-IP的基础概念" class="heading-link"><i class="fas fa-link"></i></a>1.1 IP的基础概念</h2>
      <p>是位于网络层的一个协议，实现<strong>主机和主机之间的通信</strong>，也叫<strong>点对点通信</strong>。</p>
<p>通过<strong>源IP地址</strong>和<strong>目标IP地址</strong>这两个关键信息，在众多路由器的转发中实现通信。</p>
<p>路由器实现转发机制：当一台主机朝网络中发送数据包时，他会将目标IP地址设置为接收方的IP地址。随后传给<strong>本地网络</strong>，本地网络中的路由器通过检查数据包中的目标IP地址，并与自己的<strong>路由表</strong>进行匹配。如果发现目标ip地址时自己的网络，就会转发回去，否则，转发到路由表上对应的路由器。</p>
<p>具体转发机制：<span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/145946764?utm_id=0" >https://zhuanlan.zhihu.com/p/145946764?utm_id=0</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="1-2-IP和MAC的区别"   >
          <a href="#1-2-IP和MAC的区别" class="heading-link"><i class="fas fa-link"></i></a>1.2 IP和MAC的区别</h2>
      <ul>
<li>位置不同：MAC位于数据链路层，IP位于网络层</li>
<li>管理内容不同：IP管理的是网络间两台<strong>没有直连</strong>主机之间的位置，数据链路层强调的是两台设备在物理意义上的<strong>直接连接</strong></li>
<li>也就是说，数据链路层可以是主机和路由器之间的连接，而IP只能是主机和主机之间的连接．而ip主机和主机之间的连接中间还隔了若干路由器。</li>
</ul>

        <h1 id="2-IP地址的基础知识"   >
          <a href="#2-IP地址的基础知识" class="heading-link"><i class="fas fa-link"></i></a>2.IP地址的基础知识</h1>
      
        <h2 id="2-1-IP地址的基础定义"   >
          <a href="#2-1-IP地址的基础定义" class="heading-link"><i class="fas fa-link"></i></a>2.1 IP地址的基础定义</h2>
      <p>在 TCP&#x2F;IP 网络通信时，为了保证能正常通信，每个设备都需要配置正确的 IP 地址，否则无法实现正常的通信。</p>
<p>针对IPV4协议的IP地址进行分析</p>

        <h3 id="点分十进制"   >
          <a href="#点分十进制" class="heading-link"><i class="fas fa-link"></i></a>点分十进制</h3>
      <p>IPV4协议中的IP地址是32位的，人类为了方便记忆，使用点分十进制的方法对ip地址进行了简化，即将32位IP地址每八位划分为1组，每组之间用点(<code>.</code>)隔开，再将每组都用十进制的方式表示出来。</p>
<p><img src="/IP.assets/1683941331597-512b688a-8b33-485c-aa99-bd6e08ab3fc7.png" alt="img"></p>

        <h2 id="2-2-IP地址的分类"   >
          <a href="#2-2-IP地址的分类" class="heading-link"><i class="fas fa-link"></i></a>2.2 IP地址的分类</h2>
      <p><img src="/IP.assets/1683943728185-7e904a24-9f8d-4265-ab9f-ffec2396660f.png" alt="img"></p>

        <h3 id="ABC类地址"   >
          <a href="#ABC类地址" class="heading-link"><i class="fas fa-link"></i></a>ABC类地址</h3>
      <p>ABC类地址由两个部分组成：<strong>网络号和主机号</strong>，前面的<code>0</code>,<code>10</code>,<code>110</code>是用于区分这三类地址的最快捷的方式。</p>
<p><img src="/IP.assets/1683943855883-a3824a6d-4e65-409d-9e71-288a8aba4383.png" alt="img"></p>
<p>其对应的最大主机数的计算公式为：<code>2n-2</code>, 其中n为主机号的位数。减去2的原因是因为有两个特殊ip地址不能够被使用：</p>
<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于<strong>广播</strong></li>
<li>主机号全为 0 指定某个网络</li>
</ul>

        <h3 id="DE类地址"   >
          <a href="#DE类地址" class="heading-link"><i class="fas fa-link"></i></a>DE类地址</h3>
      <p><img src="/IP.assets/1683944097408-4c2af274-7442-41a9-8887-35b78166b947.png" alt="img"></p>
<p>因为DE类地址中没有主机号，所以其不可以用于主机ip。</p>
<ul>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li>
</ul>
<p>广播和组播(多播)的区别：</p>
<p>广播：在一个局域网内，所有的IP地址都会收到这个信息，同一个链路中相互连接的主机之间发送数据包</p>
<p>组播：将信息发送给特定组内的所有主机，也就是说广播比组播的范围更加广泛，但是考虑到安全性的话，组播是更为优秀的。</p>
<p><strong>由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</strong></p>

        <h2 id="2-3-无分类地址-CIDR"   >
          <a href="#2-3-无分类地址-CIDR" class="heading-link"><i class="fas fa-link"></i></a>2.3 无分类地址 CIDR</h2>
      <p>针对于<strong>ABC类IP地址最大主机数分配不均匀</strong>的问题，提出了一种新的地址分类方式。</p>
<p>表示形式 a.b.c.d&#x2F;x，其中 &#x2F;x 表示前 x 位属于<strong>网络号</strong>， x 的范围是 0 ~ 32</p>
<p>子网掩码方式获取主机号：</p>
<p><img src="/IP.assets/1683944728553-c93926e6-a4af-420c-9271-50aec45ffec9.png" alt="img"></p>
<p>子网掩码还可以获取子网网络号，可以对网络层级做到进一步划分。</p>

        <h2 id="2-4-IP地址一些特性"   >
          <a href="#2-4-IP地址一些特性" class="heading-link"><i class="fas fa-link"></i></a>2.4 IP地址一些特性</h2>
      
        <h3 id="路由控制"   >
          <a href="#路由控制" class="heading-link"><i class="fas fa-link"></i></a>路由控制</h3>
      <p>计算机使用一个特殊的 IP 地址 <strong>127.0.0.1 作为环回地址</strong>。与该地址具有相同意义的是一个叫做 localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p>
<p>通过路由器和路由表，首先数据会先传到本地的路由器，其根据传输过来数据报文中的目标ip地址，对比自己的路由表，找到这份数据应该去向何方，并将其传向对应的路由器。</p>

        <h3 id="分片与重组"   >
          <a href="#分片与重组" class="heading-link"><i class="fas fa-link"></i></a>分片与重组</h3>
      <p>那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。</p>
<p>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</p>
<p>在分片传输中，一旦某个分片丢失，则会造成整个 IP 数据报作废，所以 <code>TCP</code> 引入了<code>MSS</code>也就是在 TCP 层进行分片不由 IP 层分片，那么对于 <code>UDP</code> 我们尽量不要发送一个大于 <code>MTU</code> 的数据报文。</p>

        <h3 id="2-5-IPV6-amp-IPV4"   >
          <a href="#2-5-IPV6-amp-IPV4" class="heading-link"><i class="fas fa-link"></i></a>2.5 IPV6 &amp; IPV4</h3>
      <p>IPV6出现的原因：IPV4是<code>32</code>位的，其能够承受的IP地址只有232（约42亿）个IP地址，是远远不能够满足人类的需求的。所以，出现了具有<code>128</code>位的IPV6地址</p>

        <h3 id="IPV6的表示方式"   >
          <a href="#IPV6的表示方式" class="heading-link"><i class="fas fa-link"></i></a>IPV6的表示方式</h3>
      <p>每十六位为一个单位，用<code>:</code>分割开，如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号 「::」隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</p>
<p><img src="/IP.assets/1683945304497-91dcd42c-5f77-4fa1-bd88-da568ac9b76a.png" alt="img"></p>

        <h3 id="IPV6的地址类型"   >
          <a href="#IPV6的地址类型" class="heading-link"><i class="fas fa-link"></i></a>IPV6的地址类型</h3>
      <p><img src="/IP.assets/1683945345679-9ebd314f-7373-4b26-9c12-d90cbff0ae5f.png" alt="img"></p>

        <h3 id="IPV4和IPV6首部的对比差异"   >
          <a href="#IPV4和IPV6首部的对比差异" class="heading-link"><i class="fas fa-link"></i></a>IPV4和IPV6首部的对比差异</h3>
      <p><img src="/IP.assets/1683945391428-3c09b4f0-cb38-4275-ab76-4ff05e647656.png" alt="img"></p>
<p>IPv6 相比 IPv4 的首部改进：</p>
<ul>
<li><strong>取消了首部校验和字段。</strong> 因为在数据链路层和传输层都会校验，因此 IPv6 直接取消了 IP 的校验。</li>
<li><strong>取消了分片&#x2F;重新组装相关字段。</strong> 分片与重组是耗时的过程，IPv6 不允许在中间路由器进行分片与重组，这种操作只能在源与目标主机，这将大大提高了路由器转发的速度。</li>
<li><strong>取消选项字段。</strong> 选项字段不再是标准 IP 首部的一部分了，但它并没有消失，而是可能出现在 IPv6 首部中的「下一个首部」指出的位置上。删除该选项字段使的 IPv6 的首部成为固定长度的 40 字节。</li>
</ul>

        <h1 id="3-IP相关协议技术"   >
          <a href="#3-IP相关协议技术" class="heading-link"><i class="fas fa-link"></i></a>3.IP相关协议技术</h1>
      
        <h2 id="3-1-DNS域名解析"   >
          <a href="#3-1-DNS域名解析" class="heading-link"><i class="fas fa-link"></i></a>3.1 DNS域名解析</h2>
      
        <h3 id="域名之间的层级关系"   >
          <a href="#域名之间的层级关系" class="heading-link"><i class="fas fa-link"></i></a>域名之间的层级关系</h3>
      <p>DNS中的域名是用<code>.</code>进行分割的，越往右边表示层级越高，如<code>www.baidu.com</code>表示一共有三个层级域名</p>
<p>分别为：<code>com</code>, <code>baidu.com</code>, <code>www.baidu.com</code></p>
<ul>
<li>根 DNS 服务器</li>
<li>顶级域 DNS 服务器（com）</li>
<li>权威 DNS 服务器（baidu.com）</li>
</ul>

        <h3 id="域名解析的全过程"   >
          <a href="#域名解析的全过程" class="heading-link"><i class="fas fa-link"></i></a>域名解析的全过程</h3>
      <p>浏览器首先看一下自己的缓存里有没有，如果没有就向操作系统的缓存要，还没有就检查本机域名解析文件 hosts，如果还是没有，就会 DNS 服务器进行查询，查询的过程如下：</p>
<ol>
<li>客户端向本地DNS服务器发送请求，询问目标域名的IP</li>
<li>本地DNS服务器收到客户端的请求后，在自己的缓存中查找，查找得到则直接返回，查找不到则向<strong>根域名服务器</strong>进行询问。</li>
</ol>
<p>根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</p>
<ol>
<li>根域名服务器收到请求后，根据后缀找到<strong>顶级域名服务器地址</strong>，将其发给本地DNS服务器。</li>
<li>本地DNS服务器根据获得的顶级域名服务器地址，对其发送请求，顶级域名服务器地址将域名查询之后，发给客户端对应的<strong>权威DNS服务器</strong>地址。</li>
<li>本地DNS服务器根据获得的权威 DNS 服务器地址，对其发送请求，权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li>
<li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li>
</ol>
<p>总结：本地 DNS与若干DNS服务器的无限问答，以及本地DNS的无数次寻找，最后找到了IP地址。</p>

        <h2 id="3-2-ARP协议和RARP协议"   >
          <a href="#3-2-ARP协议和RARP协议" class="heading-link"><i class="fas fa-link"></i></a>3.2 ARP协议和RARP协议</h2>
      <ul>
<li>ARP：已知IP地址可以求得MAC地址</li>
<li>RARP：已知MAC地址可以求得IP地址</li>
</ul>

        <h3 id="ARP协议如何得知MAC地址"   >
          <a href="#ARP协议如何得知MAC地址" class="heading-link"><i class="fas fa-link"></i></a>ARP协议如何得知MAC地址</h3>
      <ul>
<li>主机会通过<strong>广播发送 ARP 请求</strong>，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 <strong>ARP 响应包</strong>返回给主机。</li>
</ul>
<p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来，以便下次直接从缓存中找到对应 IP 地址的 MAC 地址。</p>

        <h2 id="3-3-DHCP动态获取IP地址"   >
          <a href="#3-3-DHCP动态获取IP地址" class="heading-link"><i class="fas fa-link"></i></a>3.3 DHCP动态获取IP地址</h2>
      <ul>
<li>客户端首先发起 <strong>DHCP 发现报文（DHCP DISCOVER）</strong> 的 IP 数据报，由于客户端没有 IP 地址，也不知道 DHCP 服务器的地址，所以使用的是 UDP <strong>广播</strong>通信，其使用的广播目的地址是 <code>255.255.255.255</code>（端口 67） 并且使用<code>0.0.0.0</code>（端口 68） 作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备。</li>
<li>DHCP 服务器收到 DHCP 发现报文时，用 <strong>DHCP 提供报文（DHCP OFFER）</strong> 向客户端做出响应。该报文仍然使用 IP 广播地址 <code>255.255.255.255</code>，该报文信息携带服务器提供可租约的 IP 地址、子网掩码、默认网关、DNS 服务器以及 <strong>IP 地址租用期</strong>。</li>
<li>客户端收到一个或多个服务器的 DHCP 提供报文后，从中选择一个服务器，并向选中的服务器发送 <strong>DHCP 请求报文（DHCP REQUEST</strong>进行响应，回显配置的参数。</li>
<li>最后，服务端用 <strong>DHCP ACK 报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数。</li>
</ul>
<p>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址。</p>
<p>简化来讲，就是客户端去求职BOSS海投，然后看上这个客户端的服务端就给他发送offer，这个offer告诉他我能给你提供的条件（没错，不用面试），然后客户端选来选去，最后只回了一家，签约成功。之后服务端在发个合同入职须知什么的，结束。这是多少人梦寐以求的状态。</p>
<p>如果租约的 DHCP IP 地址快期后，客户端会向服务器发送 DHCP 请求报文：</p>
<ul>
<li>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期。</li>
<li>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址。</li>
</ul>

        <h2 id="3-4-NAT网络地址转换"   >
          <a href="#3-4-NAT网络地址转换" class="heading-link"><i class="fas fa-link"></i></a>3.4 NAT网络地址转换</h2>
      <p><strong>两个私有 IP 地址都转换 IP 地址为统一的公有地址，但是以不同的端口号作为区分。</strong></p>
<p>生成一个 NAPT 路由器的转换表，就可以正确地转换地址跟端口的组合，令客户端 A、B 能同时与服务器之间进行通信。</p>
<p>这种转换表在 NAT 路由器上自动生成。例如，在 TCP 的情况下，建立 TCP 连接首次握手时的 SYN 包一经发出，就会生成这个表。而后又随着收到关闭连接时发出 FIN 包的确认应答从表中被删除。</p>
<p>缺点：</p>
<ul>
<li>外部无法主动与 NAT 内部服务器建立连接，因为 NAPT 转换表没有转换记录。</li>
<li>转换表的生成与转换操作都会产生性能开销。</li>
<li>通信过程中，如果 NAT 路由器重启了，所有的 TCP 连接都将被重置。</li>
</ul>

        <h2 id="3-5-ICMP互联网控制报文协议"   >
          <a href="#3-5-ICMP互联网控制报文协议" class="heading-link"><i class="fas fa-link"></i></a>3.5 ICMP互联网控制报文协议</h2>
      <p>ICMP 主要的功能包括：<strong>确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</strong></p>
<p><img src="/IP.assets/1683988940425-bd7992c7-d5fa-4512-b9ca-4f8eea22bb34.png" alt="img"></p>
<p>查询报文：回送请求和回送响应是查询报文的两种，主要的作用是用来确定发送的数据包是否到达对端的一种方式</p>
<p>差错报文：相当于我们平时编程语言中的异常</p>
<ul>
<li><p>目标不可达：类似于404，可能是网络不可达，可能是端口不可达，可能是主机不可达等</p>
</li>
<li><ul>
<li>网络不可达代码为 0</li>
<li>主机不可达代码为 1	</li>
<li>协议不可达代码为 2</li>
<li>端口不可达代码为 3</li>
<li>需要进行分片但设置了不分片位代码为 4</li>
</ul>
</li>
<li><p>原点抑制：使用低网速传输的时候可能会出现网络拥堵情况，这时发送一个原点抑制的报文，可以增大 IP 包的传输间隔，减少网络拥堵的情况。</p>
</li>
</ul>

        <h1 id="4-扩展知识"   >
          <a href="#4-扩展知识" class="heading-link"><i class="fas fa-link"></i></a>4.扩展知识</h1>
      
        <h2 id="4-1-ICMP具体工作原理"   >
          <a href="#4-1-ICMP具体工作原理" class="heading-link"><i class="fas fa-link"></i></a>4.1 ICMP具体工作原理</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://xiaolincoding.com/network/4_ip/ping.html#ip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%A9%E6%89%8B-icmp-%E5%8D%8F%E8%AE%AE" >https://xiaolincoding.com/network/4_ip&#x2F;ping.html#ip%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8A%A9%E6%89%8B-icmp-%E5%8D%8F%E8%AE%AE</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>不想写了。。。认认真真的看过了！</p>

        <h2 id="4-2-ping-127-0-0-1"   >
          <a href="#4-2-ping-127-0-0-1" class="heading-link"><i class="fas fa-link"></i></a>4.2 ping 127.0.0.1</h2>
      
        <h3 id="断网了还能ping的通127-0-0-1吗"   >
          <a href="#断网了还能ping的通127-0-0-1吗" class="heading-link"><i class="fas fa-link"></i></a>断网了还能ping的通127.0.0.1吗</h3>
      <p>可以，因为还没走出到网络，客户端发出网络请求会第一步先走到本地路由器，本地路由器如果判断是自己的本地地址就会直接返回，如果不是再去对比自己的路由表。本地路由器是不需要网络的，所以我们发现ping 127.0.0.1不需要联网</p>

        <h2 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"   >
          <a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="heading-link"><i class="fas fa-link"></i></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h2>
      <ul>
<li><code>localhost</code>是一个域名，相当于<code>baidu.com</code>, 其ip地址为127.0.0.1，所以意义上有区别但是实际使用是没什么区别的</li>
<li>0.0.0.0 , 表示本机上的<strong>所有IPV4地址</strong>。是ping不通的</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/11079/">2.LinkList</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-21</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">27分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-链表的基础定义"   >
          <a href="#1-链表的基础定义" class="heading-link"><i class="fas fa-link"></i></a>1. 链表的基础定义</h1>
      
        <h2 id="1-1-主要组成"   >
          <a href="#1-1-主要组成" class="heading-link"><i class="fas fa-link"></i></a>1.1 主要组成</h2>
      <ul>
<li><code>data</code>域： 用于存储每一个节点的<strong>数据</strong></li>
<li><code>next</code>域： 用于存储指向下一个节点的<strong>指针</strong></li>
</ul>

        <h2 id="1-2-特点"   >
          <a href="#1-2-特点" class="heading-link"><i class="fas fa-link"></i></a>1.2 特点</h2>
      <ul>
<li>最后指向null，意味着链表的结束。</li>
<li>可以无限扩容，通过指针指向其他元素可以实现空间的扩大。</li>
<li><mark>存储结构特点</mark>：链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。</li>
<li>相较于数组而言，插入，删除方便，查找不方便（需要一个一个去找）</li>
</ul>

        <h2 id="1-3-图表写法"   >
          <a href="#1-3-图表写法" class="heading-link"><i class="fas fa-link"></i></a>1.3 图表写法</h2>
      <p><img src="/images/LinkListStructure.png"></p>

        <h2 id="1-4-相关类型"   >
          <a href="#1-4-相关类型" class="heading-link"><i class="fas fa-link"></i></a>1.4 相关类型</h2>
      <p>近似的我们可以分为如下几种类型：</p>
<ul>
<li><font size=4><b>单链表</b></font><br>如上图，是一般的数据模型形式。<br><br></li>
<li><font size=4><b>双链表</b></font><br>在单链表的基础上增加了一个<code>next</code>域，即一个节点有两个<code>next</code>域，一个指向前面的节点，一个指向后面的节点。这样能够一定程度上提高查找的效率。<br><img src="/images/doubleLinkList.png"><br></li>
<li><font size=4><b>循环链表</b></font><br>即最后的<code>next</code>指向的是<code>head</code>，实现了链表的循环。可以解决约瑟夫环问题。<br><img src="/images/circleLinkList.png"></li>
</ul>

        <h2 id="1-5-数据结构相关操作"   >
          <a href="#1-5-数据结构相关操作" class="heading-link"><i class="fas fa-link"></i></a>1.5 数据结构相关操作</h2>
      <p>下面是链表有关的数据结构操作：</p>
<ul>
<li><font size=4><b>初始化链表结构</b></font><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Struct LinkNode&#123;</span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 定义data域内容</span></span><br><span class="line">    ListNode *next; <span class="comment">//指向ListNode类型元素的指针</span></span><br><span class="line">    <span class="comment">// 构造函数的初始化</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        <span class="built_in">data</span>(x);</span><br><span class="line">        <span class="built_in">next</span>(null)&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br></li>
<li><font size=4><b>初始化节点</b></font><br><code>ListNode* head = new ListNode(5);</code><br><br><br></li>
<li><font size=4><b>删除节点</b></font></li>
</ul>
<p>链表节点删除的主要思想有两个，第一个是<strong>寻找到要删除的位置</strong>，这个很简单实现，比对要删除的元素和指针指向的元素是否相等，如果不相等就<code>p = p-&gt;next</code>，移动到下个节点即可，难点是理解确定寻址指针指向的位置和删除元素的位置关系。而<mark>寻址指针指向的位置是删除元素的前一格</mark>，这个和后面具体删除的思想有关。</p>
<p>第二个是<strong>删除的过程操作</strong>，其中细化出来有两步，第一步是指向要删除的节点，之后直接<code>delete</code>带走即可，第二步是将原来指向删除节点的<code>next</code>域指针指向删除节点的下一个。综合这两个我们可以发现在删除节点前一个节点要做的事情是可以和其他联系起来的，他的<code>next</code>指向的就是删除的，而他的<code>next</code>我们后续也要进行操作。所以这就回应了第一个寻址思想的难点。<br><br><br><img src="/images/LinkListDel.png"><br><strong>实现代码如下：</strong></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeleteElem</span><span class="params">(link L,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">link p=L,q;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!p||!p-&gt;next)</span><br><span class="line">&#123;cout&lt;&lt;<span class="string">&quot;输出位置不合法&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<br>
- <font size=4><b>增加节点</b></font>

<p>很简单也是两步操作，<strong>第一步是定位</strong>，定位和操作和删除的差不多；<strong>第二步是增加</strong>，那么应该怎么增加呢？我们需要新引入一个指针来进行节点赋值和节点位置的操作，<u>节点赋值</u>很简单，就是<code>s-&gt;data = elem</code>，<u>节点的位置</u>也不难，因为插入元素，即要插入位置的原来节点得给你让出来，你要干他的事情，你的<code>next</code>就要指向原来节点的<code>next</code>即，<code>s-&gt;next = p-&gt;next</code>，那么你要成为他的一部分得连起来，那么原来的<code>next</code>就要指向你的元素，即<code>p-&gt;next = s</code>。<mark>注意这两步的顺序不可以搞反</mark>。<br><br><br><img src="/images/addElem.png"><br><br><br>代码如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AddElem</span><span class="params">(link &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    link p = L, s;</span><br><span class="line"> <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span>(p &amp;&amp; j&lt;i<span class="number">-1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> p = p-&gt;next;</span><br><span class="line"> j++;</span><br><span class="line"> &#125; <span class="comment">//搜索插入的位置</span></span><br><span class="line"> <span class="keyword">if</span>(!p)</span><br><span class="line">	 &#123;cout&lt;&lt;<span class="string">&quot;增加位置不合法&quot;</span>&lt;&lt;endl;</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> s = <span class="keyword">new</span> Node; <span class="comment">//为新节点创建位置</span></span><br><span class="line"> s-&gt;Data = e; <span class="comment">//赋值</span></span><br><span class="line"> s-&gt;next = p-&gt;next;</span><br><span class="line"> p-&gt;next = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<ul>
<li><font size=4><b>寻找data所对应的节点</b></font><br>删除增加的基础，不再赘述。</li>
</ul>
<hr>

        <h1 id="2-链表设计"   >
          <a href="#2-链表设计" class="heading-link"><i class="fas fa-link"></i></a>2. 链表设计</h1>
      
        <h2 id="相关题目"   >
          <a href="#相关题目" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-linked-list-elements/" >Problem 203. 移除链表元素</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/design-linked-list/" >Problem 707. 设计链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<blockquote>
<p>很好的数据结构方式，也是数据结构这门课中第一次学到的关于指针类型的数据结构，有一定的难度，又是我们的启蒙，是一门十分值得敬畏的章节。加油吧。不管前路怎么艰辛，这总是你的第一站，第一站总是会变的比较有难度一些的，那么你就一定要坚持下去，同时照顾好自己的身体，资本要有，但挥霍资本的资本也要有。</p>
</blockquote>

        <h2 id="2-1-复杂度"   >
          <a href="#2-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>2.1 复杂度</h2>
      <p>大部分是<code>O(n)</code></p>

        <h2 id="2-2-主要思想"   >
          <a href="#2-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>2.2 主要思想</h2>
      <p>这里学到了一个比较重要的东西叫做虚拟头节点，他存在的意义是为了让处理头结点的时候和处理其他节点一样的自然。因为链表这种数据结构本身具有一定的局限性，其头节点无法用next指向，所以设置一个虚拟头节点，可以让头节点获得和其他节点一样的待遇。</p>

        <h2 id="2-3-注意点"   >
          <a href="#2-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>2.3 注意点</h2>
      <ul>
<li>注意什么时候需要定位到要操作节点的前一个节点，什么时候要确定的定位到那个要操作的节点。要操作节点的前一个节点主要用于添加和删除这两个操作，因为他们都需要用到前一个节点的next指针，来指向下一个节点方能对他们进行操作。而确定的定位到要操作的节点则是根据index取值的操作。</li>
<li>需要警惕提防节点们，因为节点们在你每次更改next域之后，他们之间的关系就进行了一次大洗牌，所以在新增和删除节点的时候一定要按步骤操作好。</li>
<li>有索引就有越界问题，一定看看要搜索定位的索引是否越界或者不存在。</li>
<li>用好<code>while(index--)</code>的写法，他其实和<code>for(int i = 0; i++; i &lt; index)</code>是一样的，但是他的优点就是能加上一些<code>&amp;&amp;</code>，从而可以做出一些防止越界的举动。</li>
<li>记得在操作的时候时刻不要拿着最原始的head变量去操作，因为要返回head的时候能够帮你直接定位，而用一些替代值去进行操作就好了。</li>
</ul>

        <h2 id="2-4-代码实现"   >
          <a href="#2-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>2.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    LinkNode* next;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="type">int</span> val): <span class="built_in">val</span>(val), <span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">//长度</span></span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(<span class="number">0</span>); <span class="comment">//虚拟头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//有下标需要考虑越界问题</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(index --) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        cur -&gt; next = dummyHead -&gt; next;</span><br><span class="line">        dummyHead -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        <span class="comment">//把尾节点给找出来</span></span><br><span class="line">        <span class="keyword">while</span>(p -&gt; next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 小于零则在头部插入节点</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 越界则无效</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = dummyHead;</span><br><span class="line">        LinkNode* cur = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">while</span>(index--)&#123;</span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        p -&gt; next = cur;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//判断索引是否越界</span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = cur -&gt; next;</span><br><span class="line">        cur -&gt; next = p -&gt; next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//虚拟头节点的建立</span></span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">		<span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(cur-&gt;next-&gt;val == val)&#123;</span><br><span class="line">    			ListNode* tmp = cur-&gt;next;</span><br><span class="line">        		cur-&gt;next = cur -&gt;next-&gt;next;</span><br><span class="line">        		<span class="keyword">delete</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">        		cur = cur -&gt; next;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">		head = dummyHead-&gt;next;</span><br><span class="line">		<span class="keyword">delete</span> dummyHead;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        LinkNode* dummyHead;</span><br><span class="line">        <span class="type">int</span> size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="3-链表翻转"   >
          <a href="#3-链表翻转" class="heading-link"><i class="fas fa-link"></i></a>3. 链表翻转</h1>
      
        <h2 id="相关题目-1"   >
          <a href="#相关题目-1" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 206 链表翻转</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="3-2-复杂度"   >
          <a href="#3-2-复杂度" class="heading-link"><i class="fas fa-link"></i></a>3.2 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="3-3-主要思想"   >
          <a href="#3-3-主要思想" class="heading-link"><i class="fas fa-link"></i></a>3.3 主要思想</h2>
      <p>只要实现链表的转向即可，那么就需要有一前一后两个节点，来实现转向的操作，于是链表的转向就可以实现了。 其实这里又是双指针的另一个应用场景，双指针只要涉及到需要对两个东西同时进行操作，他都能够派上用场。</p>

        <h2 id="3-4-注意点"   >
          <a href="#3-4-注意点" class="heading-link"><i class="fas fa-link"></i></a>3.4 注意点</h2>
      <p>我感觉这道题没有什么要注意的东西，就算要有吧，也就是要注意转移到下一个节点进行翻转的时候，定位要不能定next了，因为操作过后已经转移了，所以要在翻转前就给<code>cur-&gt;next</code>给标记上temp。</p>

        <h2 id="3-5-代码实现"   >
          <a href="#3-5-代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.5 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* temp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(); <span class="comment">//临时节点，用来存储要操作的下一个节点的</span></span><br><span class="line">        ListNode* pre = <span class="literal">NULL</span>; <span class="comment">//指向头节点的前一个节点</span></span><br><span class="line">        ListNode* cur = head; <span class="comment">//指向头节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            temp = cur-&gt;next; <span class="comment">//标记</span></span><br><span class="line">            cur-&gt;next = pre;  <span class="comment">//翻转</span></span><br><span class="line">            pre = cur; <span class="comment">//下一组</span></span><br><span class="line">            cur = temp; <span class="comment">//下一组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="4-两两交换链表中的节点"   >
          <a href="#4-两两交换链表中的节点" class="heading-link"><i class="fas fa-link"></i></a>4. 两两交换链表中的节点</h1>
      
        <h2 id="相关题目-2"   >
          <a href="#相关题目-2" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/reverse-linked-list/" >Problem 24 两两交换链表中的节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="4-1-复杂度"   >
          <a href="#4-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>4.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="4-2-主要思想"   >
          <a href="#4-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>4.2 主要思想</h2>
      <p>要关注好移动的顺序，这道题是很好的让人们能够关注流程顺序的一道题目。<br><img src="/images/LinkListturn.png"></p>

        <h2 id="4-3-注意点"   >
          <a href="#4-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>4.3 注意点</h2>
      <p>关注好移动的顺序</p>

        <h2 id="4-4-代码实现"   >
          <a href="#4-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>4.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        p-&gt;next = head;</span><br><span class="line">        ListNode* cur = p;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        ListNode* temp = cur-&gt;next; <span class="comment">//临时节点1</span></span><br><span class="line">        ListNode* temp1 = cur-&gt;next-&gt;next-&gt;next; <span class="comment">//临时节点2</span></span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next; <span class="comment">//第一步操作，头节点-&gt;第二个</span></span><br><span class="line">        cur-&gt;next-&gt;next = temp; <span class="comment">//第二步操作，第二个-&gt;第一个</span></span><br><span class="line">        cur-&gt;next-&gt;next-&gt;next = temp1; <span class="comment">//第三步操作，第一个-&gt;第三个</span></span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="5-删除列表的倒数第n个节点"   >
          <a href="#5-删除列表的倒数第n个节点" class="heading-link"><i class="fas fa-link"></i></a>5. 删除列表的倒数第n个节点</h1>
      
        <h2 id="相关题目-3"   >
          <a href="#相关题目-3" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/" >Problem 19. 删除列表的倒数第n个节点</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="5-1-复杂度"   >
          <a href="#5-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>5.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="5-2-主要思想"   >
          <a href="#5-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>5.2 主要思想</h2>
      <p>还是双指针，删除这种东西好像最好双指针了，一个用来指代他的条件，另一个指针来指向要删除的值，具体而言在这道题上就是慢指针是用来指代值的，快指针的条件判断在于，倒数第几个就移动几次，终止条件本来从虚拟头节点出发到nullptr就遍历完了，那么我们删除倒数第几个就派出另一个往前先走几步就行了，那么先出发的那个到达nullptr的时候就是真正删除的那一个到达要删除的时候。 </p>

        <h2 id="5-3-注意点"   >
          <a href="#5-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>5.3 注意点</h2>
      <p>就是我们的前进的时候用while循环，其实<code>for(int i=0; i++; i&lt;n)</code>和<code>while(n--)</code>是等价的，但是要考虑他是否越界，所以要添加上<code>fast != null</code>就用while好像更好一点了。</p>

        <h2 id="5-4-代码实现"   >
          <a href="#5-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>5.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyList = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        dummyList-&gt;next = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = dummyList;</span><br><span class="line">		<span class="comment">//很好的判断条件，防止倒数第n个本来就是不存在的情况</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 一起前进</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">return</span> dummyList-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>


        <h1 id="6-链表相交"   >
          <a href="#6-链表相交" class="heading-link"><i class="fas fa-link"></i></a>6. 链表相交</h1>
      
        <h2 id="相关题目-4"   >
          <a href="#相关题目-4" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/" >Problem 链表相交</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="6-1-复杂度"   >
          <a href="#6-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>6.1 复杂度</h2>
      <p>时间复杂度：<code>O(n + m)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="6-2-主要思想"   >
          <a href="#6-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>6.2 主要思想</h2>
      <p>这道题告诉你之后难度不大，就是看看两个链表的部分是否相等就行了，怎么看呢，一个个移动，直到空为止，很容易知道应该是以最短的那个链表作为基准，因为最短的链表遍历完之后所有有可能的结果也就尘埃落定了。所以我们要做的第一步就是比对两个数组找出长度差值，之后才能够精准的进行定位。</p>

        <h2 id="6-3-注意点"   >
          <a href="#6-3-注意点" class="heading-link"><i class="fas fa-link"></i></a>6.3 注意点</h2>
      <p>计算完长度之后，临时指针要重定向归于原来的头节点，不然他们计算完长度之后的状态是指向nullptr的</p>

        <h2 id="6-4-代码实现"   >
          <a href="#6-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>6.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur1 = headA;</span><br><span class="line">        ListNode* cur2 = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//计算长度</span></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur1 = headA;</span><br><span class="line">        cur2 = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lenA &lt; lenB)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span>(cur1, cur2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">			<span class="comment">//移动到同一起跑线</span></span><br><span class="line">        <span class="keyword">while</span>(gap--)&#123;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur1 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur1 == cur2)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur1;</span><br><span class="line">            &#125;</span><br><span class="line">            cur1 = cur1-&gt;next;</span><br><span class="line">            cur2 = cur2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

        <h1 id="7-环形链表"   >
          <a href="#7-环形链表" class="heading-link"><i class="fas fa-link"></i></a>7. 环形链表</h1>
      
        <h2 id="相关题目-5"   >
          <a href="#相关题目-5" class="heading-link"><i class="fas fa-link"></i></a>相关题目</h2>
      <p><span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/" >Problem 142. 环形链表</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="7-1-复杂度"   >
          <a href="#7-1-复杂度" class="heading-link"><i class="fas fa-link"></i></a>7.1 复杂度</h2>
      <p>时间复杂度：<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>

        <h2 id="7-2-主要思想"   >
          <a href="#7-2-主要思想" class="heading-link"><i class="fas fa-link"></i></a>7.2 主要思想</h2>
      <p>这道题由两个部分组成，第一个部分是有没有环，第二个部分是环的入口到底在哪？ 首先有没有环的判断就是依据两个指针一快一慢的走，如果相遇了就能证明有环，但是这是一个必要证明，还得加上一个条件就是快指针走两步慢指针走一步，本质上就是一个追赶问题，<strong>快指针每次相对于慢指针多走了一步，那么就是链表中每一个格子都有能够遇上的机会。</strong>所以此时遇上和有环形成了一个充分必要的对应证明条件。 那么入口在哪呢，假设入口离起始点的距离为x，第一次相遇两指针在距离入口y处，环的长度为y+z，那么我们可以推断出，慢指针走了x+y距离，快指针走了x+n(y+z)。那么他们相遇的话，即x+y &#x3D; x+n(y+z)，我们要探究x是多少，即可以把等式变化为：x &#x3D; (n-1)(y+z)+z，那么因为 y+z表示一直在绕圈可以忽略掉 ，所以我们可以得出一个结论叫做，起点到入环点的位置和相遇点到入环点的位置是相等的。</p>
<blockquote>
<p>这里x一定没有绕环的论证在慢指针走一圈的时间快指针能走两圈，而快指针相对于慢指针每次走一步，也就是说快指针速度为2v，慢指针速度为v，快指针追上慢指针需要走的路程为y+z-a(不足一圈)，追上的时间为(y+z-a)&#x2F;(2v-v),慢指针走一圈的时间为(y+z)&#x2F;v，追上的时间小于慢指针走一圈的时间，所以一定能够追得上。</p>
</blockquote>

        <h2 id="7-4-代码实现"   >
          <a href="#7-4-代码实现" class="heading-link"><i class="fas fa-link"></i></a>7.4 代码实现</h2>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/56432/">TCP</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">8.9k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">49分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-TCP的基本认识"   >
          <a href="#1-TCP的基本认识" class="heading-link"><i class="fas fa-link"></i></a>1. TCP的基本认识</h1>
      
        <h2 id="1-1-头部格式"   >
          <a href="#1-1-头部格式" class="heading-link"><i class="fas fa-link"></i></a>1.1 头部格式</h2>
      <p><img src="/TCP.assets/1681538502204-6f61e70a-3a10-427e-8f2f-45b7d3612fca.png" alt="img"></p>
<ul>
<li><p>源端口号&#x2F;目标端口号：分别表示发送方和接收方</p>
</li>
<li><p>序列号：用来保证<strong>传输的可靠性</strong>，原数据是随机生成的随机数，之后服务端和客户端每交互一次就叠加一次。用来<strong>解决网络收发包的乱序问题</strong>。</p>
</li>
<li><p>确认应答号：下一次收到数据期望的序列号，可以认为此前的序列号都传输成功，用来<strong>解决网络丢包问题</strong>。</p>
</li>
<li><p>首部：表示TCP报文头部长度，按比例缩小进行存储。</p>
</li>
<li><p>控制位：</p>
</li>
<li><ul>
<li>URG(Urgent，紧急标志)：表示包中有需要紧急处理的数据，优先处理。</li>
<li>ACK(Acknowledgment，确认标志)：表示确认数据包已经收到。</li>
<li>PSH(Push，推送标志)：PSH为1，立即发送数据。PSH为0，先进行缓存。</li>
<li>RST(Reset，重置标志)：RST标志用于中止连接，用于解决网络连接问题。</li>
<li>SYN(Synchronization，同步标志)：这个位标志用于发起一个连接，建立连接并设置初始序列号。</li>
<li>FIN(Finish，完成标志)：表示终止TCP连接，用于数据传输完毕，此段连接不会再有数据往来。</li>
</ul>
</li>
<li><p>窗口大小：用于<strong>流量控制</strong>，分别表表明自己能够接受的流量大小。</p>
</li>
<li><p>校验和：确保数据传输没有被篡改，重新通过某种算法计算后得到的数。</p>
</li>
<li><p>紧急指针：当URG标志位为1的时候才存在该字段，表示该部分数据为紧急数据。</p>
</li>
<li><p>选项：用于优化TCP传输性能，对TCP功能做出解释，也是TCP总长度可变的原因。</p>
</li>
</ul>
<p>有的文章保留字段为4比特，标志位为8比特，有的文章保留字段为6比特，标志位为6比特。</p>

        <h2 id="1-2-TCP的意义和作用"   >
          <a href="#1-2-TCP的意义和作用" class="heading-link"><i class="fas fa-link"></i></a>1.2 TCP的意义和作用</h2>
      <p>TCP的<strong>面向连接</strong>的，<strong>可靠</strong>的，<strong>基于字节流</strong>的传输。</p>
<p>ip层是不可靠的，其只负责将数据传输到对应的主机，保证数据在网络传输之间不丢失，但是能够<strong>按序到达</strong>，<strong>数据内容的完整</strong>无法保证。所以tcp层的出现正是为了保证数据的安全性。</p>
<ol>
<li>面向连接：只有建立起来连接，才能进行数据的传输。即只有一对一的连接。保证了数据之间传输的<strong>安全</strong>。</li>
<li>可靠性：更加偏向于一个目的的描述，保证数据包发送之后能<strong>可靠的</strong>到达目的地。</li>
<li>基于字节流：应用程序对数据的发送和接收是<strong>没有边界限制</strong>的，为了保证其<strong>有序性</strong>，同时也可以针对其特性建立<strong>缓存区</strong>，将传输的若干数量包拼装完成后再接收。</li>
</ol>
<p>RFC 793定义的连接：</p>
<p><em>Connections: The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including</em> <em>sockets</em><em>,</em> <em>sequence numbers</em><em>, and</em> <em>window sizes</em><em>, is called a connection.</em></p>
<p>从中我们可以看出一个TCP连接中主要包含着三个关键信息：</p>
<ul>
<li>sockets：由ip地址和端口号组成，用于确认地址信息</li>
<li>sequence numbers：随机序列号，用来确保传输的有序和安全</li>
<li>window sizes：窗口大小，用来进行流量控制</li>
</ul>

        <h2 id="1-3-如何确定一个TCP连接"   >
          <a href="#1-3-如何确定一个TCP连接" class="heading-link"><i class="fas fa-link"></i></a>1.3 如何确定一个TCP连接</h2>
      <p><strong>TCP四元组</strong>可以确定一个唯一的TCP连接：</p>
<ul>
<li>源地址</li>
<li>源端口</li>
<li>目的地址</li>
<li>目的端口</li>
</ul>
<p>求一个端口能够监听的最大TCP连接数</p>
<p>最大TCP连接数 &#x3D; 客户端IP地址数量 * 客户端端口数量</p>

        <h2 id="1-4-TCP和UDP的区别"   >
          <a href="#1-4-TCP和UDP的区别" class="heading-link"><i class="fas fa-link"></i></a>1.4 TCP和UDP的区别</h2>
      <p><img src="/TCP.assets/1681540761397-b5876402-e4f2-48d1-9544-454d31f61eab.png" alt="img"></p>
<p>这里要注意包长度指的是整个UDP的长度，包含数据。校验和为了防止收到损坏的数据包。</p>
<ol>
<li><strong>连接</strong></li>
</ol>
<ul>
<li>TCP是面向连接的协议，他需要经过确定连接之后才可以进行数据的传输。</li>
<li>UDP是无连接协议，数据即刻传输</li>
</ul>
<ol>
<li><strong>服务对象</strong></li>
</ol>
<ul>
<li>TCP只支持一对一的服务，这是他面向连接的特点决定的</li>
<li>UDP支持一对一，一对多，多对多的数据传输</li>
</ul>
<ol>
<li><strong>可靠性</strong></li>
</ol>
<ul>
<li>TCP的可靠性较高，数据丢包和被篡改的风险较低下</li>
<li>UDP的可靠性较低，但其也有其改进版本增强其可靠性，如QUIC协议。</li>
</ul>
<ol>
<li><strong>拥塞控制</strong></li>
</ol>
<ul>
<li>TCP通过头部的窗口大小字段告诉传输方自己最大承受数据的能力，是有限制的。</li>
<li>UDP则因为其无连接特性，数据包可以在网络连接中停留拥塞，故可无后顾之忧的发送</li>
</ul>
<ol>
<li><strong>头部开销</strong></li>
</ol>
<ul>
<li>TCP的头部长度为20个字节加上选项</li>
<li>UDP的头部长度为8个字节，且固定</li>
</ul>
<ol>
<li><strong>传输方式</strong></li>
</ol>
<ul>
<li>TCP采用流式传输方式，保证有序及可靠</li>
<li>UDP采用数据包传输方式，是有边界的，可能会导致传输的乱序问题。</li>
</ul>
<ol>
<li><strong>分片方式</strong></li>
</ol>
<ul>
<li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li>
<li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li>
</ul>
<ol>
<li><strong>应用场景</strong></li>
</ol>
<p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li>FTP 文件传输；</li>
<li>HTTP &#x2F; HTTPS；</li>
</ul>
<p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、SNMP 等；</li>
<li>视频、音频等多媒体通信；</li>
<li>广播通信；</li>
</ul>

        <h2 id="1-5-TCP和UDP可共用一个端口号吗"   >
          <a href="#1-5-TCP和UDP可共用一个端口号吗" class="heading-link"><i class="fas fa-link"></i></a>1.5 TCP和UDP可共用一个端口号吗</h2>
      <p><strong>可以的。</strong></p>
<p>传输层端口号的作用是：用于区分同一台主机上不同应用程序的数据包</p>
<p>UDP和TCP是传输层的两个完全不一样的传输协议。</p>
<p>主机接收到数据包之后，首先会根据头部的格式判断出到底是UDP协议还是TCP协议，再交由相应的软件板块进行传输。</p>

        <h1 id="2-TCP的连接确立"   >
          <a href="#2-TCP的连接确立" class="heading-link"><i class="fas fa-link"></i></a>2. TCP的连接确立</h1>
      <p>三次握手是TCP连接最最最重要，也是最最最基础的点。但是也要记住，这个过程是数据传输的<strong>准备</strong>工作，其目的只是为客户端和服务端<strong>建立起连接</strong>，确保其能无误收发数据。</p>

        <h2 id="2-1-三次握手总流程图"   >
          <a href="#2-1-三次握手总流程图" class="heading-link"><i class="fas fa-link"></i></a>2.1 三次握手总流程图</h2>
      <p><img src="/TCP.assets/1681572757056-f103cb9c-7088-416a-9d9e-b141b084b6c2.png" alt="img"></p>
<ul>
<li><strong>第一次握手：</strong></li>
</ul>
<p>服务端没有收到请求的时候，处于<code>listen</code>状态，同时的，<strong>客户端发起请求</strong>，发送标志位为1的<code>syn</code>和<code>client_isn</code>，表示请求连接，客户端自身进入<code>syn_send</code>状态。</p>
<ul>
<li><strong>第二次握手：</strong></li>
</ul>
<p>本次由<strong>服务端首先发起请求</strong>，其发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。至此，<strong>服务端告诉客户端自己能够收到他的信息</strong>。之后，发送标志位为1的<code>syn</code>和<code>service_isn</code>，<strong>用于确认客户端能否收到自己的信息</strong>，同时自身进入<code>syn_revd</code>状态。</p>
<ul>
<li><strong>第三次握手：</strong></li>
</ul>
<p>本次握手由客户端发送，表示自己收到了服务端的请求并告知，发送了标志位为1的<code>ack</code>状态码，表示对上次请求同意的回复，同时回复的递增1的序列号。其后，进入<code>Established</code>状态，表示准备就绪，可以进行数据传输，服务端收到客户端发送的Ack，也同时进入<code>Established</code>状态，至此，三次握手完成。</p>

        <h2 id="2-2-握手的数量为3的原因"   >
          <a href="#2-2-握手的数量为3的原因" class="heading-link"><i class="fas fa-link"></i></a>2.2 握手的数量为3的原因</h2>
      <p><em>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</em></p>
<p>可以看到，三次握手的主要原因是为了<strong>防止旧的连接重复初始化导致连接混乱。</strong></p>
<p>通过头部中的序列号和确认应答号可以校验连接双方是否昔日故人，如果是再进行数据传输。少掉任意一次连接，都会造成客户端或者服务端无法对对方身份的确认。这三次连接实质上是不可或缺的<strong>两问两答</strong>。</p>
<p>而连接混乱造成的后果则是<strong>资源的浪费</strong>。用旧的无意义的连接传输资源，最后得到的也是无法使用的资源。</p>

        <h2 id="2-3-初始序列号ISN意义及如何生成"   >
          <a href="#2-3-初始序列号ISN意义及如何生成" class="heading-link"><i class="fas fa-link"></i></a>2.3 初始序列号ISN意义及如何生成</h2>
      <p>起始 ISN 是基于时钟的，每 4 微秒 + 1，转一圈要 4.55 个小时。</p>
<p>RFC793 提到初始化序列号 ISN 随机生成算法：<code>ISN = M + F(localhost, localport, remotehost, remoteport)</code>。</p>
<ul>
<li>M 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li>F 是一个 Hash 算法，根据<strong>源 IP、目的 IP、源端口、目的端口</strong>生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</li>
</ul>
<p>可以看到，随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号。</p>
<ul>
<li>意义：防止旧的报文被新的连接接收</li>
</ul>

        <h2 id="2-4-握手报文丢失，双方怎么办"   >
          <a href="#2-4-握手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>2.4 握手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h2 id="2-5-SYN攻击是什么，如何防范"   >
          <a href="#2-5-SYN攻击是什么，如何防范" class="heading-link"><i class="fas fa-link"></i></a>2.5 SYN攻击是什么，如何防范</h2>
      <p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列，对应着三次握手中的<code>syn_revd</code>状态；</li>
<li>全连接队列，也称 accept 队列，对应着三次握手中的<code>Established</code>状态；</li>
</ul>
<p>SYN攻击指的是对于服务器的SYN队列进行<code>ddos</code>攻击，<strong>发送大量的请求</strong>，这时候服务端会产生大量的<code>ACK+SYN</code>加以应答，但是因为客户端是不存在的，所以服务器始终等不到客户端发送过来的<code>ACK</code>，<strong>该批请求也就无法由SYN队列进入到accept队列</strong>，随着SYN队列被占满，服务器再也无法接受请求。</p>
<p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 netdev_max_backlog；</li>
<li>增大 TCP 半连接队列；</li>
<li>开启 tcp_syncookies；</li>
<li>减少 SYN+ACK 重传次数</li>
</ul>

        <h1 id="3-TCP断开连接"   >
          <a href="#3-TCP断开连接" class="heading-link"><i class="fas fa-link"></i></a>3. TCP断开连接</h1>
      
        <h2 id="3-1-四次挥手总流程图"   >
          <a href="#3-1-四次挥手总流程图" class="heading-link"><i class="fas fa-link"></i></a>3.1 四次挥手总流程图</h2>
      <p><img src="/TCP.assets/1681634375484-9d1277eb-3ab7-48fe-aa30-9ae16305b331.png" alt="img"></p>
<ul>
<li>首先，客户端服务端双方起始都是可以传输数据的<code>Established</code>状态，正式进入四次挥手断开连接</li>
<li><em><strong>第一次挥手：</strong></em>客户端发送带有<code>FIN</code>标志位的报文，<strong>表示想终止这次连接</strong>，之后进入<code>FIN_WAIT1</code>阶段。</li>
<li>*<strong>第二次挥手：*<strong>服务端收到客户端发送的<code>FIN</code>报文，发送带有<code>ACK</code>头部的确认报文给客户端，表示自己已经收到。随后进入<code>Closed_Wait</code>阶段，</strong>表示等待连接的关闭</strong>，客户端接收到<code>ACK</code>确认报文后进入<code>FIN_WAIT2</code>阶段</li>
<li><em><strong>第三次挥手：</strong></em>服务端将自己想要发送给客户端的信息处理完之后发送<code>FIN</code>报文，表示<strong>服务端已没有信息需要发送给客户端</strong>。随后进入<code>Last_Ack</code>阶段，表示等待客户端的最后一次回应。</li>
<li>*<strong>第四次挥手：*<strong>客户端接受到服务端的<code>FIN</code>报文后，发送<code>ACK</code>确认报文给服务端。之后</strong>进入为期</strong><code>**2MSL**</code><strong>的</strong><code>**TIME_WAIT**</code><strong>阶段</strong>，之后断开连接。服务端收到应答之后断开连接。</li>
</ul>
<p>只有在主动发起断开连接的一方才会有<code>time_wait</code>阶段</p>

        <h2 id="3-2-服务端的SYN和ACK可否合并"   >
          <a href="#3-2-服务端的SYN和ACK可否合并" class="heading-link"><i class="fas fa-link"></i></a>3.2 服务端的SYN和ACK可否合并</h2>
      <p>在四次挥手的过程中，服务端在两个报文中间有一段<code>closed_wait</code>的阶段，那么该阶段可否跳过省略呢</p>

        <h3 id="为什么会有closed-wait的阶段"   >
          <a href="#为什么会有closed-wait的阶段" class="heading-link"><i class="fas fa-link"></i></a>为什么会有closed_wait的阶段</h3>
      <p>首先我们要知道服务端在<code>closed_wait</code>这段时间内做了什么，他主要的作用就是来处理数据，检查是否还有没发送给客户端的数据，如果有，就发送给客户端。<code>FIN</code>标志位的意思是所有数据发送完毕，想要断开请求，所以必须检查数据是否完毕。</p>
<p>他主要实现的原理是在收到客户端发送的<code>FIN</code>报文之后，将一个结束标识符<code>EOF</code>放在待处理数据的末尾，由于TCP的流传输特性，所以之后当服务端将所有数据处理完，才会读取到<code>EOF</code>，读取到<code>EOF</code>之后，才会向服务端发送<code>FIN</code>报文。</p>

        <h3 id="三次连接是否可以实现？"   >
          <a href="#三次连接是否可以实现？" class="heading-link"><i class="fas fa-link"></i></a>三次连接是否可以实现？</h3>
      <p>可以实现，条件是需要<strong>开启TCP延时确认机制</strong>并且服务端<strong>没有数据要发送</strong>。</p>

        <h3 id="TCP延时确认机制"   >
          <a href="#TCP延时确认机制" class="heading-link"><i class="fas fa-link"></i></a>TCP延时确认机制</h3>
      <p>服务端当收到客户端发送过来的<code>FIN</code>信息之后，需要回复<code>ACK</code>报文，如果只单单传输一个20字节的报文头部不携带任何报文信息，而后续需要发送的报文又独立发送，就会造成网络资源的浪费（因为内容和头部是始终需要携带的）。那么为了<strong>提高网络资源的利用效率</strong>，TCP延时确认机制产生，它主要做了下面三件事：</p>
<ul>
<li>当有响应数据需要发送时，数据会随着<code>ACK</code>头部一起发送。</li>
<li>当没有响应数据需要发送时候，服务端会等待一段时间，已确定有没有数据需要发送进而一起发送。</li>
<li>当在等待响应数据时，若又有一个请求发送过来，那么<code>ACK</code>头就会立刻发送。</li>
</ul>
<p>延迟等待时间由<code>TCP_DELACK_MIN</code>和<code>TCP_DELACK_MAX</code>决定。linux内核中默认为：</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP_DELACK_MIN = HZ/5</span><br><span class="line">TCP_DELACK_MIN = HZ/25</span><br></pre></td></tr></table></div></figure>

<p>HZ与系统的时钟周期频率相关。</p>
<p><img src="/TCP.assets/1681637532127-2e7b6ac6-f1c3-408d-804b-f4f93b4b1be3.png" alt="img"></p>
<p>TCP延时确认机制是默认开启的</p>

        <h3 id="三次连接实现原理"   >
          <a href="#三次连接实现原理" class="heading-link"><i class="fas fa-link"></i></a>三次连接实现原理</h3>
      <p>当没有数据要发送的时候，那么服务端可以直接读取到<code>EOF</code>，准备发送带有<code>FIN</code>的报文，但是因为延时确认机制，原先的<code>ACK</code>报文还没有发送，那么就将<code>FIN</code>一起写到<code>ACK</code>中，之后，<strong>等待一段时间或者知道客户端再次发送请求</strong>（分别对应了其2，3情况），那么这个没有数据但是含有<code>ACK</code>和<code>FIN</code>头部信息的报文就直接发送了。</p>

        <h2 id="3-3-挥手报文丢失，双方怎么办"   >
          <a href="#3-3-挥手报文丢失，双方怎么办" class="heading-link"><i class="fas fa-link"></i></a>3.3 挥手报文丢失，双方怎么办</h2>
      <p>总而言之，简单来讲，<strong>超时重传</strong>，超过了一定的时间还收不到回应，那么则断开连接。</p>
<p>注意，重新发送的只有SYN，<strong>ACK不会重新发送</strong>。</p>
<p>等待时间逐倍的递增。</p>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code>内核参数决定，默认值是 5。</p>

        <h3 id="close和shutdown方法的比较"   >
          <a href="#close和shutdown方法的比较" class="heading-link"><i class="fas fa-link"></i></a>close和shutdown方法的比较</h3>
      <p>两者都是用于对进程的关闭，但是shutdown关闭的是该进程的发送信息功能，而接受信息功能仍然存在，close则是两个功能都将其关闭。</p>

        <h3 id="在第二次挥手中，客户端shutdown了"   >
          <a href="#在第二次挥手中，客户端shutdown了" class="heading-link"><i class="fas fa-link"></i></a>在第二次挥手中，客户端shutdown了</h3>
      <p>这是一个十分有趣的情况，第二次挥手是由服务端对于客户端的<code>FIN</code>标志的回应，发送了<code>ACK</code>确认标志，如果服务端始终不发送过来第三次挥手，正常情况下客户端是需要重发<code>FIN</code>请求的，但是因为此时客户端的<code>shutdown</code>，使得其无法发送，那么最后造就的结果便是客户端一直在<code>FIN_WAIT2</code>这个阶段卡住，无法关闭。服务端重发请求到达上限时间次数便会自己断开连接。</p>

        <h2 id="3-4-TIME-WAIT状态"   >
          <a href="#3-4-TIME-WAIT状态" class="heading-link"><i class="fas fa-link"></i></a>3.4 TIME_WAIT状态</h2>
      
        <h3 id="TIME-WAIT状态的时间是多少"   >
          <a href="#TIME-WAIT状态的时间是多少" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态的时间是多少</h3>
      <p>2MSL（Maximum Segment Lifetime，报文最大生存时间）。非常巧合的是，我们发现，这个时间便是一次<strong>客户端和服务端之间交互一来一回</strong>的时间。</p>

        <h3 id="TIME-WAIT状态存在的原因"   >
          <a href="#TIME-WAIT状态存在的原因" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态存在的原因</h3>
      <ul>
<li><em>确保新的相同的四元组TCP连接不要接收到旧的报文信息。</em></li>
</ul>
<p>主要是<strong>为了避免第四次挥手的丢失，</strong>客户端发送完成第四次挥手<code>ACK</code>之后就断开连接，那么万一服务端没有收到<code>ACK</code>确认，又重发了一次<code>FIN</code>，此时客户端无法收到他的请求。此时恰好又有一个相同的四元组TCP连接建立了起来，这时候旧的<code>FIN</code>或者数据就会发送到新的连接。会客户端收到错误的信息或者造成新的连接无法将其信息发送完整就断开连接。</p>
<ul>
<li><em>保证被动关闭的一方能够</em>***正常关闭***<em>。</em></li>
</ul>
<p>还是基于第四次挥手的丢失，服务端重新发送<code>FIN</code>报文之后，因为客户端已经关闭，所以无法收到他的<code>ACK</code>报文，那么最后关闭只能是因为超时被动断开连接了。这样既浪费了服务器资源，又对于服务器是有危害的。</p>

        <h3 id="TIME-WAIT状态过多的危害"   >
          <a href="#TIME-WAIT状态过多的危害" class="heading-link"><i class="fas fa-link"></i></a>TIME_WAIT状态过多的危害</h3>
      <p>TIME_WAIT状态其实是一种阻塞的表现，等待至少2MSL的时间，而这个时间对<strong>端口号</strong>来说是占用的。如果网络不通畅，那么端口号资源就被占用的极多，就会无法对于服务端建立连接了。会占用<strong>系统资源</strong>，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>

        <h3 id="如何优化-TIME-WAIT？"   >
          <a href="#如何优化-TIME-WAIT？" class="heading-link"><i class="fas fa-link"></i></a>如何优化 TIME_WAIT？</h3>
      <ul>
<li>打开 net.ipv4.tcp_tw_reuse 和 net.ipv4.tcp_timestamps 选项；</li>
<li>net.ipv4.tcp_max_tw_buckets</li>
<li>程序中使用 SO_LINGER ，应用强制使用 RST 关闭。</li>
</ul>
<p>第一二种方法主要是通过控制<code>TIME_WAIT</code>的时间加以控制，第三种方法则是直接跨过了<code>TIME_WAIT</code>。都存在着一定上诉提到的风险。</p>

        <h3 id="long-alive-长连接状态"   >
          <a href="#long-alive-长连接状态" class="heading-link"><i class="fas fa-link"></i></a>long-alive 长连接状态</h3>
      <p>这个状态我们可以在请求报文的头部信息中看到，开启状态表示一次请求交互完成之后<strong>不立刻断开，也就表示着后面还有请求需要进行处理</strong>。那么如果每次请求都进行握手挥手网络资源消耗量极大，于是用长连接状态表示不立刻断开。如果交互确实进行完成，那么<strong>只要有一方</strong>发送断开连接请求，那么就会来到四次挥手的状态。</p>
<p><em>什么场景下服务端会主动断开连接呢？</em></p>
<ul>
<li>第一个场景：HTTP 没有使用长连接</li>
<li>第二个场景：HTTP 长连接超时</li>
<li>第三个场景：HTTP 长连接的请求数量达到上限</li>
</ul>

        <h2 id="3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？"   >
          <a href="#3-5-服务器出现大量-CLOSE-WAIT-状态的原因有哪些？" class="heading-link"><i class="fas fa-link"></i></a>3.5 服务器出现大量 CLOSE_WAIT 状态的原因有哪些？</h2>
      <p>说明没有发出<code>FIN</code>报文，无法到达下一步<code>LAST_ACK</code>。那么也就是说无法调用<code>closed</code>方法。</p>
<p>通常是代码的问题，主要排查方向是为何服务端调用不到<code>closed</code>方法。</p>

        <h2 id="3-6-建立连接后一方发生故障会怎么样？"   >
          <a href="#3-6-建立连接后一方发生故障会怎么样？" class="heading-link"><i class="fas fa-link"></i></a>3.6 建立连接后一方发生故障会怎么样？</h2>
      
        <h3 id="保活机制"   >
          <a href="#保活机制" class="heading-link"><i class="fas fa-link"></i></a>保活机制</h3>
      <p>通过开启<code>SO_KEEPALIVE</code> 选项生效。</p>
<p>在一个时间段内，如果<strong>任何连接相关的传输的活动</strong>都没有产生，那么每隔一个时间段就发送一次探测报文，如果均没有得到回应，就断定该TCP连接已经死亡。</p>
<p>linux中默认参数如下：</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">7200</span> <span class="comment">//没有活动的时间长度</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl=<span class="number">75</span>  <span class="comment">//发送探测报文的相隔时间段</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">9</span>	 <span class="comment">// 发送探测报文的次数</span></span><br></pre></td></tr></table></div></figure>

<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>

        <h3 id="进程突然被closed"   >
          <a href="#进程突然被closed" class="heading-link"><i class="fas fa-link"></i></a>进程突然被closed</h3>
      <p>如前文所讲，挥手报文丢失的情况。</p>

        <h3 id="主机突然发生宕机"   >
          <a href="#主机突然发生宕机" class="heading-link"><i class="fas fa-link"></i></a>主机突然发生宕机</h3>
      <p>客户端主机崩溃了，服务端是<strong>无法感知到</strong>的，在保活机制时间激活之前，服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态，直到服务端重启进程。</p>
<p>所以，我们可以得知一个点，在双方不传输数据的情况下，<strong>一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</strong></p>

        <h3 id="客户端的网络连接突然断开"   >
          <a href="#客户端的网络连接突然断开" class="heading-link"><i class="fas fa-link"></i></a>客户端的网络连接突然断开</h3>
      <p>TCP 连接在 Linux 内核中是一个名为 <code>struct socket</code> 的结构体，该结构体的内容包含 TCP 连接的状态等信息。当拔掉网线的时候，操作系统并不会变更该结构体的任何内容，所以 TCP 连接的状态也不会发生改变。</p>
<p>换而言之，TCP连接一旦建立，就生成了两个独立的结构存储在<strong>本地</strong>，和传输层的连接关系已然不大。</p>
<p>之后，发送就如同进程被closed的状态，直至重新连上网络，方可恢复正常。</p>

        <h1 id="4-TCP的四个机制"   >
          <a href="#4-TCP的四个机制" class="heading-link"><i class="fas fa-link"></i></a>4. TCP的四个机制</h1>
      
        <h2 id="4-1-重传机制"   >
          <a href="#4-1-重传机制" class="heading-link"><i class="fas fa-link"></i></a>4.1 重传机制</h2>
      
        <h3 id="超时重传"   >
          <a href="#超时重传" class="heading-link"><i class="fas fa-link"></i></a>超时重传</h3>
      <p>顾名思义，<strong>超时重传指的是当发送方超过一定时间没有收到回复的时候，重新发送数据报文。</strong></p>
<ul>
<li><strong>RTT（Routing-trip time）</strong>往返时延，指的是一个数据包从发送到接受到回应所需要经过的时间长度</li>
<li>**RTO (**<strong>Retransmission Timeout</strong> <strong>)</strong> 超时发送时间，指的是超时重传的时间。</li>
</ul>
<p>一般在超时重传机制中，RTO会略大于RTT。</p>
<p>RTO太大或者太小的坏处：</p>
<ul>
<li><strong>太大</strong>：<strong>浪费网络资源，网络收发包效率低下，影响用户体验。</strong>首先发送等待请求的时候，发送方就无法给其他主机发送信息，RTO过长会导致发送方资源的浪费。而且响应的时间变慢，网络传输效率低下，影响了用户的体验。</li>
<li><strong>太小</strong>：<strong>浪费了传输的资源，增加网络阻塞。</strong>也许是回应包还没有发送到，就重新发送，这样会导致发送了两个相同的数据包，对传输资源是一种浪费。</li>
</ul>
<p><strong>超时重传的弊端</strong>：时间过久，影响用户体验。</p>

        <h3 id="快速重传"   >
          <a href="#快速重传" class="heading-link"><i class="fas fa-link"></i></a>快速重传</h3>
      <p>快速重传的工作原理是<strong>收到三个相同的ACK报文时，再发送一次ACK报文下一个的请求报文。</strong></p>
<p>因为TCP连接中基于字节流的特性，报文的传输是有序的，因此响应的ACK所发送过来的序列号就表示该序列号之前的所有报文都已经接收完成。但是后面的响应生死未卜。所以快速重传机制会认为对方没有接收到后续的请求报文，所以重新发送一遍。</p>
<p>但是这种做法存在着问题，你<strong>后面的数据包有多少是没有收到的</strong>，发送方要重新发送多少数据包，这些是快速重传无法得知的，所以我们有了<code>SACK</code>重传机制。</p>

        <h3 id="SACK-amp-amp-D-SACK"   >
          <a href="#SACK-amp-amp-D-SACK" class="heading-link"><i class="fas fa-link"></i></a>SACK &amp;&amp; D-SACK</h3>
      <p>SACK(select-acknowledge) 选择性确认，接收方发送ACK响应的时候，会告诉发送方自己接受到了哪些数据。这能够解决快速重传机制存在的问题。D-SACK（Duplicate SACK），D-SACK告诉发送方那些数据是重复发送的。</p>

        <h2 id="4-2-滑动窗口"   >
          <a href="#4-2-滑动窗口" class="heading-link"><i class="fas fa-link"></i></a>4.2 滑动窗口</h2>
      <p>TCP头部信息中的窗口大小（16位）指的就是这个窗口的大小。指的是接受数据的能力。<strong>在未接受到接受方的应答（数据还没有被处理）的时候，发送方能发送的数据总容量大小。</strong>通常该属性由接收方的窗口大小决定。</p>

        <h3 id="发送方的窗口大小参数"   >
          <a href="#发送方的窗口大小参数" class="heading-link"><i class="fas fa-link"></i></a>发送方的窗口大小参数</h3>
      <ul>
<li><code>SND.WND</code>：表示发送窗口的大小（大小是由接收方指定的）；</li>
<li><code>SND.UNA（Send Unacknoleged）</code>：是一个绝对指针，它指向的是已发送但未收到确认的第一个字节的序列号，也就是 #2 的第一个字节。</li>
<li><code>SND.NXT</code>：也是一个绝对指针，它指向未发送但可发送范围的第一个字节的序列号，也就是 #3 的第一个字节。</li>
<li>指向 #4 的第一个字节是个相对指针，它需要 SND.UNA 指针加上 SND.WND 大小的偏移量，就可以指向 #4 的第一个字节了。<strong>可用窗口大小 &#x3D;</strong> <code>**SND.WND -(SND.NXT - SND.UNA)**</code></li>
</ul>

        <h2 id="4-3-流量控制"   >
          <a href="#4-3-流量控制" class="heading-link"><i class="fas fa-link"></i></a>4.3 流量控制</h2>
      <p>TCP一般会使用<strong>滑动窗口机制</strong>来进行流量控制，简单来讲，就是接收方通过发送窗口的大小来告诉发送方，我还有多少地方可以承受你发的数据，如果太多的话，会造成丢包的情况。</p>

        <h3 id="丢包情况"   >
          <a href="#丢包情况" class="heading-link"><i class="fas fa-link"></i></a>丢包情况</h3>
      <p>但是在业务繁忙的时候，丢包情况也会发生。很简单的一个例子，当接收方窗口大小发生改变的时候，他会立刻发送报文告知发送方，但是发送方在接收到接收方发送的报文之前，就已经将一条数据容量超过窗口大小的数据发送给接收方，那么这时候就会产生丢包的现象。</p>

        <h3 id="死锁情况"   >
          <a href="#死锁情况" class="heading-link"><i class="fas fa-link"></i></a>死锁情况</h3>
      <p>这里指的是双方都无从得知对方的状态，从而进入了相对隔离的，无法更新对方信息的状态。那么造成这种结果的原因是：<strong>接收方更新窗口大小为非0的报文丢失在了网络中</strong>，这种情况下，发送方不知道对方已经处理完成信息了，会一直等待，而接收方也在一直等待发送方发送过来的信息。</p>
<ul>
<li>解决方法：</li>
</ul>
<p><strong>只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。</strong>这个计时器会在没有收到窗口信息传递报文的一定时间内，发送窗口探测报文，而接收方一旦收到这个报文，就会将自己目前的窗口大小发送。通过外界的力量打破了两者之间相互隔离的状态。</p>

        <h3 id="糊涂窗口综合症"   >
          <a href="#糊涂窗口综合症" class="heading-link"><i class="fas fa-link"></i></a>糊涂窗口综合症</h3>
      <p>这里指的是发送方太过于急于求成，可以算是一种贪心算法。只要接收方告诉发送方自己目前有多少个字节的窗口，那么发送方就会毫不犹豫的发送这么多字节的包过去。</p>
<p>但是这样有一个缺点，万一接收方剩余的窗口很小，而TCP的头部是需要占掉很大一部分的，所以说有时候是一笔得不偿失的交易。</p>
<p>那么为了避免这种情况，发送方针对发送数据的大小做出了规定：</p>
<p>接收方采用的策略如下：</p>
<p>不发送小窗口给发送方</p>
<p>发送方通常的策略如下:</p>
<p>使用 Nagle 算法，该算法的思路是延时处理，只有满足下面两个条件中的任意一个条件，才可以发送数据：</p>
<ul>
<li>条件一：要等到窗口大小 &gt;&#x3D; MSS 并且 数据大小 &gt;&#x3D; MSS；</li>
<li>条件二：收到之前发送数据的 ack 回包；</li>
</ul>

        <h2 id="4-4-拥塞控制"   >
          <a href="#4-4-拥塞控制" class="heading-link"><i class="fas fa-link"></i></a>4.4 拥塞控制</h2>
      <p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大….</strong></p>
<p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p>
<p>拥塞窗口 cwnd 变化的规则：</p>
<ul>
<li>只要网络中没有出现拥塞，cwnd 就会增大；</li>
<li>但网络中出现了拥塞，cwnd 就减少；</li>
</ul>
<p>拥塞控制主要有如下四个算法：</p>
<ul>
<li>慢启动</li>
<li>拥塞避免</li>
<li>拥塞发生</li>
<li>快速恢复</li>
</ul>

        <h3 id="慢启动"   >
          <a href="#慢启动" class="heading-link"><i class="fas fa-link"></i></a>慢启动</h3>
      <p>慢启动的意思就是一点一点的提高发送数据包的数量，<strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong>慢启动的增长为指数型增长。</p>
<p>有一个叫慢启动门限 <code>ssthresh （slow start threshold）</code>状态变量。</p>
<ul>
<li>当 <code>cwnd &lt; ssthresh</code> 时，使用慢启动算法。</li>
<li>当 <code>cwnd &gt;= ssthresh</code> 时，就会使用「拥塞避免算法」。</li>
</ul>
<p>一般来说 ssthresh 的大小是 65535 字节。</p>

        <h3 id="拥塞避免"   >
          <a href="#拥塞避免" class="heading-link"><i class="fas fa-link"></i></a>拥塞避免</h3>
      <p><strong>每当收到一个 ACK 时，cwnd 增加 1&#x2F;cwnd。</strong>它属于线性增长，增长较慢。</p>

        <h3 id="拥塞发生"   >
          <a href="#拥塞发生" class="heading-link"><i class="fas fa-link"></i></a>拥塞发生</h3>
      <p>就是在拥塞时，将窗口大小紧急下降。</p>
<p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：</p>
<ul>
<li>cwnd &#x3D; cwnd&#x2F;2 ，也就是设置为原来的一半;</li>
<li>ssthresh &#x3D; cwnd;</li>
<li>进入快速恢复算法</li>
</ul>

        <h3 id="快速恢复"   >
          <a href="#快速恢复" class="heading-link"><i class="fas fa-link"></i></a>快速恢复</h3>
      <p>进入快速恢复算法如下：</p>
<ul>
<li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>

        <h1 id="5-TCP优化的连接"   >
          <a href="#5-TCP优化的连接" class="heading-link"><i class="fas fa-link"></i></a>5. TCP优化的连接</h1>
      
        <h2 id="5-1-从三次握手的角度进行优化"   >
          <a href="#5-1-从三次握手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.1 从三次握手的角度进行优化</h2>
      <p>因为<strong>三次握手是服务端和客户端之间建立联系的前提条件</strong>，不涉及到任何具体传输数据的传输，而只是进行了<strong>一些状态和校验的传输</strong>。因为正常情况下的用时基本可以忽略不记。所以我们可以将优化点放在具体传输的<strong>异常状态</strong>中，去通过调节参数来对三次握手进行加速。</p>

        <h3 id="5-1-1-超时重传的参数调节-client"   >
          <a href="#5-1-1-超时重传的参数调节-client" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 超时重传的参数调节(client)</h3>
      <p>在网络状态堵塞的情况下，超时重传是不可避免的。但是超时了时候重传几次，采取什么策略。就会对于网络连接的效率起到一定的影响作用。</p>
<ul>
<li><strong>超时重传的次数过少：</strong>可能会引发重复传输，影响网络的资源利用率。只是因为网络拥堵，数据包没有丢失只是到达的时间较慢。而在发送一次请求只会对于本就拥塞的网络进行加塞。</li>
<li><strong>超时重传的次数过多：</strong>可能没办法及时发现问题，让一个达不到目的地，没有接收到的连接一直占用着网络资源。导致网络资源利用率的下降。</li>
</ul>
<p><strong>如何调节超时重传次数：</strong>通过控制<code>tcp_syn_retries</code>参数来控制重传次数。在linx内核中默认值为<code>5</code>，每次超时重传的时间为上一次的两倍。初始值为<code>1</code></p>

        <h3 id="5-1-2-半连接队列的参数调节-service"   >
          <a href="#5-1-2-半连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 半连接队列的参数调节(service)</h3>
      <p>半连接队列指的是服务端接受到客户端的第一次握手请求发送的时候，会将这个连接的中间态放到半连接队列中，<strong>主要用来存储准备启用但尚未启用的连接</strong>。那么对于三次握手的<code>SYN攻击</code>指的是通过不断发送只发送第一次请求的连接，将半连接队列占满，使得后面与服务端请求的连接无法获得通讯。那么怎么去尽量避免这种情况呢，有如下两种做法：</p>
<ul>
<li>调节syn队列的大小：通过调节<code>somaxconn</code>, <code>backlog</code>, <code>tcp_max_syn_conn</code>三个参数来共同调节syn队列的大小，其中，前两个参数是调整<code>accept</code>队列的大小，但是也能够同时调整到半连接队列的大小。</li>
<li>通过设置<code>synCookie</code>参数来进行调节： 这个cookie的主要作用是存储半连接队列中连接的信息。将这个信息连同第二次握手一起发送，这样就可以替代半连接队列的作用了。但是也不能一直开启，一直开启就表示忽略半连接队列，将之前的信息全部再做一次传输，那么服务器的压力就会增大。</li>
</ul>
<p>syn_cookie有三个值：0表示不开启，1表示当半连接队列满时开启，2表示一直开启。默认为1</p>

        <h3 id="5-1-3-全连接队列的参数调节-service"   >
          <a href="#5-1-3-全连接队列的参数调节-service" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 全连接队列的参数调节(service)</h3>
      <p><code>tcp_abort_on_overflow</code> 共有两个值分别是 0 和 1，其分别表示：</p>
<ul>
<li>0 ：如果 accept 队列满了，那么 server 扔掉 client 发过来的 ack ；</li>
<li>1 ：如果 accept 队列满了，server 发送一个 RST 包给 client，表示废掉这个握手过程和这个连接；</li>
</ul>
<p><code>accept</code>队列的长度取决于 <code>somaxconn</code> 和 <code>backlog</code> 之间的最小值，也就是 <code>min(somaxconn, backlog)</code>，</p>

        <h3 id="5-1-4-如何绕过三次握手"   >
          <a href="#5-1-4-如何绕过三次握手" class="heading-link"><i class="fas fa-link"></i></a>5.1.4 如何绕过三次握手</h3>
      <p>linux3.7 版本后，提供了<code>tcp fast open</code>的方式：</p>
<p>在客户端首次建立连接时的过程：</p>
<ol>
<li>客户端发送 SYN 报文，该报文包含 Fast Open 选项，且该选项的 Cookie 为空，这表明客户端请求 Fast Open Cookie；</li>
<li>支持 TCP Fast Open 的服务器生成 Cookie，并将其置于 SYN-ACK 数据包中的 Fast Open 选项以发回客户端；</li>
<li>客户端收到 SYN-ACK 后，本地缓存 Fast Open 选项中的 Cookie。</li>
</ol>
<p>支持 TCP Fast Open 的服务器会对收到 Cookie 进行校验：如果 Cookie 有效，服务器将在 SYN-ACK 报文中对 SYN 和「数据」进行确认，服务器随后将「数据」递送至相应的应用程序；如果 Cookie 无效，服务器将丢弃 SYN 报文中包含的「数据」，且其随后发出的 SYN-ACK 报文将只确认 SYN 的对应序列号；</p>
<p>节约了一个TTL的时间。</p>

        <h2 id="5-2-从四次挥手的角度进行优化"   >
          <a href="#5-2-从四次挥手的角度进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.2 从四次挥手的角度进行优化</h2>
      <p><img src="/TCP.assets/1683213868660-eb84aef1-f40d-40cb-abff-9c9a4c341f01.png" alt="img"></p>
<p><strong>主动方的优化</strong></p>
<p>主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 <code>tcp_orphan_retries</code> 参数决定。</p>
<p>当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同：</p>
<ul>
<li>如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 <code>tcp_fin_timeout</code> 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，<code>tcp_max_orphans</code> 定义了最大孤儿连接的数量，超过时连接就会直接释放。</li>
<li>反之是 shutdown 函数关闭的连接，则不受此参数限制；</li>
</ul>
<p>当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止 TIME_WAIT 状态占用太多的资源，<code>tcp_max_tw_buckets</code> 定义了最大数量，超过时连接也会直接释放。</p>
<p>当 TIME_WAIT 状态过多时，还可以通过设置 <code>tcp_tw_reuse</code> 和 <code>tcp_timestamps</code> 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。</p>
<p><strong>被动方的优化</strong></p>
<p>被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。</p>
<p>当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 <code>tcp_orphan_retries</code> 参数的控制下重发 FIN 报文。</p>

        <h2 id="5-3-传输过程中进行优化"   >
          <a href="#5-3-传输过程中进行优化" class="heading-link"><i class="fas fa-link"></i></a>5.3 传输过程中进行优化</h2>
      <p><img src="/TCP.assets/1683213899231-4a98a853-41fe-47ef-9010-09c2de5e47a4.png" alt="img"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/35944/">HTTP</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-03-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-07</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">3.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">19分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-HTTP的基本概念"   >
          <a href="#1-HTTP的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1. HTTP的基本概念</h1>
      
        <h2 id="1-1-HTTP基本定义"   >
          <a href="#1-1-HTTP基本定义" class="heading-link"><i class="fas fa-link"></i></a>1.1 HTTP基本定义</h2>
      <p>全称： 超文本传输协议</p>
<ul>
<li>超文本： 针对于<strong>传输的内容</strong>，不只是文字文件，将内容扩展到了字节流（视频，音频，图片等）内容，只要能用字节传输的内容都可以叫做超文本。</li>
<li>传输：指的是客户端和服务端的<strong>关系</strong>，是双向的。请求内容的同时也能够成为接受响应的主体。</li>
</ul>
<p>http的传输是无状态的不安全的，无需身份的认证就可以向对方发送和接受消息。</p>
<ul>
<li>协议：<strong>约定</strong>的内容，约定了传输时候的行为和规范。</li>
</ul>

        <h2 id="1-2-HTTP常见状态码"   >
          <a href="#1-2-HTTP常见状态码" class="heading-link"><i class="fas fa-link"></i></a>1.2 HTTP常见状态码</h2>
      <div class="table-container"><table>
<thead>
<tr>
<th>状态码分类</th>
<th>表示含义</th>
<th>常见状态码</th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>中间状态，正在等待恢复响应</td>
<td></td>
</tr>
<tr>
<td>2xx</td>
<td>成功</td>
<td><strong>200 OK</strong> - 完全成功 <strong>204 Content</strong> - 成功但没有响应头body <strong>206 Partial Content</strong> - 断点续传或分片中传输一部分成功</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
<td><strong>301 Moved Permanently</strong> - 永久重定向，表示资源不存在了 <strong>302 Found</strong> - 临时重定向，暂时需要用别的URL访问 <strong>304 Not Modified</strong> - 重定向到缓存，用于缓存服务</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端问题</td>
<td><strong>400 Bad Request</strong> - 请求问题（笼统） <strong>403 Forbidden</strong> - 权限问题 <strong>404 Not Found</strong> - 路径问题（和3xx对比，这个完全找不到）</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端问题</td>
<td><strong>500 Internal Server Error</strong> - 服务器错误（笼统） <strong>502 Bad Gateway</strong> - 服务器本身没问题，网关问题 <strong>503 Service Unavailable</strong> - 资源正在加载中</td>
</tr>
</tbody></table></div>

        <h2 id="1-3-GET和POST的区别"   >
          <a href="#1-3-GET和POST的区别" class="heading-link"><i class="fas fa-link"></i></a>1.3 GET和POST的区别</h2>
      <ul>
<li>get一般用于<strong>资源的读取</strong>，也就是<strong>只读</strong>操作。一般不会有请求体，通过路径参数或者json表单传递即可实现。所以说他的操作是<strong>幂等</strong>的。对数据安全不会产生影响。所以对于一些不重复修改的数据，我们可以使用缓存技术降低访问数据库的频率，提高系统的性能。</li>
</ul>
<p>幂等：两次操作后，获取的结果一定是相同的。</p>
<ul>
<li>post一般用于<strong>资源的修改或者新增</strong>，涉及到数据的<strong>写入</strong>操作，所以有可能会出现多线程情况下的<strong>脏读，重复读，幻读</strong>等问题，在高并发的场景下需要通过<strong>锁的机制</strong>来实现对数据库资源的保护。因为每次都会产生一次修改，所以说post操作<strong>不是幂等</strong>的，也是<strong>不安全</strong>的。</li>
</ul>

        <h1 id="2-HTTP缓存技术"   >
          <a href="#2-HTTP缓存技术" class="heading-link"><i class="fas fa-link"></i></a>2. HTTP缓存技术</h1>
      <p>缓存技术是为了解决<strong>静态资源</strong>反复从服务器中加载，但是并没有得到改变，从而<strong>消耗服务器性能</strong>而提出来的一种解决方案。它可以将读取的静态资源放在内存中，下次可以直接从自己的内存中读取资源。无需耗费服务器性能。常用于<strong>静态标签页</strong>。、</p>

        <h2 id="2-1-强制缓存"   >
          <a href="#2-1-强制缓存" class="heading-link"><i class="fas fa-link"></i></a>2.1 强制缓存</h2>
      <p>当你从服务器上加载了一个网页的时候，他就将该网页加载到你的缓存中，并且设置了过期时间<code>Cache-Control</code>，在过期时间之前，如果没有对浏览器进行强刷新(<code>shirt + F5</code>)的话，是无法看到更新的内容的。</p>
<p><img src="/HTTP.assets/1681389010269-d00e8729-3cda-43a2-a207-fd333edd0dfa.png" alt="img"></p>

        <h2 id="2-2-协商缓存"   >
          <a href="#2-2-协商缓存" class="heading-link"><i class="fas fa-link"></i></a>2.2 协商缓存</h2>
      <p>协商缓存时强制缓存失效后的方式。也就是说，只要强制缓存没有过期，协商缓存就不会出现。</p>
<p>有两个变量控制协商缓存的行为<code>Etag</code> 和 <code>Last-Modified</code>。</p>
<p>第一个变量<code>Etag</code> 是资源全局唯一标识，可以判断该资源有没有被修改，第二个变量<code>Last-Modified</code>可以判断该资源最后修改的时间。一般<em>先判断第一个变量，在判断第二个变量。</em>如果响应头部中有一个变量，那么就会交给服务器进行决策，判断是200还是304。304表示无需修改，可重定向到缓存，这时继续使用缓存。200表示有更新，则更新界面和缓存。</p>
<p><img src="/HTTP.assets/1681389028465-d868956c-de33-45f1-8f3d-e49f39790c15.png" alt="img"></p>
<p>先<code>Etag</code>原因是有些服务器判断最后修改时间细粒度不够高，同步性不强。以及有些非资源内部修改操作也会导致资源修改时间被重置。</p>

        <h1 id="3-HTTP如何优化"   >
          <a href="#3-HTTP如何优化" class="heading-link"><i class="fas fa-link"></i></a>3. HTTP如何优化</h1>
      <p>这里的优化指的是通过一些手段来传输时间的减少，从而提升用户使用时候的体验</p>
<p><img src="/HTTP.assets/1681389064792-928bbd85-2f79-44d3-89e4-b841a69ad8c2.png" alt="img"></p>

        <h2 id="3-1-尽可能避免HTTP请求发送"   >
          <a href="#3-1-尽可能避免HTTP请求发送" class="heading-link"><i class="fas fa-link"></i></a>3.1 尽可能避免HTTP请求发送</h2>
      <p>利用<strong>HTTP缓存技术</strong>，将热点数据存储在本地，要发送请求的时候先判断该数据是否已经先加载过，如果在本地缓存中查找到对应内容，那么直接读取本地缓存。所以这种方式主要是通过缓存的方式来尽可能避免数据的传输来优化时间上的体验。但是会占用一定的内存存储空间。</p>

        <h2 id="3-2-减少HTTP每次请求交互次数"   >
          <a href="#3-2-减少HTTP每次请求交互次数" class="heading-link"><i class="fas fa-link"></i></a>3.2 减少HTTP每次请求交互次数</h2>
      <ul>
<li><strong>减少重定向次数</strong></li>
</ul>
<p>当客户端访问的地址迁移的时候，访问的原地址只会给客户端返回302状态码，告诉他下一步要去访问的url，如果多次访问失效的话就会浪费极多次不必要的重定向。那么这时候我们可以采用代理服务器来记录每个服务端口之间的信息，将重定向的工作交由代理服务器完成，降低了一次信息的交换，提高了信息传输的效率。</p>
<ul>
<li><strong>将碎片数据集中成大文件统一进行传输</strong></li>
</ul>
<p>主要应用于<code>**.gif**</code><strong>头像小文件的传输</strong>，将多张小图片<strong>合并</strong>为一张大图片进行传输，可以减少客户端和服务端之间交互的次数。同时我们也可以将<strong>图片转换为</strong><code>**base64**</code><strong>编码文件</strong>附送到url路径中，这样服务端收到请求的时候会自动解析该文件，也减少了一次图片请求的传输。</p>
<ul>
<li><strong>非紧急文件可延迟发送</strong></li>
</ul>
<p>常用于<strong>分页查询</strong>，每次只需要加载一个页面的数据即可，翻页的时候再加载其他资源，可以提高响应的速度</p>
<p>查询100w条数据，如何快速定位到较为后面的页数 –子查询</p>

        <h2 id="3-3-减少HTTP请求发送大小"   >
          <a href="#3-3-减少HTTP请求发送大小" class="heading-link"><i class="fas fa-link"></i></a>3.3 减少HTTP请求发送大小</h2>
      <ul>
<li>有损压缩</li>
<li>无损压缩</li>
</ul>

        <h1 id="4-RSA四次握手"   >
          <a href="#4-RSA四次握手" class="heading-link"><i class="fas fa-link"></i></a>4. RSA四次握手</h1>
      <p>RSA是HTTP请求前的安全传输技术，因为HTTP主要通过明文传输，会有一定的<strong>窃取篡改以及冒充</strong>的风险。所以在HTTP层和TCP层之间新增了一层TSL层，而RSA的TSL的主要实现方式之一，主要通过传输前的四次握手实现<strong>数据加密，校验机制，身份鉴权</strong>来避免以上的风险。</p>
<p><img src="/HTTP.assets/1681389044456-17071ad8-d1cb-48fe-8709-5a6323c284fd.png" alt="img"></p>

        <h2 id="4-1-第一次握手"   >
          <a href="#4-1-第一次握手" class="heading-link"><i class="fas fa-link"></i></a>4.1 第一次握手</h2>
      <p>客户端发送<code>client Hello</code>, 发起RSA加密请求, 传输数据有三个</p>
<ul>
<li><code>TSL Version</code> : TSL加密的版本, 用于和服务端校验统一, 相同TSL版本才可以进行握手</li>
<li><code>Client Random</code>: 客户端随机数, 用于后续加密</li>
<li><code>Cipher Suiter</code>: 支持的密码套件, 用于确认其他加密的方式</li>
</ul>

        <h2 id="4-2-第二次握手"   >
          <a href="#4-2-第二次握手" class="heading-link"><i class="fas fa-link"></i></a>4.2 第二次握手</h2>
      <p>服务端发送<code>server Hello</code>, 发起RSA加密请求, 传输数据有三个</p>
<ul>
<li><code>TSL Version</code> : TSL加密的版本, 校验</li>
<li><code>Server Random</code>: 服务端随机数,  用于后续加密</li>
<li><code>Cipher Suiter</code>: 从接收到的客户端的密码套件中选择一个</li>
</ul>
<p>密码套件基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」</p>
<p>如<code>Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256</code></p>
<ul>
<li>CA数字证书 : 用于身份校验</li>
</ul>

        <h2 id="4-3-CA数字证书校验流程"   >
          <a href="#4-3-CA数字证书校验流程" class="heading-link"><i class="fas fa-link"></i></a>4.3 CA数字证书校验流程</h2>
      <p>数字证书包含的内容:</p>
<ul>
<li>公钥</li>
<li>持有者信息</li>
<li>信息认证机构(CA)的信息</li>
<li>CA采用的签名和算法</li>
<li>证书有效期</li>
<li>额外信息</li>
</ul>
<p><img src="/HTTP.assets/1681389100091-6add38bd-6760-41be-afda-3941b1bf124b.png" alt="img"></p>
<p>客户端已知: 能通过的CA证书加密之后的<code>hash value1</code>, 服务端发送过来的经过CA机构颁发的私钥加密的数字证书。</p>
<p>客户端通过公钥对于服务端发送过来的加密后的数字证书进行解密,得到<code>hash value2</code>, 将可通过的<code>hash value1</code>列表和<code>hash value2</code>进行对比, 如果相同, 就说明证书是可靠的</p>
<p>证书信任链：根证书信任中间证书，中间证书信任服务端证书，那么客户端信任了根证书，也就相当于信任了服务端证书。</p>
<p>主要目的是将根证书进行隔离，保证信任的安全性。</p>

        <h2 id="4-4-第三次握手"   >
          <a href="#4-4-第三次握手" class="heading-link"><i class="fas fa-link"></i></a>4.4 第三次握手</h2>
      <p>客户端首先需要校验发送过来的数字证书是否合法，如果合法，得到公钥<code>pubkey</code>，进行下列操作：</p>
<p>生成随机数<code>pre-master</code>，用<code>pubkey</code>加密传输给服务端；</p>
<p><strong>此时，客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master</strong></p>
<p>双方利用这三个随机数生成<strong>会话密钥</strong>，用于后续信息的加密和解密。</p>
<p>之后客户端给服务端发送<code>change cipher spec</code>， 用于通知服务端后续的会话将由通过会话密钥加密的方式传递信息。</p>
<p>最后，<code>finish</code>是最后一步的校验，将前面信息做<strong>摘要</strong>， 来判断是否前面信息又被篡改。</p>

        <h2 id="4-5-第四次握手"   >
          <a href="#4-5-第四次握手" class="heading-link"><i class="fas fa-link"></i></a>4.5 第四次握手</h2>
      <p>服务器也是同样的操作，发 [ <strong>Change Cipher Spec</strong> ] 和 [ <strong>finish</strong> ] 消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p>
<p>最后客户端和服务端就会通过加密的方式进行会话。</p>

        <h2 id="4-6-RSA算法的缺点"   >
          <a href="#4-6-RSA算法的缺点" class="heading-link"><i class="fas fa-link"></i></a>4.6 RSA算法的缺点</h2>
      <p>无法保证【<strong>前向加密</strong>】，针对于第三次握手，因为是用公钥进行加密的<code>pre-master</code>，如果服务端的私钥被破解，那么全部数据就会被截取和破解，会产生冒充的风险。</p>
<p>前向加密：一个密钥只能访问由它所保护的数据；用来产生密钥的元素一次一换，不能再产生其他的密钥；一个密钥被破解，并不影响其他密钥的安全性。</p>

        <h2 id="4-7-ECDHE-密钥协商算法"   >
          <a href="#4-7-ECDHE-密钥协商算法" class="heading-link"><i class="fas fa-link"></i></a>4.7 ECDHE 密钥协商算法</h2>
      <ul>
<li>运用了离散对数, 圆锥曲线等算法，保证了数据在加密前的安全性,这是相较于RSA算法的一大突破．</li>
<li>RSA算法不支持<strong>前向保密</strong>机制，而ECDHE密钥协商算法支持<strong>前向保密</strong>机制。</li>
<li>ECDHE算法的客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，节省了一个消息的往返时间</li>
</ul>

        <h1 id="5-HTTP2的优化点"   >
          <a href="#5-HTTP2的优化点" class="heading-link"><i class="fas fa-link"></i></a>5. HTTP2的优化点</h1>
      
        <h2 id="5-1-HTTP1-1的缺陷"   >
          <a href="#5-1-HTTP1-1的缺陷" class="heading-link"><i class="fas fa-link"></i></a>5.1 HTTP1. 1的缺陷</h2>
      <p>HTTP&#x2F;2 针对于HTTP1.1的优化主要体现在其<strong>传输效率</strong>上，对于其安全性没有做出过多的改变。安全主要靠的是<strong>HTTPS协议</strong>来进行改善。</p>
<p>那么，HTTP&#x2F;2主要针对以下几个问题进行改良：</p>
<ol>
<li>串行化运行导致传输效率过慢，完成一个HTTP请求之后才能进行下一个</li>
<li>不支持服务器主动推送信息，单向化</li>
<li>头部信息过于庞大且重复，浪费空间大</li>
</ol>
<p>针对以上问题，做出优化点如下：</p>

        <h2 id="5-2-头部压缩"   >
          <a href="#5-2-头部压缩" class="heading-link"><i class="fas fa-link"></i></a>5.2 头部压缩</h2>
      <p>针对于HTTP协议的头部大部分的重复特性，HTTP&#x2F;2编写了编码表，可以类比于我们的哈希结构，以空间换时间，首先是很平常的字段就用静态编码表记录下来，剩下的字段用动态编码表两边各储存一份，到了一定的时间后，就可以只通过发送编码表的序号就可以达到头部的传输功能了。</p>

        <h3 id="5-2-1-静态编码表"   >
          <a href="#5-2-1-静态编码表" class="heading-link"><i class="fas fa-link"></i></a>5.2.1 静态编码表</h3>
      <p>定义：为<strong>高频</strong>出现在HTTP协议头部的字段建立了一张<code>key: set</code>表，总共有61组键值对</p>
<p><img src="/HTTP.assets/1681390216162-c50fc10d-b294-4fab-b68c-a784d89b5ac5.png" alt="img"></p>
<p>其中<code>index</code>为字段的编号，剩下的为键值对信息。</p>
<p><img src="/HTTP.assets/1681390973076-72107641-e4d7-42c6-94b7-222c64e1e128.jpeg" alt="img"></p>
<p>格式如上：首先开头两位为01，表示占位，后面六位<code>index</code>为对应静态编码表中的序号。</p>
<p>第二个字节首位表示<strong>Value 是否经过 Huffman 编码</strong>，后七个字节表示每个值所需要表示的字节长度。</p>
<p>剩下内容为头部的其他信息，以第二个字节为规定的长度为一个单位。</p>

        <h3 id="5-2-2-动态编码表"   >
          <a href="#5-2-2-动态编码表" class="heading-link"><i class="fas fa-link"></i></a>5.2.2 动态编码表</h3>
      <p>边存储边积累，将双方链接过程中的所包含的头部信息共同存储为一张动态表，随着时间的推移，后期双方的链接只需要通过传递序号就可以表达所需要传递的头部信息了。但是这样做会造成<strong>极大的空间内存损耗</strong>。web服务器会提供类似于<code>http2_max_requests</code>这样的字段来限制最大字典表字段数。</p>

        <h2 id="5-3-二进制帧"   >
          <a href="#5-3-二进制帧" class="heading-link"><i class="fas fa-link"></i></a>5.3 二进制帧</h2>
      <p><img src="/HTTP.assets/1681391758634-a381d15e-07c7-4a0e-a5ee-f3af5b6fc6f1.png" alt="img"></p>
<p>帧长度（24bits）：表示的是帧数据（Frame Payload）的长度，不包含帧字节</p>
<p>帧类型（8bits）：分为数据帧和控制帧两类</p>
<p>标志位（8bits）：携带一些控制信息</p>
<p>流标识符（24bits）：表示该帧是属于哪个流的，可以用来组装帧。</p>

        <h2 id="5-4-并发传输"   >
          <a href="#5-4-并发传输" class="heading-link"><i class="fas fa-link"></i></a>5.4 并发传输</h2>
      <p><img src="/HTTP.assets/1681392701396-6abb7739-3882-494b-8d38-5e45a64c305f.png" alt="img"></p>
<ul>
<li>connection：表示HTTP连接，是一次服务端和客户端之间的对话联系</li>
<li>stream：一个connection中包含了多个stream，这是http&#x2F;2的优化之处，他保证了http&#x2F;2的帧可以乱序发送，<strong>因为帧的头部信息携带了流标识符</strong>，最后传到在重新拼装即可，实现了Http链接之间的并行传输。</li>
</ul>
<p>但是同一个流之中的帧不可乱序传输，因为帧头没有确定帧先后顺序的标识位。</p>
<ul>
<li>Response Message：响应信息，表示一个Request或者Reponse，由各个帧组成了一条完整的响应信息。</li>
</ul>
<p>这个模式还突破了原有的全单工模式的传输，服务器和客户端可以同时发送信息了，只要双方各自建立自己的stream，在不同的流上发送即可，极大的提高了传输的效率。</p>
<p>但是这里有一个规定，<strong>客户端仅可建立编号为奇数的stream，服务端仅可以建立编号为偶数的stream</strong>。</p>

        <h2 id="5-5-服务器主动推送资源"   >
          <a href="#5-5-服务器主动推送资源" class="heading-link"><i class="fas fa-link"></i></a>5.5 服务器主动推送资源</h2>
      <p>由于stream的引入，服务器可以自己主动推送资源了。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/10764/">二叉树</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-06</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">2.1k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">14分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h1 id="1-树"   >
          <a href="#1-树" class="heading-link"><i class="fas fa-link"></i></a>1. 树</h1>
      
        <h2 id="1-1-树的基本概念"   >
          <a href="#1-1-树的基本概念" class="heading-link"><i class="fas fa-link"></i></a>1.1 树的基本概念</h2>
      <p>定义：除了根节点，每个节点有且仅有一个前驱<br>基本术语：</p>
<ul>
<li>节点：树上的一个个元素，包含数据元素和指向子树的指针</li>
<li>节点的度： 节点的子树个数</li>
<li>树的度： 树中各节点的度的最大值</li>
<li>叶子节点： 又称<strong>终端节点</strong>，指度为0的节点</li>
<li>分支节点： 又称<strong>非终端节点</strong>，指度不为0的节点</li>
<li>孩子： 节点的子树的根</li>
<li>双亲： 孩子的上一个节点</li>
<li>兄弟： 同一个双亲的孩子之间互为兄弟</li>
<li>祖先： 根到某节点路径上的所有节点，都是这个节点的祖先</li>
<li>层次：根为第一层，往下为第二层</li>
<li>高度：树中节点的最大层次</li>
</ul>

        <h2 id="1-2-树的存储结构"   >
          <a href="#1-2-树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>1.2 树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>浪费空间，一般不使用</li>
<li>链式存储结构</li>
</ol>
<ul>
<li>孩子存储结构</li>
<li>双亲存储结构</li>
<li>孩子兄弟存储结构</li>
</ul>

        <h1 id="2-二叉树"   >
          <a href="#2-二叉树" class="heading-link"><i class="fas fa-link"></i></a>2. 二叉树</h1>
      <p>定义：<br>每个节点最多只能有两个子树，即每个子树的度为0，1，2<br>且有左右之分，不能颠倒</p>

        <h2 id="2-1-二叉树的主要性质"   >
          <a href="#2-1-二叉树的主要性质" class="heading-link"><i class="fas fa-link"></i></a>2.1 二叉树的主要性质</h2>
      <ol>
<li>非空二叉树上叶子节点数等于双分支节点数加1<br>即：<code>n0 = n2 + 1</code><br>证明：设二叉树上叶子节点数为n0，单分支节点数为n1，双分支节点数为n2；<br>则总结点数为<code>n0+n1+n2</code><br>总分支数为<code>n1+2n2</code><br>根据总分支数&#x3D;总节点数-1，有<code>n0+n1+n2-1 = n1+2n2</code><br>化简后得到：<code>n0 = n2 + 1</code></li>
<li>二叉树上的第i层最多有<code>2^(i-1)</code>个节点</li>
<li>高度为h的二叉树最多有<code>2^h - 1</code>个节点</li>
<li>在有n个节点的完全二叉树下，如果i为某节点的编号，那么有</li>
</ol>
<ul>
<li>i&#x2F;2（向下取整）为其双亲的节点编号</li>
<li>2i为其左孩子编号，2i+1为其右孩子编号(若&gt;n,那么无左右孩子)</li>
</ul>
<ol start="5">
<li>具有n个节点的完全二叉树的高度为log2 n + 1(向下取整)</li>
</ol>

        <h2 id="2-2-二叉树的存储结构"   >
          <a href="#2-2-二叉树的存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.2 二叉树的存储结构</h2>
      <ol>
<li>顺序存储结构<br>最适用于完全二叉树，适用于普通二叉树易导致浪费存储空间</li>
<li>链式存储结构<br>用一个节点和两个树之间的关系表示二叉树的链式存储结构<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span></span><br><span class="line">&#123;</span><br><span class="line">    Elemtype data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchlid;  <span class="comment">//左指针域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchlid;  <span class="comment">//右指针域</span></span><br><span class="line">&#125;BTNode；</span><br></pre></td></tr></table></div></figure></li>
</ol>

        <h2 id="2-3-二叉树的遍历算法"   >
          <a href="#2-3-二叉树的遍历算法" class="heading-link"><i class="fas fa-link"></i></a>2.3 二叉树的遍历算法</h2>
      <ul>
<li>先序遍历(根 -&gt; 左 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">preorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>中序遍历(左 -&gt; 根 -&gt; 右)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">        <span class="built_in">inorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>后序遍历(左 -&gt; 右 -&gt; 根)<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; lchild);  <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="built_in">postorder</span>(p -&gt; rchild);  <span class="comment">//遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(p);  <span class="comment">//假设visit为打印等我们需要的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
<li>层序遍历<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">    BTNode *queue[maxSize];</span><br><span class="line">    front = rear = <span class="number">0</span>;</span><br><span class="line">    BTNode *q;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">        queue[rear] = p;</span><br><span class="line">        <span class="keyword">while</span>(front != rear) &#123;</span><br><span class="line">            front = (front + <span class="number">1</span>)% maxSize;</span><br><span class="line">            q = queue[front];</span><br><span class="line">            <span class="built_in">visit</span>(q);</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q -&gt; rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                rear = (rear + <span class="number">1</span>)% maxSize;</span><br><span class="line">                queue[rear] = q -&gt; rchild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h2 id="2-4-线索二叉树"   >
          <a href="#2-4-线索二叉树" class="heading-link"><i class="fas fa-link"></i></a>2.4 线索二叉树</h2>
      <p>节点定义：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;  <span class="comment">//线索标记，判断是子树还是线索</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TBTNode</span> *rchild;</span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></div></figure>

<p>中序遍历线索二叉树算法：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != null) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(p -&gt; lchild, pre); <span class="comment">// 递归，左子树线索化</span></span><br><span class="line">        <span class="keyword">if</span>(p -&gt; lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立当前节点的前驱线索</span></span><br><span class="line">            p -&gt; lchild = pre;</span><br><span class="line">            p -&gt; ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre -&gt; rchlid == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 建立前驱节点的后继线索</span></span><br><span class="line">            p -&gt; rchild = p;</span><br><span class="line">            p -&gt; rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;rchlid;</span><br><span class="line">        <span class="built_in">InThread</span>(p,pre); <span class="comment">// 递归，右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立线索二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createInThread</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">    TBTNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(root, pre);</span><br><span class="line">        pre -&gt; rchild = null;  <span class="comment">//非空二叉树线索化</span></span><br><span class="line">        pre -&gt; rtag = <span class="number">1</span>;   <span class="comment">// 处理中序最后一个节点 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="2-5-树和二叉树的应用"   >
          <a href="#2-5-树和二叉树的应用" class="heading-link"><i class="fas fa-link"></i></a>2.5 树和二叉树的应用</h2>
      
        <h3 id="2-5-1-二叉排序树-BTS"   >
          <a href="#2-5-1-二叉排序树-BTS" class="heading-link"><i class="fas fa-link"></i></a>2.5.1 二叉排序树(BTS)</h3>
      
        <h4 id="2-5-1-1-定义"   >
          <a href="#2-5-1-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.1 定义</h4>
      <ol>
<li>若其左子树不为空，则左子树上所有关键字的值均不大于根关键字的值；</li>
<li>若其右子树不为空，则右子树上所有关键字的值均不小于根关键字的值；</li>
<li>每个根节点下的子树都满足此规则</li>
</ol>

        <h4 id="2-5-1-2-存储结构"   >
          <a href="#2-5-1-2-存储结构" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.2 存储结构</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *lchild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BTNode</span> *rchild;</span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-查找"   >
          <a href="#2-5-1-3-查找" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 查找</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BSTSearch</span><span class="params">(BTNode* bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(bt-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> bt;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-3-插入"   >
          <a href="#2-5-1-3-插入" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.3 插入</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BSTInsert</span><span class="params">(BTNode* &amp;bt, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到插入位置，创建新节点并插入</span></span><br><span class="line">    <span class="keyword">if</span>(bt == null) &#123;</span><br><span class="line">        bt = (BTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BTNode)); <span class="comment">//创建新节点</span></span><br><span class="line">        bt-&gt;lchild = bt-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        bt-&gt;key = key;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//节点不为空，查找插入位置，和查找算法类似</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(key == bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 已经存在值，不用插入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; bt-&gt;key) &#123;</span><br><span class="line">            <span class="comment">// 小于根节点关键字时，到左子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;lchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 大于根节点关键字时，到右子树查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">BSTSearch</span>(bt-&gt;rchild, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-4-构造"   >
          <a href="#2-5-1-4-构造" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.4 构造</h4>
      <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBTS</span><span class="params">(BTNode *&amp;bt, <span class="type">int</span> key[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一棵空树</span></span><br><span class="line">    bt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// 逐个插入节点</span></span><br><span class="line">        <span class="built_in">BSTInsert</span>(bt, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h4 id="2-5-1-5-删除"   >
          <a href="#2-5-1-5-删除" class="heading-link"><i class="fas fa-link"></i></a>2.5.1.5 删除</h4>
      <ol>
<li>p节点为叶子节点，直接删除</li>
<li>p节点只有左子树或者右子树，直接删除，将子树与原来双亲节点连接即可</li>
<li>p节点既有左子树又有右子树，将其直接前驱(或后继)作为双亲节点的连接点</li>
</ol>

        <h3 id="2-5-2-平衡二叉树-AVL树"   >
          <a href="#2-5-2-平衡二叉树-AVL树" class="heading-link"><i class="fas fa-link"></i></a>2.5.2 平衡二叉树(AVL树)</h3>
      
        <h4 id="2-5-2-1-定义"   >
          <a href="#2-5-2-1-定义" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.1 定义</h4>
      <p>是一种特殊的二叉排序树，其左右子树高度的差的绝对值不超过1；其考点主要为平衡调整，共有LL, RR, LR, RL四种类型</p>

        <h4 id="2-5-2-2-LL"   >
          <a href="#2-5-2-2-LL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.2 LL</h4>
      <ol>
<li>当前操作节点是A （A这个节点是最小失衡树的根节点)</li>
<li>断开该节点的根节点的左孩子连接线 (此时变成了两棵树，设以A为根节点的树为原根树，以B为根节点的树为新根树)</li>
<li>判断新根树的根节点的右子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的右子树。</li>
<li>若不空:<br>– 将新根树的根节点的右子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的左子树。<br>– 把原根树作为新根树的右子树。</li>
</ul>

        <h4 id="2-5-2-3-RR"   >
          <a href="#2-5-2-3-RR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.3 RR</h4>
      <ol>
<li>当前操作节点是66 （66这个节点是最小失衡树的根节点)</li>
<li>断开该节点的右孩子连接线 (此时变成了两棵树，设以66为根节点的树为原根树，以77为根节点的树为新根树)</li>
<li>判断新根树的根节点的左子树是否为空</li>
</ol>
<ul>
<li>若空，直接把原根树作为新根树的左子树。</li>
<li>若不空:<br>– 将新根树的根节点的左子树独立出来，设其名为新原独树。<br>– 把新原独树作为原根树的右子树。<br>– 把原根树作为新根树的左子树。</li>
</ul>

        <h4 id="2-5-2-4-LR"   >
          <a href="#2-5-2-4-LR" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.4 LR</h4>
      <p>先左旋，再右旋</p>

        <h4 id="2-5-2-5-RL"   >
          <a href="#2-5-2-5-RL" class="heading-link"><i class="fas fa-link"></i></a>2.5.2.5 RL</h4>
      <p>先右旋，再左旋</p>

        <h3 id="2-5-3-哈夫曼树与哈夫曼编码"   >
          <a href="#2-5-3-哈夫曼树与哈夫曼编码" class="heading-link"><i class="fas fa-link"></i></a>2.5.3 哈夫曼树与哈夫曼编码</h3>
      
        <h3 id="2-5-4-并查集"   >
          <a href="#2-5-4-并查集" class="heading-link"><i class="fas fa-link"></i></a>2.5.4 并查集</h3>
      
        <h3 id="2-5-5-红黑树"   >
          <a href="#2-5-5-红黑树" class="heading-link"><i class="fas fa-link"></i></a>2.5.5 红黑树</h3>
      
        <h4 id="2-5-5-1-性质"   >
          <a href="#2-5-5-1-性质" class="heading-link"><i class="fas fa-link"></i></a>2.5.5.1 性质</h4>
      <ol>
<li>节点包含红黑信息，根节点是黑色</li>
<li>所有叶子节点都是黑色，标记为NIL节点</li>
<li>每个红色节点必须有两个黑色的子节点（从每个叶子到根的所有路径上不能有两个连续的红色节点）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li>
</ol>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/3701/">Spring_1</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-12-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-12-03</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">17.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">131分</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="Spring-day01"   >
          <a href="#Spring-day01" class="heading-link"><i class="fas fa-link"></i></a>Spring_day01</h2>
      <p><strong>今日目标</strong></p>
<blockquote>
<ul>
<li>掌握Spring相关概念</li>
<li>完成IOC&#x2F;DI的入门案例编写</li>
<li>掌握IOC的相关配置与使用</li>
<li>掌握DI的相关配置与使用</li>
</ul>
</blockquote>

        <h2 id="1，课程介绍"   >
          <a href="#1，课程介绍" class="heading-link"><i class="fas fa-link"></i></a>1，课程介绍</h2>
      <p>对于一门新技术，我们需要从<code>为什么要学</code>、<code>学什么</code>以及<code>怎么学</code>这三个方向入手来学习。那对于Spring来说:</p>

        <h3 id="1-1-为什么要学"   >
          <a href="#1-1-为什么要学" class="heading-link"><i class="fas fa-link"></i></a>1.1 为什么要学?</h3>
      <ul>
<li><p>从使用和占有率看</p>
<ul>
<li><p>Spring在市场的占有率与使用率高</p>
</li>
<li><p>Spring在企业的技术选型命中率高</p>
</li>
<li><p>所以说,Spring技术是JavaEE开发必备技能，企业开发技术选型命中率&gt;&#x3D;&#x3D;90%&#x3D;&#x3D;</p>
<p><img src="/images/image-20210729171139088.png"></p>
<p><strong>说明</strong>:对于未使用Spring的项目一般都是些比较老的项目，大多都处于维护阶段。</p>
</li>
</ul>
</li>
<li><p>从专业角度看</p>
<ul>
<li>随着时代发展，软件规模与功能都呈几何式增长，开发难度也在不断递增，该如何解决?<ul>
<li>Spring可以&#x3D;&#x3D;简化开发&#x3D;&#x3D;，降低企业级开发的复杂性，使开发变得更简单快捷</li>
</ul>
</li>
<li>随着项目规模与功能的增长,遇到的问题就会增多，为了解决问题会引入更多的框架，这些框架如何协调工作?<ul>
<li>Spring可以&#x3D;&#x3D;框架整合&#x3D;&#x3D;，高效整合其他技术，提高企业级应用开发与运行效率</li>
</ul>
</li>
</ul>
<p>综上所述，&#x3D;&#x3D;Spring是一款非常优秀而且功能强大的框架，不仅要学，而且还要学好。&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-2-学什么"   >
          <a href="#1-2-学什么" class="heading-link"><i class="fas fa-link"></i></a>1.2 学什么?</h3>
      <p>从上面的介绍中，我们可以看到Spring框架主要的优势是在<code>简化开发</code>和<code>框架整合</code>上，至于如何实现就是咱们要学习Spring框架的主要内容:</p>
<ul>
<li><p>简化开发: Spring框架中提供了两个大的核心技术，分别是:</p>
<ul>
<li>&#x3D;&#x3D;IOC&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP&#x3D;&#x3D;<ul>
<li>&#x3D;&#x3D;事务处理&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p> 1.Spring的简化操作都是基于这两块内容,所以这也是Spring学习中最为重要的两个知识点。</p>
<p> 2.事务处理属于Spring中AOP的具体应用，可以简化项目中的事务管理，也是Spring技术中的一大亮点。</p>
</li>
<li><p>框架整合: Spring在框架整合这块已经做到了极致，它可以整合市面上几乎所有主流框架，比如:</p>
<ul>
<li>&#x3D;&#x3D;MyBatis&#x3D;&#x3D;</li>
<li>MyBatis-plus</li>
<li>Struts</li>
<li>Struts2</li>
<li>Hibernate</li>
<li>……</li>
</ul>
<p>这些框架中，我们目前只学习了MyBatis，所以在Spring框架的学习中，主要是学习如何整合MyBatis。</p>
<p>综上所述，对于Spring的学习，主要学习四块内容:</p>
<p>&#x3D;&#x3D;(1)IOC,(2)整合Mybatis(IOC的具体应用)，(3)AOP,(4)声明式事务(AOP的具体应用)&#x3D;&#x3D;</p>
</li>
</ul>

        <h3 id="1-3-怎么学"   >
          <a href="#1-3-怎么学" class="heading-link"><i class="fas fa-link"></i></a>1.3 怎么学?</h3>
      <ul>
<li>学习Spring框架设计思想<ul>
<li>对于Spring来说，它能迅速占领全球市场，不只是说它的某个功能比较强大，更重要是在它的<code>思想</code>上。</li>
</ul>
</li>
<li>学习基础操作，思考操作与思想间的联系<ul>
<li>掌握了Spring的设计思想，然后就需要通过一些基础操作来思考操作与思想之间的关联关系</li>
</ul>
</li>
<li>学习案例，熟练应用操作的同时，体会思想<ul>
<li>会了基础操作后，就需要通过大量案例来熟练掌握框架的具体应用，加深对设计思想的理解。</li>
</ul>
</li>
</ul>
<p>介绍完<code>为什么要学</code>、<code>学什么</code>和<code>怎么学</code>Spring框架后，大家需要重点掌握的是:</p>
<ul>
<li>Spring很优秀，需要认真重点的学习</li>
<li>Spring的学习主线是IOC、AOP、声明式事务和整合MyBais</li>
</ul>
<p>接下来，咱们就开始进入Spring框架的学习。</p>

        <h2 id="2，Spring相关概念"   >
          <a href="#2，Spring相关概念" class="heading-link"><i class="fas fa-link"></i></a>2，Spring相关概念</h2>
      
        <h3 id="2-1-初识Spring"   >
          <a href="#2-1-初识Spring" class="heading-link"><i class="fas fa-link"></i></a>2.1 初识Spring</h3>
      <p>在这一节，主要通过以下两个点来了解下Spring:</p>

        <h4 id="2-1-1-Spring家族"   >
          <a href="#2-1-1-Spring家族" class="heading-link"><i class="fas fa-link"></i></a>2.1.1 Spring家族</h4>
      <ul>
<li><p>官网：<a href="https://spring.io，从官网我们可以大概了解到：">https://spring.io，从官网我们可以大概了解到：</a></p>
<ul>
<li>Spring能做什么:用以开发web、微服务以及分布式系统等,光这三块就已经占了JavaEE开发的九成多。</li>
<li>Spring并不是单一的一个技术，而是一个大家族，可以从官网的<code>Projects</code>中查看其包含的所有技术。</li>
</ul>
</li>
<li><p>Spring发展到今天已经形成了一种开发的生态圈,Spring提供了若干个项目,每个项目用于完成特定的功能。</p>
<ul>
<li><p>Spring已形成了完整的生态圈，也就是说我们可以完全使用Spring技术完成整个项目的构建、设计与开发。</p>
</li>
<li><p>Spring有若干个项目，可以根据需要自行选择，把这些个项目组合起来，起了一个名称叫&#x3D;&#x3D;全家桶&#x3D;&#x3D;，如下图所示</p>
<p><img src="/images/image-20210729171850181.png"></p>
<p><strong>说明:</strong></p>
<p>图中的图标都代表什么含义，可以进入<code>https://spring.io/projects</code>网站进行对比查看。</p>
<p>这些技术并不是所有的都需要学习，额外需要重点关注<code>Spring Framework</code>、<code>SpringBoot</code>和<code>SpringCloud</code>:</p>
<p><img src="/images/1629714811435.png"></p>
<ul>
<li>Spring Framework:Spring框架，是Spring中最早最核心的技术，也是所有其他技术的基础。</li>
<li>SpringBoot:Spring是来简化开发，而SpringBoot是来帮助Spring在简化的基础上能更快速进行开发。</li>
<li>SpringCloud:这个是用来做分布式之微服务架构的相关开发。</li>
</ul>
<p>除了上面的这三个技术外，还有很多其他的技术，也比较流行，如SpringData,SpringSecurity等，这些都可以被应用在我们的项目中。我们今天所学习的Spring其实指的是&#x3D;&#x3D;Spring Framework&#x3D;&#x3D;。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="2-1-2-了解Spring发展史"   >
          <a href="#2-1-2-了解Spring发展史" class="heading-link"><i class="fas fa-link"></i></a>2.1.2 了解Spring发展史</h4>
      <p> 接下来我们介绍下Spring Framework这个技术是如何来的呢?</p>
<p><img src="/images/image-20210729171926576.png"></p>
<p>Spring发展史</p>
<ul>
<li>IBM(IT公司-国际商业机器公司)在1997年提出了EJB思想,早期的JAVAEE开发大都基于该思想。</li>
<li>Rod Johnson(Java和J2EE开发领域的专家)在2002年出版的<code>Expert One-on-One J2EE Design and Development</code>,书中有阐述在开发中使用EJB该如何做。</li>
<li>Rod Johnson在2004年出版的<code>Expert One-on-One J2EE Development without EJB</code>,书中提出了比EJB思想更高效的实现方案，并且在同年将方案进行了具体的落地实现，这个实现就是Spring1.0。</li>
<li>随着时间推移，版本不断更新维护，目前最新的是Spring5<ul>
<li>Spring1.0是纯配置文件开发</li>
<li>Spring2.0为了简化开发引入了注解开发，此时是配置文件加注解的开发方式</li>
<li>Spring3.0已经可以进行纯注解开发，使开发效率大幅提升，我们的课程会以注解开发为主</li>
<li>Spring4.0根据JDK的版本升级对个别API进行了调整</li>
<li>Spring5.0已经全面支持JDK8，现在Spring最新的是5系列所以建议大家把JDK安装成1.8版</li>
</ul>
</li>
</ul>
<p>本节介绍了Spring家族与Spring的发展史，需要大家重点掌握的是:</p>
<ul>
<li>今天所学的Spring其实是Spring家族中的Spring Framework</li>
<li>Spring Framework是Spring家族中其他框架的底层基础，学好Spring可以为其他Spring框架的学习打好基础</li>
</ul>

        <h3 id="2-2-Spring系统架构"   >
          <a href="#2-2-Spring系统架构" class="heading-link"><i class="fas fa-link"></i></a>2.2 Spring系统架构</h3>
      <p>前面我们说spring指的是Spring Framework,那么它其中都包含哪些内容以及我们该如何学习这个框架?</p>
<p>针对这些问题，我们将从<code>系统架构图</code>和<code>课程学习路线</code>来进行说明:</p>

        <h4 id="2-2-1-系统架构图"   >
          <a href="#2-2-1-系统架构图" class="heading-link"><i class="fas fa-link"></i></a>2.2.1 系统架构图</h4>
      <ul>
<li><p>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基。</p>
</li>
<li><p>Spring Framework的发展也经历了很多版本的变更，每个版本都有相应的调整</p>
<p><img src="/images/image-20210729172153796.png"></p>
</li>
<li><p>Spring Framework的5版本目前没有最新的架构图，而最新的是4版本，所以接下来主要研究的是4的架构图</p>
<p><img src="/images/1629720945720.png"></p>
<p>(1)核心层</p>
<ul>
<li>Core Container:核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块</li>
</ul>
<p>(2)AOP层</p>
<ul>
<li>AOP:面向切面编程，它依赖核心层容器，目的是&#x3D;&#x3D;在不改变原有代码的前提下对其进行功能增强&#x3D;&#x3D;</li>
<li>Aspects:AOP是思想,Aspects是对AOP思想的具体实现</li>
</ul>
<p>(3)数据层</p>
<ul>
<li>Data Access:数据访问，Spring全家桶中有对数据访问的具体实现技术</li>
<li>Data Integration:数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis</li>
<li>Transactions:事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容</li>
</ul>
<p>(4)Web层</p>
<ul>
<li>这一层的内容将在SpringMVC框架具体学习</li>
</ul>
<p>(5)Test层</p>
<ul>
<li>Spring主要整合了Junit来完成单元测试和集成测试</li>
</ul>
</li>
</ul>

        <h4 id="2-2-2-课程学习路线"   >
          <a href="#2-2-2-课程学习路线" class="heading-link"><i class="fas fa-link"></i></a>2.2.2 课程学习路线</h4>
      <p>介绍完Spring的体系结构后，从中我们可以得出对于Spring的学习主要包含四部分内容，分别是:</p>
<ul>
<li>&#x3D;&#x3D;Spring的IOC&#x2F;DI&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;Spring的AOP&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;AOP的具体应用,事务管理&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;IOC&#x2F;DI的具体应用,整合Mybatis&#x3D;&#x3D;</li>
</ul>
<p><img src="/images/1629722300996.png"></p>
<p>对于这节的内容，大家重点要记住的是Spring需要学习的四部分内容。接下来就从第一部分开始学起。</p>

        <h3 id="2-3-Spring核心概念"   >
          <a href="#2-3-Spring核心概念" class="heading-link"><i class="fas fa-link"></i></a>2.3 Spring核心概念</h3>
      <p>在Spring核心概念这部分内容中主要包含<code>IOC/DI</code>、<code>IOC容器</code>和<code>Bean</code>,那么问题就来了，这些都是什么呢?</p>

        <h4 id="2-3-1-目前项目中的问题"   >
          <a href="#2-3-1-目前项目中的问题" class="heading-link"><i class="fas fa-link"></i></a>2.3.1 目前项目中的问题</h4>
      <p>一个概念的提出，总是因为有对应的问题需要去解决，那么我们就需要先分析下目前咱们代码在编写过程中遇到的问题:</p>
<p><img src="/images/1629723232339.png"></p>
<p>(1)业务层需要调用数据层的方法，就需要在业务层new数据层的对象</p>
<p>(2)如果数据层的实现类发生变化，那么业务层的代码也需要跟着改变，发生变更后，都需要进行编译打包和重部署</p>
<p>(3)所以，现在代码在编写的过程中存在的问题是：&#x3D;&#x3D; <strong>耦合度偏高</strong> &#x3D;&#x3D;</p>
<p>针对这个问题，该如何解决呢?</p>
<p><img src="/images/1629724206002.png"></p>
<p>我们就想，如果能把框中的内容给去掉，不就可以降低依赖了么，但是又会引入新的问题，去掉以后程序能运行么?</p>
<p>答案肯定是不行，因为bookDao没有赋值为Null，强行运行就会出空指针异常。</p>
<p>所以现在的问题就是，业务层不想new对象，运行的时候又需要这个对象，该咋办呢?</p>
<p>针对这个问题，Spring就提出了一个解决方案:</p>
<ul>
<li>使用对象时，<mark>在程序中不要主动使用new产生对象，转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象</mark></li>
</ul>
<p>这种实现思就是Spring的一个核心概念</p>

        <h4 id="2-3-2-IOC、IOC容器、Bean、DI"   >
          <a href="#2-3-2-IOC、IOC容器、Bean、DI" class="heading-link"><i class="fas fa-link"></i></a>2.3.2 IOC、IOC容器、Bean、DI</h4>
      <ol>
<li>&#x3D;&#x3D;IOC（Inversion of Control）控制反转&#x3D;&#x3D;</li>
</ol>
<p>(1)什么是控制反转呢？</p>
<ul>
<li>使用对象时，由主动new产生对象转换为由&#x3D;&#x3D;外部&#x3D;&#x3D;提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，交给<code>别人[外部]</code>来创建对象</li>
<li><code>别人[外部]</code>就反转控制了数据层对象的创建权</li>
<li>这种思想就是控制反转</li>
<li>别人[外部]指定是什么呢?继续往下学</li>
</ul>
</li>
</ul>
<p>(2)Spring和IOC之间的关系是什么呢?</p>
<ul>
<li>Spring技术对IOC思想进行了<strong>实现</strong></li>
<li>Spring提供了一个容器，称为&#x3D;&#x3D;IOC容器&#x3D;&#x3D;，用来充当IOC思想中的”外部”， IOC容器是IOC思想的具体实现</li>
<li>IOC思想中的<code>别人[外部]</code>指的就是Spring的IOC容器</li>
</ul>
<p>(3)IOC容器的作用以及内部存放的是什么?</p>
<ul>
<li>IOC容器<strong>负责对象的创建</strong>、初始化等一系列工作，其中包含了数据层和业务层的类对象</li>
<li>被创建或被管理的<strong>对象</strong>在IOC容器中统称为**&#x3D;&#x3D;Bean&#x3D;&#x3D;**</li>
<li>IOC容器中放的就是一个个的Bean对象</li>
</ul>
<p>(4)当IOC容器中创建好service和dao对象后，程序能正确执行么?</p>
<ul>
<li>不行，因为service运行需要依赖dao对象</li>
<li>IOC容器中虽然有service和dao对象</li>
<li>但是service对象和dao对象没有任何关系</li>
<li>需要把dao对象交给service,也就是说要<strong>绑定service和dao对象之间的关系</strong></li>
</ul>
<p>像这种在容器中建立对象与对象之间的绑定关系就要用到DI:</p>
<ol start="2">
<li>&#x3D;&#x3D;DI（Dependency Injection）依赖注入&#x3D;&#x3D;</li>
</ol>
<p><img src="/images/1629735078619.png"></p>
<p>(1)什么是依赖注入呢?</p>
<ul>
<li>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入<ul>
<li>业务层要用数据层的类对象，以前是自己<code>new</code>的</li>
<li>现在自己不new了，靠<code>别人[外部其实指的就是IOC容器]</code>来给注入进来</li>
<li>这种思想就是依赖注入</li>
</ul>
</li>
</ul>
<p>(2)IOC容器中哪些bean之间要建立依赖关系呢?</p>
<ul>
<li>这个需要程序员根据业务需求提前建立好关系，如业务层需要依赖数据层，service就要和dao建立依赖关系</li>
</ul>
<p>介绍完Spring的IOC和DI的概念后，我们会发现这两个概念的最终目标就是:&#x3D;&#x3D;充分解耦&#x3D;&#x3D;，具体实现靠:</p>
<ul>
<li>使用IOC容器管理bean（IOC)</li>
<li>在IOC容器内将有依赖关系的bean进行关系绑定（DI）</li>
<li>最终结果为:使用对象时不仅可以直接从IOC容器中获取，并且获取到的bean已经绑定了所有的依赖关系.</li>
</ul>

        <h4 id="2-3-3-核心概念小结"   >
          <a href="#2-3-3-核心概念小结" class="heading-link"><i class="fas fa-link"></i></a>2.3.3 核心概念小结</h4>
      <p>这节比较重要，重点要理解<code>什么是IOC/DI思想</code>、<code>什么是IOC容器</code>和<code>什么是Bean</code>：</p>
<p>(1)什么IOC&#x2F;DI思想?</p>
<ul>
<li>IOC:控制反转，控制反转的是对象的创建权</li>
<li>DI:依赖注入，绑定对象与对象之间的依赖关系</li>
</ul>
<p>(2)什么是IOC容器?</p>
<p>Spring创建了一个容器用来存放所创建的对象，这个容器就叫IOC容器</p>
<p>(3)什么是Bean?</p>
<p>容器中所存放的一个个对象就叫Bean或Bean对象</p>

        <h2 id="3，入门案例"   >
          <a href="#3，入门案例" class="heading-link"><i class="fas fa-link"></i></a>3，入门案例</h2>
      <p>介绍完Spring的核心概念后，接下来我们得思考一个问题就是，Spring到底是如何来实现IOC和DI的，那接下来就通过一些简单的入门案例，来演示下具体实现过程:</p>

        <h3 id="3-1-IOC入门案例"   >
          <a href="#3-1-IOC入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.1 IOC入门案例</h3>
      <p>对于入门案例，我们得先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-1-1-入门案例思路分析"   >
          <a href="#3-1-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.1.1 入门案例思路分析</h4>
      <p>(1)Spring是使用容器来管理bean对象的，那么管什么? </p>
<ul>
<li>主要管理项目中所使用到的类对象，比如(Service和Dao)</li>
</ul>
<p>(2)如何将被管理的对象告知IOC容器?</p>
<ul>
<li>使用配置文件</li>
</ul>
<p>(3)被管理的对象交给IOC容器，要想从容器中获取对象，就先得思考如何获取到IOC容器?</p>
<ul>
<li>Spring框架提供相应的接口</li>
</ul>
<p>(4)IOC容器得到后，如何从容器中获取bean?</p>
<ul>
<li>调用Spring框架提供对应接口中的方法</li>
</ul>
<p>(5)使用Spring导入哪些坐标?</p>
<ul>
<li>用别人的东西，就需要在pom.xml添加对应的依赖</li>
</ul>

        <h4 id="3-1-2-入门案例代码实现"   >
          <a href="#3-1-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.1.2 入门案例代码实现</h4>
      <blockquote>
<p>需求分析:将BookServiceImpl和BookDaoImpl交给Spring管理，并从容器中获取对应的bean对象进行方法调用。</p>
<p>1.创建Maven的java项目</p>
<p>2.pom.xml添加Spring的依赖jar包</p>
<p>3.创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<p>4.resources下添加spring配置文件，并完成bean的配置</p>
<p>5.使用Spring提供的接口完成IOC容器的创建</p>
<p>6.从容器中获取对象进行方法调用</p>
</blockquote>

        <h5 id="步骤1-创建Maven项目"   >
          <a href="#步骤1-创建Maven项目" class="heading-link"><i class="fas fa-link"></i></a>步骤1:创建Maven项目</h5>
      <p><img src="/images/1629734010072.png"></p>

        <h5 id="步骤2-添加Spring的依赖jar包"   >
          <a href="#步骤2-添加Spring的依赖jar包" class="heading-link"><i class="fas fa-link"></i></a>步骤2:添加Spring的依赖jar包</h5>
      <p>pom.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-添加案例中需要的类"   >
          <a href="#步骤3-添加案例中需要的类" class="heading-link"><i class="fas fa-link"></i></a>步骤3:添加案例中需要的类</h5>
      <p>创建BookService,BookServiceImpl，BookDao和BookDaoImpl四个类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BookDaoImpl</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-添加spring配置文件"   >
          <a href="#步骤4-添加spring配置文件" class="heading-link"><i class="fas fa-link"></i></a>步骤4:添加spring配置文件</h5>
      <p>resources下添加spring配置文件applicationContext.xml，并完成bean的配置</p>
<p><img src="/images/1629734336440.png"></p>

        <h5 id="步骤5-在配置文件中完成bean的配置"   >
          <a href="#步骤5-在配置文件中完成bean的配置" class="heading-link"><i class="fas fa-link"></i></a>步骤5:在配置文件中完成bean的配置</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>&#x3D;&#x3D;注意事项：bean定义时id属性在同一个上下文中(配置文件)不能重复&#x3D;&#x3D;</strong></p>

        <h5 id="步骤6-获取IOC容器"   >
          <a href="#步骤6-获取IOC容器" class="heading-link"><i class="fas fa-link"></i></a>步骤6:获取IOC容器</h5>
      <p>使用Spring提供的接口完成IOC容器的创建，创建App类，编写main方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤7-从容器中获取对象进行方法调用"   >
          <a href="#步骤7-从容器中获取对象进行方法调用" class="heading-link"><i class="fas fa-link"></i></a>步骤7:从容器中获取对象进行方法调用</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">		<span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); </span><br><span class="line"><span class="comment">//        BookDao bookDao = (BookDao) ctx.getBean(&quot;bookDao&quot;);</span></span><br><span class="line"><span class="comment">//        bookDao.save();</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤8-运行程序"   >
          <a href="#步骤8-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤8:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>Spring的IOC入门案例已经完成，但是在<code>BookServiceImpl</code>的类中依然存在<code>BookDaoImpl</code>对象的new操作，它们之间的耦合度还是比较高，这块该如何解决，就需要用到下面的<code>DI:依赖注入</code>。</p>

        <h3 id="3-2-DI入门案例"   >
          <a href="#3-2-DI入门案例" class="heading-link"><i class="fas fa-link"></i></a>3.2 DI入门案例</h3>
      <p>对于DI的入门案例，我们依然先<code>分析思路</code>然后再<code>代码实现</code>，</p>

        <h4 id="3-2-1-入门案例思路分析"   >
          <a href="#3-2-1-入门案例思路分析" class="heading-link"><i class="fas fa-link"></i></a>3.2.1 入门案例思路分析</h4>
      <p>(1)要想实现依赖注入，必须要基于IOC管理Bean</p>
<ul>
<li>DI的入门案例要依赖于前面IOC的入门案例</li>
</ul>
<p>(2)Service中使用new形式创建的Dao对象是否保留?</p>
<ul>
<li>需要删除掉，最终要使用IOC容器中的bean对象</li>
</ul>
<p>(3)Service中需要的Dao对象如何进入到Service中?</p>
<ul>
<li>在Service中提供方法，让Spring的IOC容器可以通过该方法传入bean对象</li>
</ul>
<p>(4)Service与Dao间的关系如何描述?</p>
<ul>
<li>使用配置文件</li>
</ul>

        <h4 id="3-2-2-入门案例代码实现"   >
          <a href="#3-2-2-入门案例代码实现" class="heading-link"><i class="fas fa-link"></i></a>3.2.2 入门案例代码实现</h4>
      <blockquote>
<p>需求:基于IOC入门案例，在BookServiceImpl类中删除new对象的方式，使用Spring的DI完成Dao层的注入</p>
<p>1.删除业务层中使用new的方式创建的dao对象</p>
<p>2.在业务层提供BookDao的setter方法</p>
<p>3.在配置文件中添加依赖注入的配置</p>
<p>4.运行程序调用方法</p>
</blockquote>

        <h5 id="步骤1-去除代码中的new"   >
          <a href="#步骤1-去除代码中的new" class="heading-link"><i class="fas fa-link"></i></a>步骤1: 去除代码中的new</h5>
      <p>在BookServiceImpl类中，删除业务层中使用new的方式创建的dao对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-为属性提供setter方法"   >
          <a href="#步骤2-为属性提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤2:为属性提供setter方法</h5>
      <p>在BookServiceImpl类中,为BookDao提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//删除业务层中使用new的方式创建的dao对象</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-修改配置完成注入"   >
          <a href="#步骤3-修改配置完成注入" class="heading-link"><i class="fas fa-link"></i></a>步骤3:修改配置完成注入</h5>
      <p>在配置文件中添加依赖注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    	id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    	class属性表示给bean定义类型</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        		name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        		ref属性表示参照哪一个bean</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意:配置中的两个bookDao的含义是不一样的&#x3D;&#x3D;</p>
<ul>
<li>name&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring的IOC容器在获取到名称后，将首字母大写，前面加set找对应的<code>setBookDao()</code>方法进行对象注入</li>
<li>ref&#x3D;”bookDao”中<code>bookDao</code>的作用是让Spring能在IOC容器中找到id为<code>bookDao</code>的Bean对象给<code>bookService</code>进行注入</li>
<li>综上所述，对应关系如下:</li>
</ul>
<p><img src="/images/1629736314989.png"></p>

        <h5 id="步骤4-运行程序"   >
          <a href="#步骤4-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤4:运行程序</h5>
      <p>运行，测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>

        <h2 id="4，IOC相关内容"   >
          <a href="#4，IOC相关内容" class="heading-link"><i class="fas fa-link"></i></a>4，IOC相关内容</h2>
      <p>通过前面两个案例，我们已经学习了<code>bean如何定义配置</code>，<code>DI如何定义配置</code>以及<code>容器对象如何获取</code>的内容，接下来主要是把这三块内容展开进行详细的讲解，深入的学习下这三部分的内容，首先是bean基础配置。</p>

        <h3 id="4-1-bean基础配置"   >
          <a href="#4-1-bean基础配置" class="heading-link"><i class="fas fa-link"></i></a>4.1 bean基础配置</h3>
      <p>对于bean的配置中，主要会讲解<code>bean基础配置</code>,<code>bean的别名配置</code>,<code>bean的作用范围配置</code>&#x3D;&#x3D;(重点)&#x3D;&#x3D;,这三部分内容：</p>

        <h4 id="4-1-1-bean基础配置-id与class"   >
          <a href="#4-1-1-bean基础配置-id与class" class="heading-link"><i class="fas fa-link"></i></a>4.1.1 bean基础配置(id与class)</h4>
      <p>对于bean的基础配置，在前面的案例中已经使用过:</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>其中，bean标签的功能、使用方式以及id和class属性的作用，我们通过一张图来描述下</p>
<p><img src="/images/image-20210729183500978.png"></p>
<p>这其中需要大家重点掌握的是:&#x3D;&#x3D;bean标签的id和class属性的使用&#x3D;&#x3D;。</p>
<p><strong>思考：</strong></p>
<ul>
<li>class属性能不能写接口如<code>BookDao</code>的类全名呢?</li>
</ul>
<p>答案肯定是不行，因为接口是没办法创建对象的。</p>
<ul>
<li>前面提过为bean设置id时，id必须唯一，但是如果由于命名习惯而产生了分歧后，该如何解决?</li>
</ul>
<p>在解决这个问题之前，我们需要准备下开发环境，对于开发环境我们可以有两种解决方案:</p>
<ul>
<li><p>使用前面IOC和DI的案例</p>
</li>
<li><p>重新搭建一个新的案例环境,目的是方便大家查阅代码</p>
<ul>
<li><p>搭建的内容和前面的案例是一样的，内容如下：</p>
<p><img src="/images/1629769227068.png"></p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-1-2-bean的name属性"   >
          <a href="#4-1-2-bean的name属性" class="heading-link"><i class="fas fa-link"></i></a>4.1.2 bean的name属性</h4>
      <p>环境准备好后，接下来就可以在这个环境的基础上来学习下bean的别名配置，</p>
<p>首先来看下别名的配置说明:</p>
<p><img src="/images/image-20210729183558051.png"></p>

        <h5 id="步骤1：配置别名"   >
          <a href="#步骤1：配置别名" class="heading-link"><i class="fas fa-link"></i></a>步骤1：配置别名</h5>
      <p>打开spring的配置文件applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--name:为bean指定别名，别名可以有多个，使用逗号，分号，空格进行分隔--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">name</span>=<span class="string">&quot;service service4 bookEbi&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--scope：为bean设置作用范围，可选值为单例singloton，非单例prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:Ebi全称Enterprise Business Interface，翻译为企业业务接口</strong></p>

        <h5 id="步骤2-根据名称容器中获取bean对象"   >
          <a href="#步骤2-根据名称容器中获取bean对象" class="heading-link"><i class="fas fa-link"></i></a>步骤2:根据名称容器中获取bean对象</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForName</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//此处根据bean标签的id属性和name属性的任意一个值来获取bean对象</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;service4&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序"   >
          <a href="#步骤3-运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>测试结果为：</p>
<p><img src="/images/image-20210729184337603.png"></p>
<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>bean依赖注入的ref属性指定bean，必须在容器中存在</p>
<p><img src="/images/1629771744003.png"></p>
</li>
<li><p>如果不存在,则会报错，如下:</p>
<p><img src="/images/1629771880920.png"></p>
<p>这个错误大家需要特别关注下:</p>
<p><img src="/images/1629771972886.png"></p>
<p>获取bean无论是通过id还是name获取，如果无法获取到，将抛出异常&#x3D;&#x3D;NoSuchBeanDefinitionException&#x3D;&#x3D;</p>
</li>
</ul>

        <h4 id="4-1-3-bean作用范围scope配置"   >
          <a href="#4-1-3-bean作用范围scope配置" class="heading-link"><i class="fas fa-link"></i></a>4.1.3 bean作用范围scope配置</h4>
      <p>关于bean的作用范围是bean属性配置的一个&#x3D;&#x3D;重点&#x3D;&#x3D;内容。</p>
<p>看到这个作用范围，我们就得思考bean的作用范围是来控制bean哪块内容的?</p>
<p>我们先来看下<code>bean作用范围的配置属性</code>:</p>
<p><img src="/images/image-20210729183628138.png"></p>

        <h5 id="4-1-3-1-验证IOC容器中对象是否为单例"   >
          <a href="#4-1-3-1-验证IOC容器中对象是否为单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.1 验证IOC容器中对象是否为单例</h5>
      
        <h6 id="验证思路"   >
          <a href="#验证思路" class="heading-link"><i class="fas fa-link"></i></a>验证思路</h6>
      <p>​	同一个bean获取两次，将对象打印到控制台，看打印出的地址值是否一致。</p>

        <h6 id="具体实现"   >
          <a href="#具体实现" class="heading-link"><i class="fas fa-link"></i></a>具体实现</h6>
      <ul>
<li><p>创建一个AppForScope的类，在其main方法中来验证</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForScope</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao1</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao2</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        System.out.println(bookDao1);</span><br><span class="line">        System.out.println(bookDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>打印，观察控制台的打印结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>结论:默认情况下，Spring创建的bean对象都是单例的</p>
</li>
</ul>
<p>获取到结论后，问题就来了，那如果我想创建出来非单例的bean对象，该如何实现呢?</p>

        <h5 id="4-1-3-2-配置bean为非单例"   >
          <a href="#4-1-3-2-配置bean为非单例" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.2 配置bean为非单例</h5>
      <p>在Spring配置文件中，配置scope属性来实现bean的非单例创建</p>
<ul>
<li><p>在Spring的配置文件中，修改<code>&lt;bean&gt;</code>的scope属性</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>将scope设置为<code>singleton</code></p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772538893.png"></p>
</li>
<li><p>将scope设置为<code>prototype</code></p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;bookDao&quot; name=&quot;dao&quot; class=&quot;com.itheima.dao.impl.BookDaoImpl&quot; scope=&quot;prototype&quot;/&gt;</span><br></pre></td></tr></table></div></figure>

<p>运行AppForScope，打印看结果</p>
<p><img src="/images/1629772928714.png"></p>
</li>
<li><p>结论，使用bean的<code>scope</code>属性可以控制bean的创建是否为单例：</p>
<ul>
<li><code>singleton</code>默认为单例</li>
<li><code>prototype</code>为非单例</li>
</ul>
</li>
</ul>

        <h5 id="4-1-3-3-scope使用后续思考"   >
          <a href="#4-1-3-3-scope使用后续思考" class="heading-link"><i class="fas fa-link"></i></a>4.1.3.3 scope使用后续思考</h5>
      <p>介绍完<code>scope</code>属性以后，我们来思考几个问题:</p>
<ul>
<li><p>为什么bean默认为单例?</p>
<ul>
<li>bean为单例的意思是在Spring的IOC容器中<strong>只会有该类的一个对象</strong></li>
<li>bean对象只有一个就<strong>避免了对象的频繁创建与销毁</strong>，达到了bean对象的<strong>复用，性能高</strong></li>
</ul>
</li>
<li><p>bean在容器中是单例的，会不会产生<strong>线程安全</strong>问题?</p>
<ul>
<li><p>如果对象是<mark>有状态</mark>对象，即该对象有成员变量可以用来存储数据的，</p>
<p>因为所有请求线程共用一个bean对象，所以会存在线程安全问题。</p>
</li>
<li><p>如果对象是<mark>无状态</mark>对象，即该对象没有成员变量没有进行数据存储的，</p>
<p>因方法中的<strong>局部变量在方法调用完成后会被销毁</strong>，所以不会存在线程安全问题。</p>
</li>
</ul>
</li>
<li><p>哪些bean对象适合交给容器进行管理?</p>
<ul>
<li>表现层对象</li>
<li>业务层对象</li>
<li>数据层对象</li>
<li>工具对象</li>
</ul>
</li>
<li><p>哪些bean对象不适合交给容器进行管理?</p>
<ul>
<li>封装<strong>实例</strong>的域对象，因为会引发线程安全问题，所以不适合。</li>
</ul>
</li>
</ul>

        <h4 id="4-14-bean基础配置小结"   >
          <a href="#4-14-bean基础配置小结" class="heading-link"><i class="fas fa-link"></i></a>4.14 bean基础配置小结</h4>
      <p>关于bean的基础配置中，需要大家掌握以下属性:</p>
<p><img src="/images/1631529887695.png"></p>

        <h3 id="4-2-bean实例化"   >
          <a href="#4-2-bean实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2 bean实例化</h3>
      <p>对象已经能交给Spring的IOC容器来创建了，但是容器是如何来创建对象的呢?</p>
<p>就需要研究下<code>bean的实例化过程</code>，在这块内容中主要解决两部分内容，分别是</p>
<ul>
<li>bean是如何创建的</li>
<li>实例化bean的三种方式，<code>构造方法(重点)</code>,<code>静态工厂</code>，<code>实例工厂()</code>，<code>FactoryBean()(重点)</code></li>
</ul>
<p>在讲解这三种创建方式之前，我们需要先确认一件事:</p>
<p>bean本质上就是对象，对象在new的时候会使用构造方法完成，那创建bean也是使用构造方法完成的。</p>
<p>基于这个知识点出发，我们来验证spring中bean的三种创建方式，</p>

        <h4 id="4-2-1-环境准备"   >
          <a href="#4-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.1 环境准备</h4>
      <p>为了方便大家阅读代码，重新准备个开发环境，</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629775585694.png"></p>

        <h4 id="4-2-2-构造方法实例化"   >
          <a href="#4-2-2-构造方法实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.2 构造方法实例化</h4>
      <p>在上述的环境下，我们来研究下Spring中的第一种bean的创建方式<code>构造方法实例化</code>:</p>

        <h5 id="步骤1-准备需要被创建的类"   >
          <a href="#步骤1-准备需要被创建的类" class="heading-link"><i class="fas fa-link"></i></a>步骤1:准备需要被创建的类</h5>
      <p>准备一个BookDao和BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-将类配置到Spring容器"   >
          <a href="#步骤2-将类配置到Spring容器" class="heading-link"><i class="fas fa-link"></i></a>步骤2:将类配置到Spring容器</h5>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-编写运行程序"   >
          <a href="#步骤3-编写运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3:编写运行程序</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceBook</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤4-类中提供构造函数测试"   >
          <a href="#步骤4-类中提供构造函数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤4:类中提供构造函数测试</h5>
      <p>在BookDaoImpl类中添加一个无参构造函数，并打印一句话，方便观察结果。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，如果控制台有打印构造函数中的输出，说明Spring容器在创建对象的时候也走的是构造函数</p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤5-将构造函数改成private测试"   >
          <a href="#步骤5-将构造函数改成private测试" class="heading-link"><i class="fas fa-link"></i></a>步骤5:将构造函数改成private测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，能执行成功,说明内部走的依然是构造函数,能访问到类中的私有构造方法,因为无论私有公有都能够被访问，所以我们可以说，<strong>Spring底层用的是反射</strong></p>
<p><img src="/images/1629775972507.png"></p>

        <h5 id="步骤6-构造函数中添加一个参数测试"   >
          <a href="#步骤6-构造函数中添加一个参数测试" class="heading-link"><i class="fas fa-link"></i></a>步骤6:构造函数中添加一个参数测试</h5>
      <figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BookDaoImpl</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao constructor is running ....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>运行程序，</p>
<p>程序会报错，说明Spring底层使用的是<strong>类的无参构造方法</strong>。</p>
<p>（原因：有参构造器通常意味着类要进行实例化，而实例化的类在IOC的单例模式下很容易造成线程安全问题，所以IOC拒绝访问有参构造器生成的对象）</p>
<p><img src="/images/1629776331499.png"></p>
<p><mark>底层是运用反射获取类的无参构造器来构造类的单例对象。</mark></p>

        <h4 id="4-2-3-分析Spring的错误信息-简单看看就好了"   >
          <a href="#4-2-3-分析Spring的错误信息-简单看看就好了" class="heading-link"><i class="fas fa-link"></i></a>4.2.3 分析Spring的错误信息(简单看看就好了)</h4>
      <p>接下来，我们主要研究下Spring的报错信息来学一学如阅读。</p>
<ul>
<li><p>错误信息从下往上依次查看，因为上面的错误大都是对下面错误的一个包装，最核心错误是在最下面</p>
<blockquote>
<p>Caused by: java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>Caused by 翻译为<code>引起</code>，即出现错误的原因</li>
<li>java.lang.NoSuchMethodException:抛出的异常为<code>没有这样的方法异常</code></li>
<li>com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>():哪个类的哪个方法没有被找到导致的异常，<code>&lt;init&gt;</code>()指定是类的构造方法，即该类的无参构造方法</li>
</ul>
</li>
</ul>
<p>如果最后一行错误获取不到错误信息，接下来查看第二层:</p>
<blockquote>
<p> Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()</p>
</blockquote>
<ul>
<li>nested:嵌套的意思，后面的异常内容和最底层的异常是一致的<ul>
<li>Caused by: org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; <ul>
<li>Caused by: <code>引发</code></li>
<li>BeanInstantiationException:翻译为<code>bean实例化异常</code></li>
<li>No default constructor found:没有一个默认的构造函数被发现</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>看到这其实错误已经比较明显，给大家个练习，把倒数第三层的错误分析下吧:</p>
<blockquote>
<p> Exception in thread “main” org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘bookDao’ defined in class path resource [applicationContext.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.itheima.dao.impl.BookDaoImpl]: No default constructor found; nested exception is java.lang.NoSuchMethodException: com.itheima.dao.impl.BookDaoImpl.<code>&lt;init&gt;</code>()。</p>
</blockquote>
<p>至此，关于Spring的构造方法实例化就已经学习完了，因为每一个类默认都会提供一个无参构造函数，所以其实真正在使用这种方式的时候，我们什么也不需要做。这也是我们以后比较常用的一种方式。</p>

        <h4 id="4-2-4-静态工厂实例化"   >
          <a href="#4-2-4-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4 静态工厂实例化</h4>
      <p>接下来研究Spring中的第二种bean的创建方式<code>静态工厂实例化</code>:</p>

        <h5 id="4-2-4-1-工厂方式创建bean"   >
          <a href="#4-2-4-1-工厂方式创建bean" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.1 工厂方式创建bean</h5>
      <p>在讲这种方式之前，我们需要先回顾一个知识点是使用工厂来创建对象的方式:</p>
<p>(1)准备一个OrderDao和OrderDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;order dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个&#x3D;&#x3D;静态方法&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态工厂创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceOrder运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//通过静态工厂创建对象</span></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> OrderDaoFactory.getOrderDao();</span><br><span class="line">        orderDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>如果代码中对象是通过上面的这种方式来创建的，如何将其交给Spring来管理呢?</p>

        <h5 id="4-2-4-2-静态工厂实例化"   >
          <a href="#4-2-4-2-静态工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.4.2 静态工厂实例化</h5>
      <p>这就要用到Spring中的静态工厂实例化的知识了，具体实现步骤为:</p>
<p>(1)在spring的配置文件application.properties中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orderDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.OrderDaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getOrderDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>class:工厂类的类全名</p>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>对应关系如下图:</p>
<p><img src="/images/image-20210729195248948.png"></p>
<p>(2)在AppForInstanceOrder运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">OrderDao</span> <span class="variable">orderDao</span> <span class="operator">=</span> (OrderDao) ctx.getBean(<span class="string">&quot;orderDao&quot;</span>);</span><br><span class="line"></span><br><span class="line">        orderDao.save();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629786862329.png"></p>
<p>看到这，可能有人会问了，你这种方式在工厂类中不也是直接new对象的，和我自己直接new没什么太大的区别，而且静态工厂的方式反而更复杂，这种方式的意义是什么?</p>
<p>主要的原因是:</p>
<ul>
<li>在工厂的静态方法中，我们除了new对象还可以做其他的一些业务操作，这些操作必不可少,如:</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> OrderDao <span class="title function_">getOrderDao</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;factory setup....&quot;</span>);<span class="comment">//模拟必要的业务操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OrderDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>之前new对象的方式就无法添加其他的业务内容，重新运行，查看结果:</p>
<p><img src="/images/1629788036885.png"></p>
<p>介绍完静态工厂实例化后，这种方式一般是用来兼容早期的一些老系统，所以&#x3D;&#x3D;了解为主&#x3D;&#x3D;。</p>

        <h4 id="4-2-5-实例工厂与FactoryBean"   >
          <a href="#4-2-5-实例工厂与FactoryBean" class="heading-link"><i class="fas fa-link"></i></a>4.2.5 实例工厂与FactoryBean</h4>
      <p>接下来继续来研究Spring的第三种bean的创建方式<code>实例工厂实例化</code>:</p>

        <h5 id="4-2-3-1-环境准备"   >
          <a href="#4-2-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.1 环境准备</h5>
      <p>(1)准备一个UserDao和UserDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)创建一个工厂类OrderDaoFactory并提供一个普通方法，注意此处和静态工厂的工厂类不一样的地方是方法不是静态方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForInstanceUser运行类，在类中通过工厂获取对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建实例工厂对象</span></span><br><span class="line">        <span class="type">UserDaoFactory</span> <span class="variable">userDaoFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoFactory</span>();</span><br><span class="line">        <span class="comment">//通过实例工厂对象创建对象</span></span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> userDaoFactory.getUserDao();</span><br><span class="line">        userDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(4)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>对于上面这种实例工厂的方式如何交给Spring管理呢?</p>

        <h5 id="4-2-3-2-实例工厂实例化"   >
          <a href="#4-2-3-2-实例工厂实例化" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.2 实例工厂实例化</h5>
      <p>具体实现步骤为:</p>
<p>(1)在spring的配置文件中添加以下内容:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;userFactory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>实例化工厂运行的顺序是:</p>
<ul>
<li><p>创建实例化工厂对象,对应的是第一行配置</p>
</li>
<li><p>调用对象中的方法来创建bean，对应的是第二行配置</p>
<ul>
<li><p>factory-bean:工厂的实例对象</p>
</li>
<li><p>factory-method:工厂对象中的具体创建对象的方法名,对应关系如下:</p>
<p><img src="/images/image-20210729200203249.png"></p>
</li>
</ul>
</li>
</ul>
<p>factory-mehod:具体工厂类中创建对象的方法名</p>
<p>(2)在AppForInstanceUser运行类，使用从IOC容器中获取bean的方法进行运行测试</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(3)运行后，可以查看到结果</p>
<p><img src="/images/1629788769436.png"></p>
<p>实例工厂实例化的方式就已经介绍完了，配置的过程还是比较复杂，所以Spring为了简化这种配置方式就提供了一种叫<code>FactoryBean</code>的方式来简化开发。</p>

        <h5 id="4-2-3-3-FactoryBean的使用"   >
          <a href="#4-2-3-3-FactoryBean的使用" class="heading-link"><i class="fas fa-link"></i></a>4.2.3.3 FactoryBean的使用</h5>
      <p>具体的使用步骤为:</p>
<p>(1)创建一个UserDaoFactoryBean的类，实现FactoryBean接口，重写接口的方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)在Spring的配置文件中进行配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)AppForInstanceUser运行类不用做任何修改，直接运行</p>
<p><img src="/images/1629788769436.png"></p>
<p>这种方式在Spring去整合其他框架的时候会被用到，所以这种方式需要大家理解掌握。</p>
<p>查看源码会发现，FactoryBean接口其实会有三个方法，分别是:</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>方法一:getObject()，被重写后，在方法中进行对象的创建并返回</p>
<p>方法二:getObjectType(),被重写后，主要返回的是被创建类的Class对象</p>
<p>方法三:没有被重写，因为它已经给了默认值，从方法名中可以看出其作用是设置对象是否为单例，默认true，从意思上来看，我们猜想默认应该是单例，如何来验证呢?</p>
<p>思路很简单，就是从容器中获取该对象的多个值，打印到控制台，查看是否为同一个对象。</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForInstanceUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">            <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) ctx.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        System.out.println(userDao1);</span><br><span class="line">        System.out.println(userDao2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>打印结果，如下:</p>
<p><img src="/images/1629790070607.png"></p>
<p>通过验证，会发现默认是单例，那如果想改成单例具体如何实现?</p>
<p>只需要将isSingleton()方法进行重写，修改返回为false，即可</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FactoryBean创建对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForInstanceUser，查看结果</p>
<p><img src="/images/1629790197860.png"></p>
<p>从结果中可以看出现在已经是非单例了，但是一般情况下我们都会采用单例，也就是采用默认即可。所以isSingleton()方法一般不需要进行重写。</p>

        <h4 id="4-2-6-bean实例化小结"   >
          <a href="#4-2-6-bean实例化小结" class="heading-link"><i class="fas fa-link"></i></a>4.2.6 bean实例化小结</h4>
      <p>通过这一节的学习，需要掌握:</p>
<p>(1)bean是如何创建的呢?</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造方法</span><br></pre></td></tr></table></div></figure>

<p>(2)Spring的IOC实例化对象的三种方式分别是:</p>
<ul>
<li>构造方法(常用)</li>
<li>静态工厂(了解)</li>
<li>实例工厂(了解)<ul>
<li>FactoryBean(实用)</li>
</ul>
</li>
</ul>
<p>这些方式中，重点掌握<code>构造方法</code>和<code>FactoryBean</code>即可。</p>
<p>需要注意的一点是，构造方法在类中默认会提供，但是如果重写了构造方法，默认的就会消失，在使用的过程中需要注意，如果需要重写构造方法，最好把默认的构造方法也重写下。</p>

        <h3 id="4-3-bean的生命周期"   >
          <a href="#4-3-bean的生命周期" class="heading-link"><i class="fas fa-link"></i></a>4.3 bean的生命周期</h3>
      <p>关于bean的相关知识还有最后一个是<code>bean的生命周期</code>,对于生命周期，我们主要围绕着<code>bean生命周期控制</code>来讲解:</p>
<ul>
<li>首先理解下什么是生命周期?<ul>
<li>从创建到消亡的完整过程,例如人<strong>从出生到死亡</strong>的整个过程就是一个生命周期。</li>
</ul>
</li>
<li>bean生命周期是什么?<ul>
<li>bean对象从创建到销毁的整体过程。</li>
</ul>
</li>
<li>bean生命周期控制是什么?<ul>
<li>在bean创建后到销毁前做一些事情。</li>
</ul>
</li>
</ul>
<p>现在我们面临的问题是如何在bean的创建之后和销毁之前把我们需要添加的内容添加进去。</p>

        <h4 id="4-3-1-环境准备"   >
          <a href="#4-3-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>4.3.1 环境准备</h4>
      <p>还是老规矩，为了方便大家后期代码的阅读，我们重新搭建下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629791473409.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForLifeCycle运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForLifeCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">        	<span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="4-3-2-生命周期设置"   >
          <a href="#4-3-2-生命周期设置" class="heading-link"><i class="fas fa-link"></i></a>4.3.2 生命周期设置</h4>
      <p>接下来，在上面这个环境中来为BookDao添加生命周期的控制方法，具体的控制有两个阶段:</p>
<ul>
<li>bean<strong>创建之后</strong>，想要添加内容，比如用<strong>来初始化需要用到资源</strong></li>
<li>bean销毁之前，想要添加内容，比如用来释放用到的资源</li>
</ul>

        <h5 id="步骤1-添加初始化和销毁方法"   >
          <a href="#步骤1-添加初始化和销毁方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加初始化和销毁方法</h5>
      <p>针对这两个阶段，我们在BooDaoImpl类中分别添加两个方法，&#x3D;&#x3D;方法名任意&#x3D;&#x3D;</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean初始化对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示bean销毁前对应的操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置生命周期"   >
          <a href="#步骤2-配置生命周期" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置生命周期</h5>
      <p>在配置文件添加配置，如下:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-1"   >
          <a href="#步骤3-运行程序-1" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForLifeCycle打印结果为:</p>
<p><img src="/images/1629792339889.png"></p>
<p>从结果中可以看出，init方法执行了，但是destroy方法却未执行，这是为什么呢?</p>
<ul>
<li>Spring的IOC容器是运行在JVM中</li>
<li>运行main方法后,JVM启动,Spring加载配置文件生成IOC容器,从容器获取bean对象，然后调方法执行</li>
<li>main方法执行完后，JVM退出，这个时候IOC容器中的bean还没有来得及销毁就已经结束了</li>
<li>所以没有调用对应的destroy方法</li>
</ul>
<p>知道了出现问题的原因，具体该如何解决呢?</p>

        <h4 id="4-3-3-close关闭容器"   >
          <a href="#4-3-3-close关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.3 close关闭容器</h4>
      <ul>
<li><p>ApplicationContext中没有close方法</p>
</li>
<li><p>需要将ApplicationContext更换成ClassPathXmlApplicationContext</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>调用ctx的close()方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.close();</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>运行程序，就能执行destroy方法的内容</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>

        <h4 id="4-3-4-注册钩子关闭容器"   >
          <a href="#4-3-4-注册钩子关闭容器" class="heading-link"><i class="fas fa-link"></i></a>4.3.4 注册钩子关闭容器</h4>
      <ul>
<li><p>在容器未关闭之前，提前设置好回调函数，让JVM在退出之前回调此函数来关闭容器</p>
</li>
<li><p>调用ctx的<code>registerShutdownHook()</code>方法</p>
<figure class="highlight plaintext"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.registerShutdownHook();</span><br></pre></td></tr></table></div></figure>

<p>**注意:**registerShutdownHook在ApplicationContext中也没有</p>
</li>
<li><p>运行后，查询打印结果</p>
<p><img src="/images/1629792857608.png"></p>
</li>
</ul>
<p>两种方式介绍完后，close和registerShutdownHook选哪个?</p>
<p>相同点:这两种都能用来关闭容器</p>
<p>不同点:close()是在调用的时候关闭，registerShutdownHook()是在JVM退出前调用关闭。</p>
<p>分析上面的实现过程，会发现添加初始化和销毁方法，即需要编码也需要配置，实现起来步骤比较多也比较乱。</p>
<p>Spring提供了两个接口来完成生命周期的控制，好处是可以不用再进行配置<code>init-method</code>和<code>destroy-method</code></p>
<p>接下来在BookServiceImpl完成这两个接口的使用:</p>
<p>修改BookServiceImpl类，添加两个接口<code>InitializingBean</code>， <code>DisposableBean</code>并实现接口中的两个方法<code>afterPropertiesSet</code>和<code>destroy</code></p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service destroy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>重新运行AppForLifeCycle类，</p>
<p><img src="/images/1629794527419.png"></p>
<p>那第二种方式的实现，我们也介绍完了。</p>
<p><strong>小细节</strong></p>
<ul>
<li><p>对于InitializingBean接口中的afterPropertiesSet方法，翻译过来为<code>属性设置之后</code>。</p>
</li>
<li><p>对于BookServiceImpl来说，bookDao是它的一个属性</p>
</li>
<li><p>setBookDao方法是Spring的IOC容器为其注入属性的方法</p>
</li>
<li><p>思考:afterPropertiesSet和setBookDao谁先执行?</p>
<ul>
<li><p>从方法名分析，猜想应该是setBookDao方法先执行</p>
</li>
<li><p>验证思路，在setBookDao方法中添加一句话</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;set .....&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>重新运行AppForLifeCycle，打印结果如下:</p>
<p><img src="/images/1629794928636.png"></p>
<p>验证的结果和我们猜想的结果是一致的，所以初始化方法会在类中属性设置之后执行。</p>
</li>
</ul>
</li>
</ul>

        <h4 id="4-3-5-bean生命周期小结"   >
          <a href="#4-3-5-bean生命周期小结" class="heading-link"><i class="fas fa-link"></i></a>4.3.5 bean生命周期小结</h4>
      <p>(1)关于Spring中对bean生命周期控制提供了两种方式:</p>
<ul>
<li>在配置文件中的bean标签中添加<code>init-method</code>和<code>destroy-method</code>属性</li>
<li>类实现<code>InitializingBean</code>与<code>DisposableBean</code>接口，这种方式了解下即可。</li>
</ul>
<p>(2)对于bean的生命周期控制在bean的整个生命周期中所处的位置如下:</p>
<ul>
<li>初始化容器<ul>
<li>1.创建对象(内存分配)</li>
<li>2.执行构造方法</li>
<li>3.执行属性注入(set操作)</li>
<li>&#x3D;&#x3D;4.执行bean初始化方法&#x3D;&#x3D;</li>
</ul>
</li>
<li>使用bean<ul>
<li>1.执行业务操作</li>
</ul>
</li>
<li>关闭&#x2F;销毁容器<ul>
<li>&#x3D;&#x3D;1.执行bean销毁方法&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p>(3)关闭容器的两种方式:</p>
<ul>
<li>ConfigurableApplicationContext是ApplicationContext的子类<ul>
<li>close()方法</li>
<li>registerShutdownHook()方法</li>
</ul>
</li>
</ul>

        <h2 id="5，DI相关内容"   >
          <a href="#5，DI相关内容" class="heading-link"><i class="fas fa-link"></i></a>5，DI相关内容</h2>
      <p>前面我们已经完成了bean相关操作的讲解，接下来就进入第二个大的模块<code>DI依赖注入</code>，首先来介绍下Spring中有哪些注入方式?</p>
<p>我们先来思考</p>
<ul>
<li>向一个类中传递数据的方式有几种?<ul>
<li>普通方法(set方法)</li>
<li>构造方法</li>
</ul>
</li>
<li>依赖注入描述了在容器中建立bean与bean之间的依赖关系的过程，如果bean运行需要的是数字或字符串呢?<ul>
<li>引用类型</li>
<li>简单类型(基本数据类型与String)</li>
</ul>
</li>
</ul>
<p>Spring就是基于上面这些知识点，为我们提供了两种注入方式，分别是:</p>
<ul>
<li>setter注入<ul>
<li>简单类型</li>
<li>&#x3D;&#x3D;引用类型&#x3D;&#x3D;</li>
</ul>
</li>
<li>构造器注入<ul>
<li>简单类型</li>
<li>引用类型</li>
</ul>
</li>
</ul>
<p>依赖注入的方式已经介绍完，接下来挨个学习下:</p>

        <h3 id="5-1-setter注入"   >
          <a href="#5-1-setter注入" class="heading-link"><i class="fas fa-link"></i></a>5.1 setter注入</h3>
      <ol>
<li>对于setter方式注入引用类型的方式之前已经学习过，快速回顾下:</li>
</ol>
<ul>
<li>在bean中定义引用类型属性，并提供可访问的&#x3D;&#x3D;set&#x3D;&#x3D;方法</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>配置中使用&#x3D;&#x3D;property&#x3D;&#x3D;标签&#x3D;&#x3D;ref&#x3D;&#x3D;属性注入引用类型对象</li>
</ul>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.imipl.BookDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-1-1-环境准备"   >
          <a href="#5-1-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.1.1 环境准备</h4>
      <p>为了更好的学习下面内容，我们依旧准备一个新环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629799214191.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDISet运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDISet</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成setter注入的学习:</p>

        <h4 id="5-1-2-注入引用数据类型"   >
          <a href="#5-1-2-注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.2 注入引用数据类型</h4>
      <blockquote>
<p>需求:在bookServiceImpl对象中注入userDao</p>
<p>1.在BookServiceImpl中声明userDao属性</p>
<p>2.为userDao属性提供setter方法</p>
<p>3.在配置文件中使用property标签注入</p>
</blockquote>

        <h5 id="步骤1-声明属性并提供setter方法"   >
          <a href="#步骤1-声明属性并提供setter方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookServiceImpl中声明userDao属性，并提供setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置"   >
          <a href="#步骤2-配置文件中进行注入配置" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤3-运行程序-2"   >
          <a href="#步骤3-运行程序-2" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629799873386.png"></p>

        <h4 id="5-1-3-注入简单数据类型"   >
          <a href="#5-1-3-注入简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.1.3 注入简单数据类型</h4>
      <blockquote>
<p>需求：给BookDaoImpl注入一些简单数据类型的数据</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.在BookDaoImpl类中声明对应的简单数据类型的属性</p>
<p>2.为这些属性提供对应的setter方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>
<p><strong>思考:</strong></p>
<p>引用类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code>,简单数据类型还是使用ref么?</p>
<p>ref是指向Spring的IOC容器中的另一个bean对象的，对于简单数据类型，没有对应的bean对象，该如何配置?</p>

        <h5 id="步骤1-声明属性并提供setter方法-1"   >
          <a href="#步骤1-声明属性并提供setter方法-1" class="heading-link"><i class="fas fa-link"></i></a>步骤1:声明属性并提供setter方法</h5>
      <p>在BookDaoImpl类中声明对应的简单数据类型的属性,并提供对应的setter方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setConnectionNum</span><span class="params">(<span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDatabaseName</span><span class="params">(String databaseName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行注入配置-1"   >
          <a href="#步骤2-配置文件中进行注入配置-1" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行注入配置</h5>
      <p>在applicationContext.xml配置文件中使用property标签注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>value:后面跟的是简单数据类型，对于参数类型，Spring在注入的时候会自动转换，但是不能写成</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>这样的话，spring在将<code>abc</code>转换成int类型的时候就会报错。</p>

        <h5 id="步骤3-运行程序-3"   >
          <a href="#步骤3-运行程序-3" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDISet类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629800324721.png"></p>
<p>**注意:**两个property注入标签的顺序可以任意。</p>
<p>对于setter注入方式的基本使用就已经介绍完了，</p>
<ul>
<li>对于引用数据类型使用的是<code>&lt;property name=&quot;&quot; ref=&quot;&quot;/&gt;</code></li>
<li>对于简单数据类型使用的是<code>&lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</code></li>
</ul>

        <h3 id="5-2-构造器注入"   >
          <a href="#5-2-构造器注入" class="heading-link"><i class="fas fa-link"></i></a>5.2 构造器注入</h3>
      
        <h4 id="5-2-1-环境准备"   >
          <a href="#5-2-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.2.1 环境准备</h4>
      <p>构造器注入也就是构造方法注入，学习之前，还是先准备下环境:</p>
<ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629800748639.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、UserDao、UserDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDIConstructor运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDIConstructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-2-2-构造器注入引用数据类型"   >
          <a href="#5-2-2-构造器注入引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.2 构造器注入引用数据类型</h4>
      <p>接下来，在上面这个环境中来完成构造器注入的学习:</p>
<blockquote>
<p>需求：将BookServiceImpl类中的bookDao修改成使用构造器的方式注入。</p>
<p>1.将bookDao的setter方法删除掉</p>
<p>2.添加带有bookDao参数的构造方法</p>
<p>3.在applicationContext.xml中配置</p>
</blockquote>

        <h5 id="步骤1-删除setter方法并提供构造方法"   >
          <a href="#步骤1-删除setter方法并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:删除setter方法并提供构造方法</h5>
      <p>在BookServiceImpl类中将bookDao的setter方法删除掉,并添加带有bookDao参数的构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置文件中进行配置构造方式注入"   >
          <a href="#步骤2-配置文件中进行配置构造方式注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置文件中进行配置构造方式注入</h5>
      <p>在applicationContext.xml中配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p><strong>说明:</strong></p>
<p>标签<constructor-arg>中</p>
<ul>
<li><p>name属性对应的值为构造函数中方法形参的参数名，必须要保持一致。</p>
</li>
<li><p>ref属性指向的是spring的IOC容器中其他bean对象。</p>
</li>
</ul>

        <h5 id="步骤3：运行程序"   >
          <a href="#步骤3：运行程序" class="heading-link"><i class="fas fa-link"></i></a>步骤3：运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明bookDao已经成功注入。</p>
<p><img src="/images/1629802656916.png"></p>

        <h4 id="5-2-3-构造器注入多个引用数据类型"   >
          <a href="#5-2-3-构造器注入多个引用数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.3 构造器注入多个引用数据类型</h4>
      <blockquote>
<p>需求:在BookServiceImpl使用构造函数注入多个引用数据类型，比如userDao</p>
<p>1.声明userDao属性</p>
<p>2.生成一个带有bookDao和userDao参数的构造函数</p>
<p>3.在applicationContext.xml中配置注入</p>
</blockquote>

        <h5 id="步骤1-提供多个属性的构造函数"   >
          <a href="#步骤1-提供多个属性的构造函数" class="heading-link"><i class="fas fa-link"></i></a>步骤1:提供多个属性的构造函数</h5>
      <p>在BookServiceImpl声明userDao并提供多个参数的构造函数</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao,UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>步骤2:配置文件中配置多参数注入</p>
<p>在applicationContext.xml中配置注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-4"   >
          <a href="#步骤3-运行程序-4" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果，说明userDao已经成功注入。</p>
<p><img src="/images/1629802697318.png"></p>

        <h4 id="5-2-4-构造器注入多个简单数据类型"   >
          <a href="#5-2-4-构造器注入多个简单数据类型" class="heading-link"><i class="fas fa-link"></i></a>5.2.4 构造器注入多个简单数据类型</h4>
      <blockquote>
<p>需求:在BookDaoImpl中，使用构造函数注入databaseName和connectionNum两个参数。</p>
<p>参考引用数据类型的注入，我们可以推出具体的步骤为:</p>
<p>1.提供一个包含这两个参数的构造方法</p>
<p>2.在applicationContext.xml中进行注入配置</p>
</blockquote>

        <h5 id="步骤1-添加多个简单属性并提供构造方法"   >
          <a href="#步骤1-添加多个简单属性并提供构造方法" class="heading-link"><i class="fas fa-link"></i></a>步骤1:添加多个简单属性并提供构造方法</h5>
      <p>修改BookDaoImpl类，添加构造方法</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookDaoImpl</span><span class="params">(String databaseName, <span class="type">int</span> connectionNum)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.databaseName = databaseName;</span><br><span class="line">        <span class="built_in">this</span>.connectionNum = connectionNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>+databaseName+<span class="string">&quot;,&quot;</span>+connectionNum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h5 id="步骤2-配置完成多个属性构造器注入"   >
          <a href="#步骤2-配置完成多个属性构造器注入" class="heading-link"><i class="fas fa-link"></i></a>步骤2:配置完成多个属性构造器注入</h5>
      <p>在applicationContext.xml中进行注入配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;databaseName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;connectionNum&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>**说明:**这两个<code>&lt;contructor-arg&gt;</code>的配置顺序可以任意</p>

        <h5 id="步骤3-运行程序-5"   >
          <a href="#步骤3-运行程序-5" class="heading-link"><i class="fas fa-link"></i></a>步骤3:运行程序</h5>
      <p>运行AppForDIConstructor类，查看结果</p>
<p><img src="/images/1629803111769.png"></p>
<p>上面已经完成了构造函数注入的基本使用，但是会存在一些问题:</p>
<p><img src="/images/1629803529598.png"></p>
<ul>
<li>当构造函数中方法的参数名发生变化后，配置文件中的name属性也需要跟着变</li>
<li>这两块存在紧耦合，具体该如何解决?</li>
</ul>
<p>在解决这个问题之前，需要提前说明的是，这个参数名发生变化的情况并不多，所以上面的还是比较主流的配置方式，下面介绍的，大家都以了解为主。</p>
<p>方式一:删除name属性，添加type属性，按照类型注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决构造函数形参名发生变化带来的耦合问题</li>
<li>但是如果构造方法参数中有类型相同的参数，这种方式就不太好实现了</li>
</ul>
<p>方式二:删除type属性，添加index属性，按照索引下标注入，下标从0开始</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mysql&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<ul>
<li>这种方式可以解决参数类型重复问题</li>
<li>但是如果构造方法参数顺序发生变化后，这种方式又带来了耦合问题</li>
</ul>
<p>介绍完两种参数的注入方式，具体我们该如何选择呢?</p>
<ol>
<li>强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<ul>
<li>强制依赖指对象在创建的过程中必须要注入指定的参数</li>
</ul>
</li>
<li>可选依赖使用setter注入进行，灵活性强<ul>
<li>可选依赖指对象在创建过程中注入的参数可有可无</li>
</ul>
</li>
<li>Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨</li>
<li>如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入</li>
<li>实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入</li>
<li><strong>&#x3D;&#x3D;自己开发的模块推荐使用setter注入&#x3D;&#x3D;</strong></li>
</ol>
<p>这节中主要讲解的是Spring的依赖注入的实现方式:</p>
<ul>
<li><p>setter注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>构造器注入</p>
<ul>
<li><p>简单数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure>
</li>
<li><p>引用数据类型</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">index</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure></li>
</ul>
</li>
<li><p>依赖注入的方式选择上</p>
<ul>
<li>建议使用setter注入</li>
<li>第三方技术根据情况选择</li>
</ul>
</li>
</ul>

        <h3 id="5-3-自动配置"   >
          <a href="#5-3-自动配置" class="heading-link"><i class="fas fa-link"></i></a>5.3 自动配置</h3>
      <p>前面花了大量的时间把Spring的注入去学习了下，总结起来就一个字&#x3D;&#x3D;麻烦&#x3D;&#x3D;。</p>
<p>问:麻烦在哪?</p>
<p>答:配置文件的编写配置上。</p>
<p>问:有更简单方式么?</p>
<p>答:有，自动配置</p>
<p>什么是自动配置以及如何实现自动配置，就是接下来要学习的内容：</p>

        <h4 id="5-3-1-什么是依赖自动装配"   >
          <a href="#5-3-1-什么是依赖自动装配" class="heading-link"><i class="fas fa-link"></i></a>5.3.1 什么是依赖自动装配?</h4>
      <ul>
<li>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</li>
</ul>

        <h4 id="5-3-2-自动装配方式有哪些"   >
          <a href="#5-3-2-自动装配方式有哪些" class="heading-link"><i class="fas fa-link"></i></a>5.3.2 自动装配方式有哪些?</h4>
      <ul>
<li>&#x3D;&#x3D;按类型（常用）&#x3D;&#x3D;</li>
<li>按名称</li>
<li>按构造方法</li>
<li>不启用自动装配</li>
</ul>

        <h4 id="5-3-3-准备下案例环境"   >
          <a href="#5-3-3-准备下案例环境" class="heading-link"><i class="fas fa-link"></i></a>5.3.3 准备下案例环境</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629805387647.png"></p>
<p>(1)项目中添加BookDao、BookDaoImpl、BookService和BookServiceImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String databaseName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> connectionNum;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book service save ...&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;bookDao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForAutoware运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAutoware</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) ctx.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h4 id="5-3-4-完成自动装配的配置"   >
          <a href="#5-3-4-完成自动装配的配置" class="heading-link"><i class="fas fa-link"></i></a>5.3.4 完成自动装配的配置</h4>
      <p>接下来，在上面这个环境中来完成<code>自动装配</code>的学习:</p>
<p>自动装配只需要修改applicationContext.xml配置文件即可:</p>
<p>(1)将<code>&lt;property&gt;</code>标签删除</p>
<p>(2)在<code>&lt;bean&gt;</code>标签中添加autowire属性</p>
<p>首先来实现按照类型注入的配置</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li>需要注入属性的类中对应属性的setter方法不能省略</li>
<li>被注入的对象必须要被Spring的IOC容器管理</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报<code>NoUniqueBeanDefinitionException</code></li>
</ul>
<p>一个类型在IOC中有多个对象，还想要注入成功，这个时候就需要按照名称注入，配置方式为:</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire属性：开启自动装配，通常使用按类型装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.BookServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>&#x3D;&#x3D;注意事项:&#x3D;&#x3D;</p>
<ul>
<li><p>按照名称注入中的名称指的是什么?</p>
<p><img src="/images/1629806856156.png"></p>
<ul>
<li>bookDao是private修饰的，外部类无法直接方法</li>
<li>外部类只能通过属性的set方法进行访问</li>
<li>对外部类来说，setBookDao方法名，去掉set后首字母小写是其属性名<ul>
<li>为什么是去掉set首字母小写?</li>
<li>这个规则是set方法生成的默认规则，set方法的生成是把属性名首字母大写前面加set形成的方法名</li>
</ul>
</li>
<li>所以按照名称注入，其实是和对应的set方法有关，但是如果按照标准起名称，属性名和set对应的名是一致的</li>
</ul>
</li>
<li><p>如果按照名称去找对应的bean对象，找不到则注入Null</p>
</li>
<li><p>当某一个类型在IOC容器中有多个对象，按照名称注入只找其指定名称对应的bean对象，不会报错</p>
</li>
</ul>
<p>两种方式介绍完后，以后用的更多的是&#x3D;&#x3D;按照类型&#x3D;&#x3D;注入。</p>
<p>最后对于依赖注入，需要注意一些其他的配置特征:</p>
<ol>
<li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li>
<li>使用按类型装配时（byType）必须保障容器中相同类型的bean唯一，推荐使用</li>
<li>使用按名称装配时（byName）必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li>
<li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li>
</ol>

        <h3 id="5-4-集合注入"   >
          <a href="#5-4-集合注入" class="heading-link"><i class="fas fa-link"></i></a>5.4 集合注入</h3>
      <p>前面我们已经能完成引入数据类型和简单数据类型的注入，但是还有一种数据类型&#x3D;&#x3D;集合&#x3D;&#x3D;，集合中既可以装简单数据类型也可以装引用数据类型，对于集合，在Spring中该如何注入呢?</p>
<p>先来回顾下，常见的集合类型有哪些?</p>
<ul>
<li>数组</li>
<li>List</li>
<li>Set</li>
<li>Map</li>
<li>Properties</li>
</ul>
<p>针对不同的集合类型，该如何实现注入呢?</p>

        <h4 id="5-4-1-环境准备"   >
          <a href="#5-4-1-环境准备" class="heading-link"><i class="fas fa-link"></i></a>5.4.1 环境准备</h4>
      <ul>
<li>创建一个Maven项目</li>
<li>pom.xml添加依赖</li>
<li>resources下添加spring的配置文件applicationContext.xml</li>
</ul>
<p>这些步骤和前面的都一致，大家可以快速的拷贝即可，最终项目的结构如下:</p>
<p><img src="/images/1629807579330.png"></p>
<p>(1)项目中添加添加BookDao、BookDaoImpl类</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//setter....方法省略，自己使用工具生成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>(2)resources下提供spring的配置文件，applicationContext.xml</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>(3)编写AppForDICollection运行类，加载Spring的IOC容器，并从中获取对应的bean对象</p>
<figure class="highlight java"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForDICollection</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">BookDao</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookDao) ctx.getBean(<span class="string">&quot;bookDao&quot;</span>);</span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>接下来，在上面这个环境中来完成<code>集合注入</code>的学习:</p>
<p>下面的所以配置方式，都是在bookDao的bean标签中使用<property>进行注入</p>
<figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.BookDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-2-注入数组类型数据"   >
          <a href="#5-4-2-注入数组类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.2 注入数组类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-3-注入List类型数据"   >
          <a href="#5-4-3-注入List类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.3 注入List类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>chuanzhihui<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-4-注入Set类型数据"   >
          <a href="#5-4-4-注入Set类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.4 注入Set类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itcast<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>itheima<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>boxuegu<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-5-注入Map类型数据"   >
          <a href="#5-4-5-注入Map类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.5 注入Map类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;henan&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kaifeng&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>


        <h4 id="5-4-6-注入Properties类型数据"   >
          <a href="#5-4-6-注入Properties类型数据" class="heading-link"><i class="fas fa-link"></i></a>5.4.6 注入Properties类型数据</h4>
      <figure class="highlight xml"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>henan<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>kaifeng<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure>

<p>配置完成后，运行下看结果:</p>
<p><img src="/images/1629808046783.png"></p>
<p><strong>说明：</strong></p>
<ul>
<li>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写<code>&lt;array&gt;</code>、<code>&lt;list&gt;</code>、<code>&lt;set&gt;</code>、<code>&lt;map&gt;</code>、<code>&lt;props&gt;</code>标签</li>
<li>List的底层也是通过数组实现的，所以<code>&lt;list&gt;</code>和<code>&lt;array&gt;</code>标签是可以混用</li>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;ref&gt;</code>标签，这种方式用的比较少</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/18463/">C++指针和结构体的浅显认知</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-25</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-25</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">1.4k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">8分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>因为数据结构中会设计到C++的一些基本指针操作，在进行算法的时候或多或少链表，哈希表，二叉树也会涉及一些相应的指针操作，而本人对于C++这么博大精深的语言体系又只有浅浅的一些了解，所以将这些数据结构涉及到的底层的指针做一个简单的知识梳理，方便以后在理解算法的时候尽量少花点笔墨放在基础语法知识上。</p>
<hr>

        <h1 id="1-指针"   >
          <a href="#1-指针" class="heading-link"><i class="fas fa-link"></i></a>1. 指针</h1>
      
        <h2 id="1-1-指针的意义"   >
          <a href="#1-1-指针的意义" class="heading-link"><i class="fas fa-link"></i></a>1.1 指针的意义</h2>
      <p>对于C++程序的一个数据，我们一般需要做到关注他如下的三个部分：</p>
<ul>
<li><code>data</code> : 数据的内容</li>
<li><code>address</code> : 数据的地址（存储位置）</li>
<li><code>dtype</code> : 数据的类型</li>
</ul>
<p>那么平时我们在定义一个变量的时候，一般只会定义他的数据类型和数据的内容(<code>int a = 5</code>)，那么他的地址又指的是什么呢？</p>
<p>我们可以这样去理解：<mark>代码中出现的变量存放在主机里存储器中的一个个存储单元中，每一个存储单元都有一个地址。</mark>换而言之，我们作为程序员更多的会去关注字面值的内容，而地址更像是计算机底层程序自己考虑的。当我们定义完一个变量要去调用他的时候，我们需要进行的操作仅仅是运用运算符<code>=</code>, 而计算机底层则需要对应的去寻找这个变量的地址，再将其调用出来。指针像是一种<strong>工具</strong>，模拟了这种过程，我们可以通过指针<u><strong>直接知道其指向的地址</strong></u>，也可以<u><strong>获取他指向的值</strong></u>。</p>
<p>用听起来厉害一点的话来讲就是：**<font color=red>指针可以精准控制了内存中的地址，从而高效率的传递和更改数据。</font>**</p>

        <h2 id="1-2-指针和引用"   >
          <a href="#1-2-指针和引用" class="heading-link"><i class="fas fa-link"></i></a>1.2 指针和引用</h2>
      <ul>
<li><p>&amp; ： 取地址运算符<br>针对于变量，<code>&amp; + 变量名称</code>表示的是该变量在内存中的地址。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code></p>
</li>
<li><p>*： 间接运算符</p>
</li>
</ul>
<p>针对的是指针，<code>* + 指针名称</code>表示引用该指针指向的值。<br><code>*p</code>表示取p指针指向地址的值<br><code>int* p</code>表示p的数据类型是<mark>指向int类型的指针</mark></p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">cout&lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>* p = &amp;a; <span class="comment">//表示p是指向int类型的a变量的地址的指针</span></span><br><span class="line">cout&lt;&lt; *p &lt;&lt;endl;</span><br></pre></td></tr></table></div></figure>
<p>输出的结果是：<code>004FFDE0</code>; <code>10</code></p>
<p><font size=2>某种意义上，int*  p &#x3D;int * p ; 但是他们表示的含义完全不同。左值定义了一个指针，右值定义了一个变量。但是他们最终的结果是相等的。但是要注意的是，在程序编译器中，int* p1, p2指的是定义一个p1为指向int类型的指针，p2为int类型的变量。</font></p>
<hr>

        <h1 id="2-结构体"   >
          <a href="#2-结构体" class="heading-link"><i class="fas fa-link"></i></a>2. 结构体</h1>
      
        <h2 id="2-1-结构体的定义"   >
          <a href="#2-1-结构体的定义" class="heading-link"><i class="fas fa-link"></i></a>2.1 结构体的定义</h2>
      <p>类似于类，可以表示一个需要用各种数据类型表示的数据集体，如学生有他的姓名年龄，那么此时就需要进行结构体的定义，将学生封装为<code>char</code>类型的姓名和包括<code>int</code>类型的年龄。<br><br>具体在C++中表达如下：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>他在数据结构中用处十分之大，比如链表中需要定义<code>data</code>和<code>next</code>，又比如在二叉树中需要定义双亲和头节点等。都需要用到结构体。</p>

        <h2 id="2-2-结构体的初始化"   >
          <a href="#2-2-结构体的初始化" class="heading-link"><i class="fas fa-link"></i></a>2.2 结构体的初始化</h2>
      <p>结构体的初始化有如下两种方式：</p>
<ul>
<li>通过直接定义初始化<br><code>struct Student s1;</code>：表示构造出一个数据类型为<code>Student</code>的学生变量<code>s1</code>。<br>注意：此类型构造需要确定结构体定义的位置，如果在同一个方法内可以调用，在不同方法内不能调用。如果结构体被设置为全局则每个方法都可以引用。</li>
<li>在构造时完成初始化<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,s1,s2</span><br></pre></td></tr></table></div></figure>
这样就表示<code>s1,s2</code>两个变量是<code>Student</code>类型，并且再后续无需再定义就可以直接使用，在构造的时候就完成了初始化。</li>
</ul>

        <h2 id="2-3-typedef关键字"   >
          <a href="#2-3-typedef关键字" class="heading-link"><i class="fas fa-link"></i></a>2.3 typedef关键字</h2>
      <p><code>typedef</code>关键字可以简化结构体变量的初始化，通过该关键字可以给结构体起别名，从而直接实现通过别名来进行调用。</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">char</span>[<span class="number">20</span>] name;</span><br><span class="line">  <span class="type">int</span> age;</span><br><span class="line">&#125;,S,s1</span><br></pre></td></tr></table></div></figure>
<blockquote>
<p>其中，S为结构体的别名，s1为结构体类型的变量。</p>
</blockquote>

        <h2 id="2-4-结构体成员变量的调用"   >
          <a href="#2-4-结构体成员变量的调用" class="heading-link"><i class="fas fa-link"></i></a>2.4 结构体成员变量的调用</h2>
      <p>通过<code>.</code>的形式调用。<br>如<code>s1.age</code>表示第一名学生的年龄；<code>s2.name</code>表示第二名学生的姓名。</p>
<hr>

        <h1 id="3-指向结构体的指针"   >
          <a href="#3-指向结构体的指针" class="heading-link"><i class="fas fa-link"></i></a>3. 指向结构体的指针</h1>
      <p>此时结构体可以视为数据类型，所以指针定义写法和原先指针写法差别不大。<br><code>struct Student* p= &amp;s1</code></p>
<blockquote>
<p>指向结构体Student的指针p(左值)，指向(&#x3D;)数据类型为Student的s1的地址(右值)。</p>
</blockquote>
<ul>
<li><font size=4 color=red><b>指针访问结构体成员变量</b></font><br>用箭头函数：<br><code>p-&gt;name</code><blockquote>
<p>无需带变量名，因为p指向了地址，知道需要获取哪个变量的值</p>
</blockquote>
</li>
</ul>
<hr>
<p>本篇只针对于目前个人认为可能会在数据结构中用到的知识点，对于真正的指针和结构体的知识知识九牛一毛不尽完整，而对于有关于理解数据结构语法有帮助的知识点，如有遗漏或者后续想到的，接下来再来进行补充。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/post/16107/">Hello World</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="fa fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2022-11-18</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="fa fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2022-11-30</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="fa fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">80</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="fa fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">1分</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/" >Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/" >documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html" >troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues" >GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html" >Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server"   >
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/server.html" >Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files"   >
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html" >Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites"   >
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html" >Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><a class="extend prev" rel="prev" href="/page/2/"><i class="fas fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/myphoto.png" alt="avatar"></div><p class="sidebar-ov-author__text">道阻且长,行则将至</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://plus.google.com/" target="_blank" rel="noopener" data-popover="Google" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-google"></i></span></a><a class="sidebar-ov-social-item" href="https://twitter.com/" target="_blank" rel="noopener" data-popover="Twitter" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-twitter"></i></span></a><a class="sidebar-ov-social-item" href="https://youtube.com/" target="_blank" rel="noopener" data-popover="Youtube" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-youtube"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-cn" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fa fa-heart"></i></span><span>Arong</span></div><div>加油！一起学习一起成长</div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script src="/js/utils.js?v=2.1.1"></script><script src="/js/stun-boot.js?v=2.1.1"></script><script src="/js/scroll.js?v=2.1.1"></script><script src="/js/header.js?v=2.1.1"></script><script src="/js/sidebar.js?v=2.1.1"></script></body></html>